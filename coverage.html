
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>binarytree: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">binarysearch/binarytree/allocate.go (100.0%)</option>
				
				<option value="file1">binarysearch/binarytree/assert.go (25.0%)</option>
				
				<option value="file2">binarysearch/binarytree/avl.go (100.0%)</option>
				
				<option value="file3">binarysearch/binarytree/avl_bottomup.go (100.0%)</option>
				
				<option value="file4">binarysearch/binarytree/avl_joinbased.go (0.0%)</option>
				
				<option value="file5">binarysearch/binarytree/balancers.go (70.4%)</option>
				
				<option value="file6">binarysearch/binarytree/conc.go (0.0%)</option>
				
				<option value="file7">binarysearch/binarytree/draw.go (0.0%)</option>
				
				<option value="file8">binarysearch/binarytree/joinbased.go (0.0%)</option>
				
				<option value="file9">binarysearch/binarytree/lbst.go (0.0%)</option>
				
				<option value="file10">binarysearch/binarytree/lbst_bottomup.go (0.0%)</option>
				
				<option value="file11">binarysearch/binarytree/lbst_joinbased.go (0.0%)</option>
				
				<option value="file12">binarysearch/binarytree/lbst_relaxed.go (0.0%)</option>
				
				<option value="file13">binarysearch/binarytree/lbst_topdown.go (0.0%)</option>
				
				<option value="file14">binarysearch/binarytree/measurements.go (0.0%)</option>
				
				<option value="file15">binarysearch/binarytree/node.go (49.6%)</option>
				
				<option value="file16">binarysearch/binarytree/partition.go (52.5%)</option>
				
				<option value="file17">binarysearch/binarytree/randomized.go (0.0%)</option>
				
				<option value="file18">binarysearch/binarytree/rank_balanced.go (33.3%)</option>
				
				<option value="file19">binarysearch/binarytree/rank_balanced_ravl_bottomup.go (0.0%)</option>
				
				<option value="file20">binarysearch/binarytree/rank_balanced_ravl_topdown.go (0.0%)</option>
				
				<option value="file21">binarysearch/binarytree/rank_balanced_redblack_bottomup.go (100.0%)</option>
				
				<option value="file22">binarysearch/binarytree/rank_balanced_redblack_relaxed.go (0.0%)</option>
				
				<option value="file23">binarysearch/binarytree/rank_balanced_redblack_relaxed_bottomup.go (0.0%)</option>
				
				<option value="file24">binarysearch/binarytree/rank_balanced_redblack_relaxed_topdown.go (0.0%)</option>
				
				<option value="file25">binarysearch/binarytree/rank_balanced_wavl.go (0.0%)</option>
				
				<option value="file26">binarysearch/binarytree/rank_balanced_wavl_bottomup.go (0.0%)</option>
				
				<option value="file27">binarysearch/binarytree/rank_balanced_wavl_joinbased.go (0.0%)</option>
				
				<option value="file28">binarysearch/binarytree/rank_balanced_wavl_topdown.go (0.0%)</option>
				
				<option value="file29">binarysearch/binarytree/sandbox.go (0.0%)</option>
				
				<option value="file30">binarysearch/binarytree/skiplist_ziptree.go (0.0%)</option>
				
				<option value="file31">binarysearch/binarytree/splay.go (0.0%)</option>
				
				<option value="file32">binarysearch/binarytree/split.go (0.0%)</option>
				
				<option value="file33">binarysearch/binarytree/treap_fingertree.go (0.0%)</option>
				
				<option value="file34">binarysearch/binarytree/treap_joinbased.go (0.0%)</option>
				
				<option value="file35">binarysearch/binarytree/treap_topdown.go (0.0%)</option>
				
				<option value="file36">binarysearch/binarytree/tree.go (29.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package binarytree

import (
   arenas "arena"
)

//type Allocator interface {
//   allocate(Node) *Node
//}

// Arena is a binary search tree node arena that uses a memory arena.
//
// Using an arena significantly reduces the overhead and impact of the garbage
// collector and improves the locality of nodes that belong to the same tree.
//
type Arena struct {
   *arenas.Arena
}

// Free releases all the memory allocated by this arena.
//func (arena *Allocator) Free() {
//  ((*arena.Arena)(arena)).Free()
//}
//func (arena *Allocator) Free() {
//   ((*arena.Arena)(arena)).Free()
//}

func (tree *Tree) allocate(node Node) (allocated *Node) <span class="cov8" title="1">{
   if tree.arena == nil </span><span class="cov8" title="1">{
      tree.arena = arenas.NewArena()
   }</span>
   // measurement(&amp;allocations, 1)
   <span class="cov8" title="1">allocated = arenas.New[Node](tree.arena)
   *allocated = node
   return</span>
}

// Allocates memory for a new node and copies the given node into that memory.
//func (arena *Arena) allocate(node Node) (allocated *Node) {
//   if arena.Arena == nil {
//      fmt.Println("arena is nil")
//      arena.Arena = arenas.NewArena()
//   }
//   // measurement(&amp;allocations, 1)
//   allocated = arenas.New[Node](arena.Arena)
//  *allocated = node
//   return
//}

// ReferenceCounter is used to implemented copy-on-write persistence.
//
//   "Copy-on-write, sometimes referred to as implicit sharing or shadowing,
//    is a resource-management technique used in computer programming to
//    efficiently implement a "duplicate" or "copy" operation on modifiable
//    resources. If a resource is duplicated but not modified, it is not
//    necessary to create a new resource; the resource can be shared between
//    the copy and the original. Modifications must still create a copy, hence
//    the technique: the copy operation is deferred until the first write."
//
//   "By sharing resources in this way, it is possible to significantly reduce
//    the resource consumption of unmodified copies, while adding a small
//    overhead to resource-modifying operations."
//
//    https://en.wikipedia.org/wiki/Copy-on-write
//
// A tree can be made _immutable_ by always creating a clone of the tree before
// making a modification. Anything still referencing the previous version is not
// aware of the modification and every version can be used independently. This
// technique allows one implementation to be used as both in-place and immutable
// where the immutable variant simply creates a clone before each modification.
//
// To avoid copying the entire tree, multiple trees may reference the same node,
// allowing independent trees to share common subtrees in memory. We refer to
// a node as "shared" if at least one other tree also references it. To track
// how many other trees reference a given node, we maintain a "reference count".
//
// When the reference count is zero, it means that the node is not shared and is
// therefore considered a "unique reference" because no other trees reference it.
// A unique reference can be modified without the need to copy it first, and can
// therefore be modified "in-place". In short, if a tree never shares its nodes
// then none of its nodes will ever need to be copied.
//
type ReferenceCounter struct {
   refs uint64
}

// AddReference increments the reference count.
func (rc *ReferenceCounter) AddReference()  <span class="cov8" title="1">{
   rc.refs++
}</span>

// RemoveReference decrements the reference count.
func (rc *ReferenceCounter) RemoveReference()  <span class="cov8" title="1">{
   if rc.refs &gt; 0 </span><span class="cov8" title="1">{
      rc.refs--
   }</span>
}

// Adds a reference to the node to share it with another tree.
func (tree Tree) share(p *Node)  <span class="cov8" title="1">{
   if p != nil </span><span class="cov8" title="1">{
      p.AddReference()
   }</span>
}

// Removes one reference from the given node.
func (tree Tree) release(p *Node)  <span class="cov8" title="1">{
   if p != nil </span><span class="cov8" title="1">{
      p.RemoveReference()
   }</span>
}

// Determines whether a node is shared with at least one other tree.
func (tree Tree) shared(p *Node) bool <span class="cov8" title="1">{
   return (*p).refs &gt; 0
}</span>

// Replaces the given node with a copy only if the node shared with other trees.
func (tree Tree) copy(p **Node) <span class="cov8" title="1">{
   // assert(*p != nil)
   //
   // There is no need to copy the node if it is NOT shared with other trees.
   //
   if !tree.shared(*p) </span><span class="cov8" title="1">{
      return
   }</span>
   // A copy is required to modify the node stored at the given reference.
   //
   // Only the pointers to the left and right subtrees are copied, increasing
   // their reference counts by one and thereby sharing them with another tree.
   //
   <span class="cov8" title="1">tree.share((*p).l)
   tree.share((*p).r)

   // The resulting copy is a new allocation that has no other references to it,
   // so we decrease the reference count of the original node by one.
   defer tree.release(*p)

   // Allocate memory for a new node and copy the original values into it.
   //
   // Notice that this allocation uses the same arena as the original tree,
   // so all versions of a tree use the same arena and will be freed together.
   //
   *p = tree.allocate(Node{
      l: (*p).l,
      r: (*p).r,
      s: (*p).s,
      x: (*p).x,
      y: (*p).y,
   })</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package binarytree

// Assertions are checks within code to verify that certain conditions are met.
//
// Go does not support zero-cost assertions, so this project uses find/replace
// to toggle them with comments `//`. Tests enable them, code coverage disables
// them, as well as benchmarks and animations. Some assertions run in O(n) or
// worse, so they should always be disabled when performance matters.
//
//    `make assertions-on`   : enables assertions
//    `make assertions-off`  : disables assertions
//
func assert(condition bool) <span class="cov0" title="0">{
   if !condition </span><span class="cov0" title="0">{
      panic("assertion failed")</span>
   }
}

// Invariant checks are always evaluated even when assertions are disabled.
func invariant(condition bool) <span class="cov8" title="1">{
   if !condition </span><span class="cov0" title="0">{
      panic("invariant failed")</span>
   }
}</pre>
		
		<pre class="file" id="file2" style="display: none">package binarytree

import (
   "binarysearch/abstract/list"
   "binarysearch/utility"
)

type AVL struct {
   Tree
}

func (AVL) height(p *Node) int <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return -1
   }</span> else<span class="cov8" title="1"> {
      return int(p.y)
   }</span>
}

func (tree *AVL) calculateHeight(p *Node) <span class="cov8" title="1">{
   p.y = uint64(utility.Max(tree.height(p.l), tree.height(p.r)) + 1)
}</span>

func (tree *AVL) verifyHeight(p *Node) <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return
   }</span>
   <span class="cov8" title="1">invariant(utility.Difference(tree.height(p.l), tree.height(p.r)) &lt;= 1)

   invariant(tree.height(p) &gt; tree.height(p.l))
   invariant(tree.height(p) &gt; tree.height(p.r))

   tree.verifyHeight(p.l)
   tree.verifyHeight(p.r)</span>
}

func (tree *AVL) verifySize(p *Node, s list.Size) list.Size <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return 0
   }</span>
   <span class="cov8" title="1">sl := tree.verifySize(p.l, p.s)
   sr := tree.verifySize(p.r, s-p.s-1)

   invariant(s == sl+sr+1)
   return s</span>
}

func (tree *AVL) Verify() <span class="cov8" title="1">{
   tree.verifySize(tree.root, tree.size)
   tree.verifyHeight(tree.root)
}</span>

func (tree *AVL) balance(p *Node) *Node <span class="cov8" title="1">{
   if tree.height(p.r) &gt; tree.height(p.l)+1 </span><span class="cov8" title="1">{
      if tree.height(p.r.l) &gt; tree.height(p.r.r) </span><span class="cov8" title="1">{
         tree.rotateRL(&amp;p)
         tree.calculateHeight(p.l)
         tree.calculateHeight(p.r)
         tree.calculateHeight(p)
      }</span> else<span class="cov8" title="1"> {
         tree.rotateL(&amp;p)
         tree.calculateHeight(p.l)
         tree.calculateHeight(p)
      }</span>
   } else<span class="cov8" title="1"> if tree.height(p.l) &gt; tree.height(p.r)+1 </span><span class="cov8" title="1">{
      if tree.height(p.l.r) &gt; tree.height(p.l.l) </span><span class="cov8" title="1">{
         tree.rotateLR(&amp;p)
         tree.calculateHeight(p.l)
         tree.calculateHeight(p.r)
         tree.calculateHeight(p)
      }</span> else<span class="cov8" title="1"> {
         tree.rotateR(&amp;p)
         tree.calculateHeight(p.r)
         tree.calculateHeight(p)
      }</span>
   } else<span class="cov8" title="1"> {
      tree.calculateHeight(p)
   }</span>
   <span class="cov8" title="1">return p</span>
}

func (tree *AVL) Select(i list.Size) list.Data <span class="cov8" title="1">{
   // assert(i &lt; tree.size)
   return tree.lookup(tree.root, i)
}</span>

func (tree *AVL) Update(i list.Size, x list.Data) <span class="cov8" title="1">{
   // assert(i &lt; tree.size)
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *AVL) deleteMin(p *Node, min **Node) *Node <span class="cov8" title="1">{
   tree.copy(&amp;p)
   if p.l == nil </span><span class="cov8" title="1">{
      *min = p
      return p.r
   }</span>
   <span class="cov8" title="1">p.s = p.s - 1
   p.l = tree.deleteMin(p.l, min)
   return tree.balance(p)</span>
}

func (tree *AVL) deleteMax(p *Node, max **Node) *Node <span class="cov8" title="1">{
   tree.copy(&amp;p)
   if p.r == nil </span><span class="cov8" title="1">{
      *max = p
      return p.l
   }</span>
   <span class="cov8" title="1">p.r = tree.deleteMax(p.r, max)
   return tree.balance(p)</span>
}

func (tree *AVL) buildL(l, p, r *Node, sl list.Size) *Node <span class="cov8" title="1">{
   if tree.height(l)-tree.height(r) &lt;= 1 </span><span class="cov8" title="1">{
      p.l = l
      p.r = r
      p.s = sl
      tree.calculateHeight(p)
      return p
   }</span>
   <span class="cov8" title="1">tree.copy(&amp;l)
   l.r = tree.buildL(l.r, p, r, sl-l.s-1)
   return tree.balance(l)</span>
}

func (tree *AVL) buildR(l, p, r *Node, sl list.Size) *Node <span class="cov8" title="1">{
   if tree.height(r)-tree.height(l) &lt;= 1 </span><span class="cov8" title="1">{
      p.l = l
      p.r = r
      p.s = sl
      tree.calculateHeight(p)
      return p
   }</span>
   <span class="cov8" title="1">tree.copy(&amp;r)
   r.s = 1 + sl + r.s
   r.l = tree.buildR(l, p, r.l, sl)
   return tree.balance(r)</span>
}

func (tree *AVL) build(l, p, r *Node, sl list.Size) *Node <span class="cov8" title="1">{
   if tree.height(l) &gt; tree.height(r) </span><span class="cov8" title="1">{
      return tree.buildL(l, p, r, sl)
   }</span> else<span class="cov8" title="1"> {
      return tree.buildR(l, p, r, sl)
   }</span>
}

func (tree *AVL) joinL(l, r *Node, sl list.Size) (p *Node) <span class="cov8" title="1">{
   if tree.height(l)-tree.height(r) &lt;= 1 </span><span class="cov8" title="1">{
      return tree.build(tree.deleteMax(l, &amp;p), p, r, sl-1)
   }</span>
   <span class="cov8" title="1">tree.copy(&amp;l)
   l.r = tree.joinL(l.r, r, sl-l.s-1)
   return tree.balance(l)</span>
}

func (tree *AVL) joinR(l, r *Node, sl list.Size) (p *Node) <span class="cov8" title="1">{
   if tree.height(r)-tree.height(l) &lt;= 1 </span><span class="cov8" title="1">{
      return tree.build(l, p, tree.deleteMin(r, &amp;p), sl)
   }</span>
   <span class="cov8" title="1">tree.copy(&amp;r)
   r.s = sl + r.s
   r.l = tree.joinR(l, r.l, sl)
   return tree.balance(r)</span>
}

func (tree *AVL) join(l, r *Node, sl list.Size) (p *Node) <span class="cov8" title="1">{
   if r == nil </span><span class="cov8" title="1">{
      return l
   }</span>
   <span class="cov8" title="1">if l == nil </span><span class="cov8" title="1">{
      return r
   }</span>
   <span class="cov8" title="1">if tree.height(l) &gt; tree.height(r) </span><span class="cov8" title="1">{
      return tree.joinL(l, r, sl)
   }</span> else<span class="cov8" title="1"> {
      return tree.joinR(l, r, sl)
   }</span>
}

func (tree *AVL) Join(other AVL) AVL <span class="cov8" title="1">{
   tree.share(tree.root)
   tree.share(other.root)
   return AVL{
      Tree{
         arena: tree.arena,
         root:  tree.join(tree.root, other.root, tree.size),
         size:  tree.size + other.size,
      },
   }
}</span>

func (tree *AVL) split(p *Node, i, s list.Size) (l, r *Node) <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return
   }</span>
   <span class="cov8" title="1">tree.copy(&amp;p)
   if i &lt;= (*p).s </span><span class="cov8" title="1">{
      l, r = tree.split(p.l, i, p.s)
      r = tree.build(r, p, p.r, p.s-i)
   }</span> else<span class="cov8" title="1"> {
      l, r = tree.split(p.r, i-p.s-1, s-p.s-1)
      l = tree.build(p.l, p, l, p.s)
   }</span>
   <span class="cov8" title="1">return l, r</span>
}

func (tree *AVL) Split(i list.Position) (AVL, AVL) <span class="cov8" title="1">{
   // assert(i &lt;= tree.size)
   tree.share(tree.root)

   l, r := tree.split(tree.root, i, tree.size)

   return AVL{Tree{arena: tree.arena, root: l, size: i}},
      AVL{Tree{arena: tree.arena, root: r, size: tree.size - i}}
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package binarytree

import "binarysearch/abstract/list"

type AVLBottomUp struct {
   AVL
}

func (AVLBottomUp) New() list.List <span class="cov8" title="1">{
   return &amp;AVLBottomUp{}
}</span>

func (tree *AVLBottomUp) Clone() list.List <span class="cov8" title="1">{
   return &amp;AVLBottomUp{AVL{Tree: tree.Tree.Clone()}}
}</span>

func (tree *AVLBottomUp) insert(p *Node, i list.Position, x list.Data) *Node <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return tree.allocate(Node{x: x})
   }</span>
   <span class="cov8" title="1">tree.copy(&amp;p)
   if i &lt;= p.s </span><span class="cov8" title="1">{
      p.s = p.s + 1
      p.l = tree.insert(p.l, i, x)
      return tree.balance(p)
   }</span> else<span class="cov8" title="1"> {
      p.r = tree.insert(p.r, i-p.s-1, x)
      return tree.balance(p)
   }</span>
}

func (tree *AVLBottomUp) Insert(i list.Position, x list.Data) <span class="cov8" title="1">{
   tree.root = tree.insert(tree.root, i, x)
   tree.size++
}</span>

func (tree *AVLBottomUp) delete(p *Node, i list.Position, x *list.Data) *Node <span class="cov8" title="1">{
   tree.copy(&amp;p)
   if i == p.s </span><span class="cov8" title="1">{
      *x = p.x
      defer tree.release(p)
      return tree.join(p.l, p.r, p.s)
   }</span>
   <span class="cov8" title="1">if i &lt; p.s </span><span class="cov8" title="1">{
      p.s = p.s - 1
      p.l = tree.delete(p.l, i, x)
   }</span> else<span class="cov8" title="1"> {
      p.r = tree.delete(p.r, i-p.s-1, x)
   }</span>
   <span class="cov8" title="1">return tree.balance(p)</span>
}

func (tree *AVLBottomUp) Delete(i list.Position) (x list.Data) <span class="cov8" title="1">{
   // assert(i &lt; tree.size)
   tree.root = tree.delete(tree.root, i, &amp;x)
   tree.size--
   return
}</span>

// TODO: just inline this?
func (tree *AVLBottomUp) Join(other list.List) list.List <span class="cov8" title="1">{
   return &amp;AVLBottomUp{tree.AVL.Join(other.(*AVLBottomUp).AVL)}
}</span>

func (tree *AVLBottomUp) Split(i list.Position) (list.List, list.List) <span class="cov8" title="1">{
   l, r := tree.AVL.Split(i)
   return &amp;AVLBottomUp{l},
          &amp;AVLBottomUp{r}
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type AVLJoinBased struct {
   AVL
}

func (AVLJoinBased) New() List <span class="cov0" title="0">{
   return &amp;AVLJoinBased{}
}</span>

func (tree *AVLJoinBased) Clone() List <span class="cov0" title="0">{
   return &amp;AVLJoinBased{
      AVL: AVL{
         Tree: tree.Tree.Clone(),
      },
   }
}</span>

func (tree *AVLJoinBased) insert(p *Node, i Position, s Size, x *Node) *Node <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return x
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)

   sl := p.s
   sr := s - p.s - 1

   if i &lt;= p.s </span><span class="cov0" title="0">{
      p.s++
      return tree.build(tree.insert(p.l, i, sl, x), p, p.r, sl+1)
   }</span> else<span class="cov0" title="0"> {
      return tree.build(p.l, p, tree.insert(p.r, i-sl-1, sr, x), sl)
   }</span>
}

func (tree *AVLJoinBased) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.size)
   tree.root = tree.insert(tree.root, i, tree.size, tree.allocate(Node{x: x}))
   tree.size++
}</span>

func (tree AVLJoinBased) delete(p *Node, i Position, s Size, x *Data) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p)

   sl := p.s
   sr := s - p.s - 1

   if i == p.s </span><span class="cov0" title="0">{
      *x = p.x
      defer tree.release(p)
      return tree.join(p.l, p.r, sl)
   }</span>
   <span class="cov0" title="0">if i &lt; p.s </span><span class="cov0" title="0">{
      p.s--
      return tree.build(tree.delete(p.l, i, sl, x), p, p.r, sl-1)
   }</span> else<span class="cov0" title="0"> {
      return tree.build(p.l, p, tree.delete(p.r, i-sl-1, sr, x), sl)
   }</span>
}

func (tree *AVLJoinBased) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.size)
   tree.root = tree.delete(tree.root, i, tree.size, &amp;x)
   tree.size--
   return
}</span>

func (tree *AVLJoinBased) Join(other List) List <span class="cov0" title="0">{
   return &amp;AVLJoinBased{tree.AVL.Join(other.(*AVLJoinBased).AVL)}
}</span>

func (tree *AVLJoinBased) Split(i Position) (List, List) <span class="cov0" title="0">{
   l, r := tree.AVL.Split(i)
   return &amp;AVLJoinBased{l},
      &amp;AVLJoinBased{r}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/distribution"
   . "binarysearch/utility"
)

type Balancer interface {
   Restore(Tree) Tree
   Verify(Tree)
}

type Balance interface {
   isBalanced(x, y Size) bool
}

type Partition struct {
   Balance
}

func (strategy Partition) Restore(tree Tree) Tree <span class="cov8" title="1">{
   tree.root = strategy.balance(&amp;tree, tree.root, tree.size)
   return tree
}</span>

func (strategy Partition) balance(tree *Tree, p *Node, s Size) *Node <span class="cov8" title="1">{
   if s &lt; 3 </span><span class="cov8" title="1">{
      return p
   }</span>
   <span class="cov8" title="1">sl := p.sizeL()
   sr := p.sizeR(s)

   // assert(strategy.isBalanced(sl, sr) || sl &lt; sr)
   // assert(strategy.isBalanced(sr, sl) || sr &lt; sl)

   // Replace `p` by its underlying median if not balanced.
   if !strategy.isBalanced(sl, sr) || !strategy.isBalanced(sr, sl) </span><span class="cov8" title="1">{
      p = tree.partition(p, s &gt;&gt; 1)
   }</span>
   // Recursively balance the left and right subtrees.
   <span class="cov8" title="1">p.l = strategy.balance(tree, p.l, p.sizeL())
   p.r = strategy.balance(tree, p.r, p.sizeR(s))
   return p</span>
}

func (strategy Partition) verify(p *Node, s Size) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">sl := p.sizeL()
   sr := p.sizeR(s)

   invariant(strategy.isBalanced(sl, sr))
   invariant(strategy.isBalanced(sr, sl))

   strategy.verify(p.l, sl)
   strategy.verify(p.r, sr)</span>

}

func (strategy Partition) Verify(tree Tree) <span class="cov0" title="0">{
   strategy.verify(tree.root, tree.size)

}</span>



type Weight struct{}

func (balancer Weight) Restore(tree Tree) Tree <span class="cov8" title="1">{
   tree.root = balancer.balance(&amp;tree, tree.root, tree.size)
   return tree
}</span>

func (strategy Weight) balance(tree *Tree, p *Node, s Size) *Node <span class="cov8" title="1">{
   if s &lt; 3 </span><span class="cov8" title="1">{
      return p
   }</span>
   //sl := p.sizeL()
   //sr := p.sizeR(s)

   // assert(strategy.isBalanced(sl, sr) || sl &lt; sr)
   // assert(strategy.isBalanced(sr, sl) || sr &lt; sl)

   // Replace `p` by its underlying median if not balanced.
   <span class="cov8" title="1">if !strategy.isBalanced(p, s) </span><span class="cov8" title="1">{
      p = tree.partition(p, s &gt;&gt; 1)
   }</span>
   // Recursively balance the left and right subtrees.
   <span class="cov8" title="1">p.l = strategy.balance(tree, p.l, p.sizeL())
   p.r = strategy.balance(tree, p.r, p.sizeR(s))
   return p</span>
}

func (Weight) isBalanced(p *Node, s Size) bool <span class="cov8" title="1">{
   sl := p.sizeL()
   sr := p.sizeR(s)
   if sl &gt; sr </span><span class="cov8" title="1">{
      if p.l.sizeL() &gt; p.l.sizeR(sl) </span><span class="cov8" title="1">{
         if p.l.sizeL() &gt; sr </span><span class="cov8" title="1">{
            return false
         }</span> else <span class="cov8" title="1">{
            //
         }</span>
      } else<span class="cov8" title="1"> {
         if p.l.sizeR(sl) &gt; sr </span><span class="cov8" title="1">{
            return false
         }</span> else <span class="cov8" title="1">{
            //
         }</span>
      }
   } else<span class="cov8" title="1"> {
      if p.r.sizeR(sr) &gt; p.r.sizeL() </span><span class="cov8" title="1">{
         if p.r.sizeR(sr) &gt; sl </span><span class="cov8" title="1">{
            return false
         }</span> else <span class="cov8" title="1">{
            //
         }</span>
      } else<span class="cov8" title="1"> {
         if p.r.sizeL() &gt; sl </span><span class="cov8" title="1">{
            return false
         }</span> else <span class="cov8" title="1">{
            //
         }</span>
      }
   }
   <span class="cov8" title="1">return true</span>
   //return !SmallerLog2(x, y &gt;&gt; 1)
}

func (balancer Weight) Verify(tree Tree) <span class="cov8" title="1">{
   balancer.verify(tree.root, tree.size)
}</span>

func (balancer Weight) verify(p *Node, s Size) <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return
   }</span>
   // -1 &lt;= ⌊log₂(L)⌋ - ⌊log₂(R)⌋ &lt;= 1
   //invariant(Difference(Log2(p.sizeL()), Log2(p.sizeR(s))) &lt;= 1)
   //invariant(Difference(p.l.height(), p.r.height()) &lt;= 1)

   <span class="cov8" title="1">balancer.verify(p.l, p.sizeL())
   balancer.verify(p.r, p.sizeR(s))</span>
}



type Median struct{}

func (balancer Median) Restore(tree Tree) Tree <span class="cov8" title="1">{
   return Partition{balancer}.Restore(tree)
}</span>

func (balancer Median) Verify(tree Tree) <span class="cov8" title="1">{
   balancer.verify(tree.root, tree.size)
}</span>

// -1 &lt;= L - R &lt;= 1
func (balancer Median) verify(p *Node, s Size) <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return
   }</span>
   <span class="cov8" title="1">invariant(Difference(p.sizeL(), p.sizeR(s)) &lt;= 1)

   balancer.verify(p.l, p.sizeL())
   balancer.verify(p.r, p.sizeR(s))</span>
}

func (Median) isBalanced(x, y Size) bool <span class="cov8" title="1">{
   return !(x+1 &lt; y)
}</span>

type Height struct{}

func (balancer Height) Restore(tree Tree) Tree <span class="cov8" title="1">{
   return Partition{balancer}.Restore(tree)
}</span>

func (Height) isBalanced(x, y Size) bool <span class="cov8" title="1">{
   return !SmallerLog2(x+1, y)
}</span>

func (balancer Height) Verify(tree Tree) <span class="cov8" title="1">{
   balancer.verify(tree.root, tree.size)
}</span>

// A node is height-balanced when the difference between the height of its
// subtrees is no greater than 1, and both subtrees are also height-balanced.
//
// invariant(p.height() &lt;= FloorLog2(s))
func (balancer Height) verify(p *Node, s Size) <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return
   }</span>
   <span class="cov8" title="1">invariant(Difference(p.l.height(), p.r.height()) &lt;= 1)

   balancer.verify(p.l, p.sizeL())
   balancer.verify(p.r, p.sizeR(s))</span>
}

//
//func (balancer Weight) Balance(p *Node, s Size) *Node {
//   return PartitionBalancer{balancer}.balance(p, s)
//}
//
//func (balancer Median) Balance(p *Node, s Size) *Node {
//   return PartitionBalancer{balancer}.balance(p, s)
//}
//
//func (balancer Height) Balance(p *Node, s Size) *Node {
//   return PartitionBalancer{balancer}.balance(p, s)
//}

//
//type ArrayRebuilder struct {
//}
//
//func (balancer ArrayRebuilder) Restore(tree Tree) Tree {
//   tree.root = balancer.fromArray(tree, treeToArray(tree.root, tree.size), 1, tree.size)
//   return tree
//}
//
//func (balancer ArrayRebuilder) fromArray(tree Tree, values []Data, i, j Position) *Node {
//   if i &gt; j {
//      return nil
//   }
//   m := i + (j - i ) &gt;&gt; 1
//
//   return tree.allocate(Node{
//      x: values[m - 1],
//      s: m - i,
//      l: balancer.fromArray(tree, values, i, m - 1),
//      r: balancer.fromArray(tree, values, m + 1, j),
//   })
//}
//
//func (balancer ArrayRebuilder) Verify(tree Tree) {
//   invariant(tree.root.height() &lt;= int(Log2(tree.size)))
//}
//
//func treeToArray(p *Node, s Size) []Data {
//  array := make([]Data, s)
//  stack := make([]*Node, 0)
//  index := 0
//  for {
//     if p != nil {
//        stack = append(stack, p)
//        p = p.l
//     } else {
//        n := len(stack)
//        if n == 0 {
//           return array
//        }
//        p = stack[n-1]
//        stack = stack[:n-1]
//        array[index] = p.x
//        index++
//        p = p.r
//     }
//  }
//}

// https://web.eecs.umich.edu/~qstout/pap/CACM86.pdf
type DSW struct {
}

func (balancer DSW) Verify(tree Tree) <span class="cov8" title="1">{
   invariant(tree.root.height() &lt;= int(Log2(tree.size)))
}</span>

//func (tree Tree) fromVineToTree() Tree {
//   //leaves ← size + 1 − 2**⌊log2(size + 1))⌋
//
//   leaves := NextPowerOf2LessThanOrEqualTo(tree.size+1) - 1 //tree.size + 1 - (1 &lt;&lt; FloorLog2(tree.size + 1))  // size + 1 - (1 &lt;&lt; FloorLog2(size + 1))
//   tree.compress(tree.root, tree.size - leaves)
//   leaves = tree.size - leaves
//   for leaves &gt; 1 {
//      tree.compress(tree.root, leaves / 2)
//      leaves = leaves / 2
//   }
//   return tree
//}

func (balancer DSW) Restore(tree Tree) Tree <span class="cov8" title="1">{
   return balancer.toTree(balancer.toVine(tree))
}</span>

func (balancer DSW) toVine(tree Tree) Tree <span class="cov8" title="1">{
   n := Node{}
   l := &amp;n
   p := tree.root
   s := tree.size
   for p != nil </span><span class="cov8" title="1">{
      //tree.copy(&amp;p)
      for p.l != nil </span><span class="cov8" title="1">{
         p = p.rotateR()
         //tree.rotateR(&amp;p)
      }</span>
      <span class="cov8" title="1">l.r = p
      l = l.r
      p = p.r</span>
   }
   <span class="cov8" title="1">tree.root = n.r
   tree.size = s
   return tree</span>
}

func (balancer DSW) toTree(tree Tree) Tree <span class="cov8" title="1">{
   p := tree.root
   s := tree.size
   m := 1&lt;&lt;Log2(s+1) - 1

   p = balancer.compress(p, s-Size(m))
   for m &gt; 1 </span><span class="cov8" title="1">{
      p = balancer.compress(p, Size(m)&gt;&gt;1)
      m = m &gt;&gt; 1
   }</span>
   <span class="cov8" title="1">tree.root = p
   tree.size = s
   return tree</span>
}

func (balancer DSW) compress(p *Node, c Size) *Node <span class="cov8" title="1">{
   n := Node{}
   l := &amp;n
   n.r = p
   for ; c &gt; 0; c-- </span><span class="cov8" title="1">{
      l.r = p.rotateL()
      l = l.r
      p = l.r
   }</span>
   <span class="cov8" title="1">return n.r</span>
}

//func (tree Tree) compress(count Size) Tree {
//   n := Node{}
//   l := &amp;n
//   p := tree.root
//   for ; count &gt; 0; count-- {
//      tree.copy(&amp;p)
//      tree.rotateL(&amp;p)
//      l.r = p
//      l = l.r
//      p = p.r
//   }
//   tree.root = n.r
//   return tree
//}
//
//
// routine compress(root, count)
//    scanner ← root
//    for i ← 1 to count
//        child ← scanner.right
//        scanner.right ← child.right
//        scanner ← scanner.right
//        child.right ← scanner.left
//        scanner.left ← child

//n := Node{}
//l := &amp;n
//n.r = p
//for ; count &gt; 0; count-- {
//   p = p.rotateL()
//   l.r = p
//   l = l.r
//   p = p.r
//}
//return n.r

//if count == 0 {
//   return v
//}
//tree.rotateL(&amp;v)
//v.r = tree.compress(v.r, count - 1)
//return v
//

//for ; count &gt; 0; count-- {
//  tree.rotateL(v)
//  v = &amp;(*v).r
//}

//n := Node{}
//l := &amp;n
//p := *v
//for ; count &gt; 0; count-- {
//   p = p.rotateL()
//   l.r = p
//   l = l.r
//   p = p.r
//}
//*v = n.r

//
//func (tree Tree) fromVineToTree() Tree {
//   //p := tree.root
//   s := NextPowerOf2LessThanOrEqualTo(tree.size + 1) - 1
//   //var count = tree.size - s
//   for count := tree.size - s; count &gt; 0; count-- {
//      tree.compress(&amp;tree.root, count)
//   }
//   for s &gt; 1 {
//      for count := s / 2; count &gt; 0; count-- {
//         tree.compress(&amp;tree.root, count)
//      }
//      s = s / 2
//   }
//   return tree
//}
//
//func (tree Tree) compress(p **Node, count Size) {
//   for ; count &gt; 0; count-- {
//      tree.copy(p)
//      tree.rotateL(p)
//      p = &amp;(*p).r
//   }
//}

//
//func (tree Tree) fromVineToTree() Tree {
//   //leaves ← size + 1 − 2**⌊log2(size + 1))⌋
//
//   leaves := NextPowerOf2LessThanOrEqualTo(tree.size+1) - 1 //tree.size + 1 - (1 &lt;&lt; FloorLog2(tree.size + 1))  // size + 1 - (1 &lt;&lt; FloorLog2(size + 1))
//   tree.compress(tree.root, tree.size - leaves)
//   leaves = tree.size - leaves
//   for leaves &gt; 1 {
//      tree.compress(tree.root, leaves / 2)
//      leaves = leaves / 2
//   }
//   return tree
//}

//func (tree Tree) compress(p *Node, rotations Size) {
//   for ; rotations &gt; 0; rotations-- {
//      tree.rotateL(&amp;p)
//      tree.copy(&amp;p.r)
//      p = p.r
//   }
//}
//
//

// There is a clever morris-based traversal version that benchmarked slower.
//
//     // Convert tree to a "vine", i.e., a sorted linked list,
//    // using the right pointers to point to the next node in the list
//    tail ← root
//    rest ← tail.right
//    while rest ≠ nil
//        if rest.left = nil
//            tail ← rest
//            rest ← rest.right
//        else
//            temp ← rest.left
//            rest.left ← temp.right
//            temp.right ← rest
//            rest ← temp
//            tail.right ← temp

//   func (tree Tree) Vine(size Size) (root *Node) {
//    p := &amp;root
//    for ; size &gt; 0; size-- {
//      *p = tree.allocate(Node{})
//       p = &amp;(*p).r
//    }
//    return
//   }
func (Tree) Vine(size Size) Tree <span class="cov0" title="0">{
   t := Tree{}
   n := Node{}
   p := &amp;n
   for t.size = 0; t.size &lt; size; t.size++ </span><span class="cov0" title="0">{
      p.r = t.allocate(Node{})
      p = p.r
   }</span>
   <span class="cov0" title="0">t.root = n.r
   return t</span>
}

func (Tree) WorstCaseMedianVine(size Size) Tree <span class="cov0" title="0">{
   // assert(size &gt; 0)
   t := Tree{}
   n := Node{}
   p := &amp;n
   for t.size = 0; t.size &lt; (size-1)/2+1; t.size++ </span><span class="cov0" title="0">{
      p.r = t.allocate(Node{})
      p = p.r
   }</span>
   <span class="cov0" title="0">for ; t.size &lt; size; t.size++ </span><span class="cov0" title="0">{
      p.l = t.allocate(Node{})
      p.s = size - t.size
      p = p.l
   }</span>
   <span class="cov0" title="0">t.root = n.r
   return t</span>
}

// public void flatten(TreeNode root) {
//    if (root == null)
//        return;
//    flatten(root.right);
//    flatten(root.left);
//    root.right = prev;
//    root.left = null;
//    prev = root;
//}

// void flatten(TreeNode *root) {
//   while (root) {
//      if (root-&gt;left &amp;&amp; root-&gt;right) {
//         TreeNode* t = root-&gt;left;
//         while (t-&gt;right)
//            t = t-&gt;right;
//         t-&gt;right = root-&gt;right;
//      }

//
//        if(root-&gt;left)
//          root-&gt;right = root-&gt;left;
//      root-&gt;left = NULL;
//      root = root-&gt;right;
//   }
//}

//func (tree Tree) treeToVineAlt(p *Node) (vine *Node) {
//   if p == nil {
//      return nil
//   }
//   vine = p
//   for {
//      if p.l != nil &amp;&amp; p.r != nil {
//         t := p.l
//         for t.r != nil {
//            t = t.r
//         }
//         if p.r != nil {
//         }
//         t.r = p.r
//      }
//      if p.l != nil {
//         p.r = p.l
//      }
//      p.l = nil
//      p.s = 0
//      if p.r == nil {
//         break
//      }
//      p = p.r
//   }
//   return vine
//}

// TODO: make pointer
func (tree Tree) Randomize(access distribution.Distribution) Tree <span class="cov0" title="0">{
   tree.root = tree.randomize(access, tree.root, tree.size)
   return tree
}</span>

func (tree Tree) randomize(access distribution.Distribution, p *Node, s Size) *Node <span class="cov0" title="0">{
   // assert(p.size() == s)
   if p == nil </span><span class="cov0" title="0">{
      return nil
   }</span>
   <span class="cov0" title="0">p = tree.partition(p, access.LessThan(s))
   p.l = tree.randomize(access, p.l, p.sizeL())
   p.r = tree.randomize(access, p.r, p.sizeR(s))
   return p</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/utility"
)

// https://www.youtube.com/watch?v=o0NR9GrcHQo
//
// https://api.semanticscholar.org/CorpusID:21267485
// http://aleksandar-prokopec.com/publications/conc-trees/
// Prokopec, A., &amp; Odersky, M. (2015). Conc-Trees for Functional and Parallel Programming. LCPC.

type Conc struct {
   Tree
}

func (tree Conc) Count(p *Node) Size <span class="cov0" title="0">{
   if p.isLeaf() </span><span class="cov0" title="0">{
      return 1
   }</span> else<span class="cov0" title="0"> {
      return tree.Count(p.l) + tree.Count(p.r)
   }</span>
}

func (Conc) New() List <span class="cov0" title="0">{
   return &amp;Conc{}
}</span>

//func (tree Conc) build(values []Data, i, j Size) *Node {
//  size := j - i
//
//  if size == 0 { return nil }
//  if size == 1 { return tree.asLeaf(values[i]) }
//
//  m := i + size &gt;&gt; 1
//  l := tree.build(values, i, m)
//  r := tree.build(values, m, j)
//
//  return tree.link(l, r)
//}

func (tree *Conc) Clone() List <span class="cov0" title="0">{
   return &amp;Conc{
      Tree: tree.Tree.Clone(),
   }
}</span>

// Creates a leaf node containing the data `s`.
func (tree *Conc) asLeaf(x Data) *Node <span class="cov0" title="0">{
   return tree.allocate(Node{
      x: x,
      s: 1,
   })
}</span>

// This is the node constructor from the paper.
//
// Creates a &lt;&gt; node with subtrees `l` and `r`, caching the size and height of.
// Note that we store the height in the unused data field `s`.
func (tree *Conc) link(l, r *Node) *Node <span class="cov0" title="0">{
   return tree.allocate(Node{
      y: utility.Max(l.y, r.y) + 1,
      s: l.s + r.s,
      l: l,
      r: r,
   })
}</span>

// This is the &lt;&gt; (conc) function from the paper.
//
// Creates a reduced and balanced concatenation of two subtrees.
func (tree *Conc) balanced(l, r *Node) *Node <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>
   <span class="cov0" title="0">return tree.concat(l, r)</span>
}

func (tree *Conc) concat(l, r *Node) *Node <span class="cov0" title="0">{
   if l.y &gt; r.y &amp;&amp; ((l.y - r.y) &gt; 1) </span><span class="cov0" title="0">{
      if l.l.y &gt;= l.r.y </span><span class="cov0" title="0">{
         return tree.link(l.l, tree.concat(l.r, r))
      }</span>
      <span class="cov0" title="0">rr := tree.concat(l.r.r, r)
      if l.y-rr.y &lt; 3 </span><span class="cov0" title="0">{
         return tree.link(tree.link(l.l, l.r.l), rr)
      }</span> else<span class="cov0" title="0"> {
         return tree.link(l.l, tree.link(l.r.l, rr))
      }</span>
   }
   <span class="cov0" title="0">if r.y &gt; l.y &amp;&amp; ((r.y - l.y) &gt; 1) </span><span class="cov0" title="0">{
      if r.r.y &gt;= r.l.y </span><span class="cov0" title="0">{
         return tree.link(tree.concat(l, r.l), r.r)
      }</span>
      <span class="cov0" title="0">ll := tree.concat(l, r.l.l)
      if r.y-ll.y &lt; 3 </span><span class="cov0" title="0">{
         return tree.link(ll, tree.link(r.l.r, r.r))
      }</span> else<span class="cov0" title="0"> {
         return tree.link(tree.link(ll, r.l.r), r.r)
      }</span>
   }
   <span class="cov0" title="0">return tree.link(l, r)</span>
}

func (tree Conc) Select(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i).x
}</span>

func (tree Conc) lookup(p *Node, i Position) *Node <span class="cov0" title="0">{
   if p.isLeaf() </span><span class="cov0" title="0">{
      // assert(i == 0)
      return p
   }</span>
   <span class="cov0" title="0">if i &lt; p.l.s </span><span class="cov0" title="0">{
      return tree.lookup(p.l, i)
   }</span> else<span class="cov0" title="0"> {
      return tree.lookup(p.r, i-p.l.s)
   }</span>
}

func (tree *Conc) Update(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.root = tree.update(tree.root, i, x)
}</span>

func (tree *Conc) update(p *Node, i Position, x Data) *Node <span class="cov0" title="0">{
   if p.isLeaf() </span><span class="cov0" title="0">{
      return tree.asLeaf(x)
   }</span>
   <span class="cov0" title="0">if i &lt; p.l.s </span><span class="cov0" title="0">{
      return tree.link(tree.update(p.l, i, x), p.r)
   }</span> else<span class="cov0" title="0"> {
      return tree.link(p.l, tree.update(p.r, i-p.l.s, x))
   }</span>
}

func (tree *Conc) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.size++
   if tree.root == nil </span><span class="cov0" title="0">{
      tree.root = tree.asLeaf(x)
   }</span> else<span class="cov0" title="0"> {
      tree.root = tree.insert(tree.root, i, x)
   }</span>
}

func (tree *Conc) insert(p *Node, i Position, x Data) *Node <span class="cov0" title="0">{
   if p.isLeaf() </span><span class="cov0" title="0">{
      if i == 0 </span><span class="cov0" title="0">{
         return tree.link(tree.asLeaf(x), p)
      }</span> else<span class="cov0" title="0"> {
         return tree.link(p, tree.asLeaf(x))
      }</span>
   }
   <span class="cov0" title="0">if i &lt; p.l.s </span><span class="cov0" title="0">{
      return tree.balanced(tree.insert(p.l, i, x), p.r)
   }</span> else<span class="cov0" title="0"> {
      return tree.balanced(p.l, tree.insert(p.r, i-p.l.s, x))
   }</span>
}

func (tree *Conc) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.size--
   tree.root = tree.delete(tree.root, i, &amp;x)
   return
}</span>

func (tree *Conc) delete(p *Node, i Position, x *Data) *Node <span class="cov0" title="0">{
   if p.isLeaf() </span><span class="cov0" title="0">{
      *x = p.x
      return nil
   }</span>
   <span class="cov0" title="0">if i &lt; p.l.s </span><span class="cov0" title="0">{
      return tree.balanced(tree.delete(p.l, i, x), p.r)
   }</span> else<span class="cov0" title="0"> {
      return tree.balanced(p.l, tree.delete(p.r, i-p.l.s, x))
   }</span>
}

func (tree Conc) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   if i == 0 </span><span class="cov0" title="0">{
      return &amp;Conc{Tree: Tree{arena: tree.arena}},
         &amp;Conc{Tree: Tree{arena: tree.arena, root: tree.root, size: tree.size}}
   }</span> else<span class="cov0" title="0"> {
      l, r := tree.split(tree.root, i)
      return &amp;Conc{Tree: Tree{arena: tree.arena, root: l, size: i}}, &amp;Conc{Tree: Tree{arena: tree.arena, root: r, size: tree.size - i}}
   }</span>
}

func (tree Conc) split(p *Node, i Position) (*Node, *Node) <span class="cov0" title="0">{
   if p.isLeaf() </span><span class="cov0" title="0">{
      if i == 0 </span><span class="cov0" title="0">{
         return nil, p
      }</span> else<span class="cov0" title="0"> {
         return p, nil
      }</span>
   }
   <span class="cov0" title="0">if i &lt; p.l.s </span><span class="cov0" title="0">{
      l, r := tree.split(p.l, i)
      return l, tree.balanced(r, p.r)
   }</span> else<span class="cov0" title="0"> {
      l, r := tree.split(p.r, i-p.l.s)
      return tree.balanced(p.l, l), r
   }</span>
}

func (tree Conc) Join(other List) List <span class="cov0" title="0">{
   return &amp;Conc{
      Tree: Tree{
         arena: tree.arena,
         root:  tree.join(other.(*Conc)),
         size:  tree.size + other.Size(),
      },
   }
}</span>

func (tree *Conc) join(other *Conc) *Node <span class="cov0" title="0">{
   return tree.balanced(tree.root, other.root)
}</span>

func (tree Conc) Each(visit func(Data)) <span class="cov0" title="0">{
   tree.inorder(tree.root, visit)
}</span>

func (tree Conc) inorder(p *Node, visit func(Data)) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">if p.isLeaf() </span><span class="cov0" title="0">{
      visit(p.x)
   }</span> else<span class="cov0" title="0"> {
      tree.inorder(p.l, visit)
      tree.inorder(p.r, visit)
   }</span>
}

func (tree Conc) Verify() <span class="cov0" title="0">{
   tree.verifyLeaves(tree.root)
   tree.verifyHeights(tree.root)
   tree.verifySizes(tree.root)
}</span>

func (tree Conc) verifyHeights(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">if p.isLeaf() </span><span class="cov0" title="0">{
      invariant(p.y == 0)
   }</span> else<span class="cov0" title="0"> {
      invariant(utility.Difference(p.l.y, p.r.y) &lt;= 1)
   }</span>
   <span class="cov0" title="0">tree.verifyHeights(p.l)
   tree.verifyHeights(p.r)</span>
}

func (tree Conc) verifyLeaves(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant((p.l == nil) == (p.r == nil))
   tree.verifyLeaves(p.l)
   tree.verifyLeaves(p.r)</span>
}

func (tree Conc) verifySizes(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant(p.s == Conc{}.Count(p))
   tree.verifySizes(p.l)
   tree.verifySizes(p.r)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package binarytree

import (
   . "binarysearch/utility"
   . "fmt"
   "io"
)

// Draw is a basic implementation of a binary tree drawing algorithm, derived
// from how I was drawing them by hand for many years. The algorithm is only
// suitable for small trees because the width is exponential and wraps very
// quickly in the terminal. The main purpose of this algorithm is to debug cases
// that trigger invariant checks and to understand and verify some balancing and
// building algorithms along the way.
//
// For example:
//
//   Tree{}.New(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 50, 100).Draw()
//
//
//                                   7                     &lt;-- 1st level
//                           ╭───────┴───────╮
//                           4               20            &lt;-- 2nd level
//                       ╭───┴───╮       ╭───┴───╮
//                       2       6       9      100        &lt;-- 3rd level
//                     ╭─┴─╮   ╭─╯     ╭─┴─╮   ╭─╯
//                     1   3   5       8   10  50          &lt;-- 4th level
//
// Notice the following properties:
//
//   - Nodes are drawn centered above subtrees.
//   - Nodes are positioned in-order from left to right.
//   - Nodes are assumed to have a value no greater than 3-characters,
//     which is plenty in most cases before the tree becomes too wide.
func (p *Node) Draw(writer io.Writer) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   // The first stage of the drawing algorithm collects nodes, level by level.
   //
   // For example, in the example drawing abive, the first level would have
   // one node (7), the second level would have two nodes: (4) and (20), etc.
   //
   // Nodes that are nil are collected as well to know where to draw spacing.
   //
   <span class="cov0" title="0">var level []*Node    // Current level
   var levels [][]*Node // Collected levels

   level = append(level, p)
   for </span><span class="cov0" title="0">{
      // Collect the nodes for the next level by iterating through the nodes
      // of the current level, until all nodes in the next level are nil.
      //
      var next []*Node
      for i, node := range level </span><span class="cov0" title="0">{
         if node != nil </span><span class="cov0" title="0">{
            break</span>
         }
         <span class="cov0" title="0">if i == len(level)-1 </span><span class="cov0" title="0">{ // All nodes in the next level are nil.
            goto drawing</span>
         }
      }
      <span class="cov0" title="0">for _, node := range level </span><span class="cov0" title="0">{
         if node == nil </span><span class="cov0" title="0">{
            next = append(next, nil)
            next = append(next, nil)
         }</span> else<span class="cov0" title="0"> {
            next = append(next, node.l)
            next = append(next, node.r)
         }</span>
      }
      // Add the collected nodes to the list of level, move on to the next.
      <span class="cov0" title="0">levels = append(levels, level)
      level = next</span>
   }
   // Now we can start drawing.
   //
   // For each level, we first draw the line-work (except for the first level),
   // followed by the node values of that level.
   //
<span class="cov0" title="0">drawing:
   for depth, level := range levels </span><span class="cov0" title="0">{
      //
      // The spacing is a measure of the separation between nodes, increasing
      // exponentially from the bottom to the top of the tree.
      //
      spacing := 1 &lt;&lt; (len(levels) - depth)

      // Skip the line-work for the first level because the root has to parent.
      if depth &gt; 0 </span><span class="cov0" title="0">{
         //
         // The first space to write is the prefix, or the leading gap from the
         // left of the frame before the first node of the level is to be drawn.
         //
         Fprint(writer, Repeat(" ", spacing-1))

         // Here begins the line-work.
         //
         // There are 3 possibilities for each pair of nodes on this level:
         //
         //    ╭───┴───╮      Left and right are not nil.
         //
         //    ╭───╯          Left is not nil, right is nil.
         //
         //        ╰───╮      Left is nil, right is not nil.
         //
         // We first draw the left side, then the connector to the parent node,
         // then the right side, as indicated by these vertical guides:
         //
         //       | |
         //   ╭───|┴|───╮
         //       | |
         //   ╭───|╯|
         //       | |
         //       |╰|───╮
         //       | |
         //
         for i, node := range level </span><span class="cov0" title="0">{
            if i%2 == 0 </span><span class="cov0" title="0">{
               //
               // Left node.
               //
               // Here we draw a shape like this: ╭──, under which the node will
               // be placed in the next row of the drawing. When the node is nil
               // we just draw more spacing until we are under the parent, where
               // the line for the next node (the right subtree) will be drawn.
               //
               if node == nil </span><span class="cov0" title="0">{
                  Fprint(writer, Repeat(" ", spacing))
               }</span> else<span class="cov0" title="0"> {
                  Fprint(writer, "╭")
                  Fprint(writer, Repeat("─", spacing-1))
               }</span>
            } else<span class="cov0" title="0"> {
               //
               // Right node.
               //
               // Here we first draw the connector to the parent: ╯ or ┴ or ╰
               // depending on whether the left or right nodes are nil, then
               // the line towards where the right child will be drawn, then the
               // connector to the right node (all spacing if the node is nil).
               //
               // Because the index is odd, we know that a previous index must
               // exist, so it is safe to access the left node as level[i-1].
               //
               if node == nil </span><span class="cov0" title="0">{
                  //
                  // The right node of the pair is nil, so either the left node
                  // is also nil (no line-work at all), or the left node is not
                  // nil, in which case it is the only non-nil node under the
                  // parent and we can use the ╯ connector to complete the pair.
                  //
                  if level[i-1] == nil </span><span class="cov0" title="0">{
                     Fprint(writer, " ") // Left and right are nil.
                  }</span> else<span class="cov0" title="0"> {
                     Fprint(writer, "╯") // Left is not nil, right is nil.
                  }</span>
                  <span class="cov0" title="0">if i &lt; len(level)-1 </span><span class="cov0" title="0">{
                     Fprint(writer, Repeat(" ", spacing))
                  }</span>
                  //
                  // The right node is nil so the line-work for this pair is now
                  // complete. The final step is to draw the spacing before the
                  // line-work for the next pair should start. However, only add
                  // this spacing if this is not the last node of the level.
                  //
               } else<span class="cov0" title="0"> {
                  //
                  // The right node of the pair is NOT nil, so either the left
                  // node is nil (╰) or they are both not nil (┴).
                  //
                  if level[i-1] == nil </span><span class="cov0" title="0">{
                     Fprint(writer, "╰") // Left is nil, right is not nil.
                  }</span> else<span class="cov0" title="0"> {
                     Fprint(writer, "┴") // Left and right are not nil.
                  }</span>
                  //
                  // The right node is NOT nil, so we need to now draw a line
                  // from the parent connector to where the right node will be
                  // drawn below. Given that there is a node here, we can draw
                  // the downward connector (╮) exactly above that node.
                  //
                  <span class="cov0" title="0">Fprint(writer, Repeat("─", spacing-1))
                  Fprint(writer, "╮")</span>
               }
               //
               // The final step is to draw the spacing that separates this pair
               // from the next pair on this level. However, to avoid wrapping
               // and unnecessary trailing whitespace, we only add this spacing
               // if this was not the last pair of the level.
               //
               <span class="cov0" title="0">if i &lt; len(level)-1 </span><span class="cov0" title="0">{
                  Fprint(writer, Repeat(" ", spacing))
                  Fprint(writer, Repeat(" ", spacing-1))
               }</span>
            }
         }
         <span class="cov0" title="0">Fprint(writer, "\n")</span>
      }
      // The line-work for this level is done, and we are now on a new line.
      // Here we follow the same pattern as with the line-work, except instead
      // of lines we draw the `value` of each node.
      //
      // There is no need to consider differences between left and right because
      // all nodes are drawn the same and the spacing is consistent.
      //
      <span class="cov0" title="0">for i, node := range level </span><span class="cov0" title="0">{
         //
         // When the node to draw is nil, we need to draw empty space below the
         // missing line-work, up to where the node value would have been drawn
         // if it was not nil, and then more spacing for the separation leading
         // up to the next pair when it is not the last node of the level.
         //
         if node == nil </span><span class="cov0" title="0">{
            if i &lt; len(level)-1 </span><span class="cov0" title="0">{
               Fprint(writer, Repeat(" ", spacing))
               Fprint(writer, Repeat(" ", spacing))
            }</span>
         } else<span class="cov0" title="0"> {
            //
            // When the node to draw is NOT nil, we center the node's value (x)
            // within a cell of 3-characters and prefix it with node separation.
            //
            value := Centered(String(node.s), " ", 3)
            Fprint(writer, Repeat(" ", spacing-len(value)+1))
            Fprint(writer, value)

            // Draw spacing to create separation between this pair and the next
            // pair of nodes on this level. However, to avoid line-wrapping and
            // unnecessary trailing whitespace, we only add this spacing if this
            // is not the last node of the current level.
            if i &lt; len(level)-1 </span><span class="cov0" title="0">{
               Fprint(writer, Repeat(" ", spacing-1))
            }</span>
         }
      }
      <span class="cov0" title="0">Fprint(writer, "\n")</span>
   }
}

//TODO: is Draw ever _not_ stdout?
func (tree Tree) Draw(writer io.Writer) <span class="cov0" title="0">{
   tree.root.Draw(writer)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package binarytree

import . "binarysearch/abstract/list"

// TODO just inline all of this stuff

type Joiner interface {
   join3(l, p, r *Node, sl, sr Size) *Node
   join2(l, r *Node, sl, sr Size) *Node
}

type JoinBased struct {
   Tree
   Joiner
}

func (tree JoinBased) insert(p *Node, i Position, s Size, x *Node) *Node <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return x
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)

   sl := p.s
   sr := s - p.s - 1

   if i &lt;= p.s </span><span class="cov0" title="0">{
      p.s++
      return tree.join3(tree.insert(p.l, i, sl, x), p, p.r, sl+1, sr)
   }</span> else<span class="cov0" title="0"> {
      return tree.join3(p.l, p, tree.insert(p.r, i-sl-1, sr, x), sl, sr+1)
   }</span>
}

func (tree JoinBased) delete(p *Node, i Position, s Size, x *Data) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p)

   sl := p.s
   sr := s - p.s - 1

   if i == p.s </span><span class="cov0" title="0">{
      *x = p.x
      defer tree.release(p)
      return tree.join2(p.l, p.r, sl, sr)
   }</span>
   <span class="cov0" title="0">if i &lt; p.s </span><span class="cov0" title="0">{
      p.s--
      return tree.join3(tree.delete(p.l, i, sl, x), p, p.r, sl-1, sr)
   }</span> else<span class="cov0" title="0"> {
      return tree.join3(p.l, p, tree.delete(p.r, i-sl-1, sr, x), sl, sr-1)
   }</span>
}

func (tree JoinBased) split(p *Node, i, s Size) (l, r *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)

   sl := p.s
   sr := s - p.s - 1

   if i &lt;= (*p).s </span><span class="cov0" title="0">{
      l, r = tree.split(p.l, i, sl)
      r = tree.join3(r, p, p.r, sl-i, sr)
   }</span> else<span class="cov0" title="0"> {
      l, r = tree.split(p.r, i-sl-1, sr)
      l = tree.join3(p.l, p, l, sl, i-sl-1)
   }</span>
   <span class="cov0" title="0">return l, r</span>
}

func (tree JoinBased) splitToBST(p *Node, i, s Size) (Tree, Tree) <span class="cov0" title="0">{
   l, r := tree.split(p, i, s)
   return Tree{arena: tree.arena, root: l, size: i},
      Tree{arena: tree.arena, root: r, size: s - i}
}</span>

//func (tree JoinBased) join(l, r *Node, sl, sr Size) *Node {
//   return tree.join2(l, r, sl, sr)
//}
</pre>
		
		<pre class="file" id="file9" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/utility"
)

type LBST struct {
   Tree
}

// Determines if two sizes are balanced.
func (LBST) isBalanced(x, y Size) bool <span class="cov0" title="0">{
   //
   // Given the sizes of two subtrees, an LBST is balanced when the difference
   // between the integer parts of log₂(x) and log₂(y) is no greater than one.
   //
   //                  -1 &lt;= ⌊log₂(x)⌋ - ⌊log₂(y)⌋ &lt;= 1
   //
   // This is similar to the height-balance rule, except instead of height we
   // consider the discrete the binary logarithm of the size of the subtree.
   //
   //    When `x` &lt; `y`, is ⌊log₂(x)⌋ at most one less than ⌊log₂(y)⌋?
   //
   // Looking at the binary representation, the most significant bit or MSB is
   // the left-most bit set to 1, starting from the right. The bit position of
   // the MSB is equal to the floor of the binary logarithm of that integer.
   //
   //                                        00001101
   //                                             ↖
   //                                              MSB of 13 is at position 3
   //                                              log₂(13) = ~3.7
   //
   // Using this information, we can compare the bit position of the MSB of each
   // size without the need to calculate the logarithm itself.
   //
   // The MSB of `y` is within one step of the MSB of `x` (therefore balanced)
   // if after shifting `y` right, the MSB of `x` is less than the MSB of `y`.
   //
   //    Would it take more than one shift to align the MSBs of `y` and `x`?
   //
   // For example:
   //
   //              ↓                       ↓                    ↓
   //       s:   00100000              00001000              00010001
   //       y:   00111001              00010001              01001101
   //              ↑ BALANCED             ↑ BALANCED          ↑ NOT BALANCED
   //
   //
   // Returns true for s &gt; y.
   //
   // Complexity: O(1)
   //
   return !utility.SmallerLog2(x, y&gt;&gt;1)
}</span>

func (LBST) singleRotation(x, y Size) bool <span class="cov0" title="0">{
   return !utility.SmallerLog2(x, y)
}</span>

func (tree LBST) join2(l *Node, r *Node, sl, sr Size) (k *Node) <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>
   <span class="cov0" title="0">if sl &lt;= sr </span><span class="cov0" title="0">{
      r = tree.extractMin(r, sr, &amp;k)
      return tree.join3(l, k, r, sl, sr-1)
   }</span> else<span class="cov0" title="0"> {
      l = tree.extractMax(l, sl, &amp;k)
      return tree.join3(l, k, r, sl-1, sr)
   }</span>
}

func (tree LBST) extractMin(p *Node, s Size, x **Node) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p)
   if p.l == nil </span><span class="cov0" title="0">{
      *x = p
      p = p.r
      return p
   }</span>
   <span class="cov0" title="0">sl := p.s
   sr := s - p.s - 1

   p.l = tree.extractMin(p.l, p.s, x)
   p.s--

   if !tree.isBalanced(sl-1, sr) </span><span class="cov0" title="0">{
      srl := (*p).r.s
      srr := sr - (*p).r.s - 1
      //
      if tree.singleRotation(srr, srl) </span><span class="cov0" title="0">{
         tree.rotateL(&amp;p)
      }</span> else<span class="cov0" title="0"> {
         tree.rotateRL(&amp;p)
      }</span>
   }
   <span class="cov0" title="0">return p</span>
}

func (tree LBST) extractMax(p *Node, s Size, x **Node) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p)
   if p.r == nil </span><span class="cov0" title="0">{
      *x = p
      p = p.l
      return p
   }</span>
   <span class="cov0" title="0">sl := p.s
   sr := s - p.s - 1

   p.r = tree.extractMax(p.r, sr, x)
   if !tree.isBalanced(sr-1, sl) </span><span class="cov0" title="0">{
      if tree.singleRotation((*p).l.s, sl-(*p).l.s-1) </span><span class="cov0" title="0">{
         tree.rotateR(&amp;p)
      }</span> else<span class="cov0" title="0"> {
         tree.rotateLR(&amp;p)
      }</span>
   }
   <span class="cov0" title="0">return p</span>
}

func (tree LBST) Join(that LBST) LBST <span class="cov0" title="0">{
   l := tree
   r := that
   tree.share(l.root)
   tree.share(r.root)
   return LBST{
      Tree{
         arena: tree.arena,
         root:  tree.join2(l.root, r.root, l.size, r.size),
         size:  l.size + r.size,
      },
   }
}</span>

func (tree LBST) join3(l, k, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   //tree.pathcopy(&amp;k) // optional?
   if sl &lt;= sr </span><span class="cov0" title="0">{
      return tree.assembleRL(k, l, r, sl, sr)
   }</span> else<span class="cov0" title="0"> {
      return tree.assembleLR(k, l, r, sl, sr)
   }</span>
}

func (tree *LBST) assembleLR(p *Node, l, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   if tree.isBalanced(sr, sl) </span><span class="cov0" title="0">{
      p.l = l
      p.r = r
      p.s = sl
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;l)

   sll := l.s
   slr := sl - l.s - 1

   l.r = tree.assembleLR(p, l.r, r, slr, sr)
   slr = 1 + sr + slr

   if !tree.isBalanced(sll, slr) </span><span class="cov0" title="0">{

      srr := slr - l.r.s - 1
      srl := l.r.s

      if tree.singleRotation(srr, srl) </span><span class="cov0" title="0">{
         tree.rotateL(&amp;l)
      }</span> else<span class="cov0" title="0"> {
         tree.rotateRL(&amp;l)
      }</span>
   }
   <span class="cov0" title="0">return l</span>
}

func (tree *LBST) assembleRL(p *Node, l, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   if tree.isBalanced(sl, sr) </span><span class="cov0" title="0">{
      p.l = l
      p.r = r
      p.s = sl
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;r)

   srl := r.s
   srr := sr - r.s - 1

   r.l = tree.assembleRL(p, l, r.l, sl, srl)
   r.s = 1 + sl + srl

   if !tree.isBalanced(srr, r.s) </span><span class="cov0" title="0">{
      if tree.singleRotation(r.l.s, r.s-r.l.s-1) </span><span class="cov0" title="0">{
         tree.rotateR(&amp;r)
      }</span> else<span class="cov0" title="0"> {
         tree.rotateLR(&amp;r)
      }</span>
   }
   <span class="cov0" title="0">return r</span>
}

func (tree LBST) Split(i Position) (LBST, LBST) <span class="cov0" title="0">{
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: tree}.split(tree.root, i, tree.size)

   return LBST{Tree{arena: tree.arena, root: l, size: i}},
      LBST{Tree{arena: tree.arena, root: r, size: tree.size - i}}
}</span>

func (tree LBST) verifyBalance(p *Node, s Size) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant(utility.Difference(utility.Log2(p.sizeL()), utility.Log2(p.sizeR(s))) &lt;= 1)

   tree.verifyBalance(p.l, p.sizeL())
   tree.verifyBalance(p.r, p.sizeR(s))</span>
}

func (tree LBST) verifyHeight(root *Node, size Size) <span class="cov0" title="0">{
   invariant(root.height() &lt;= int(2*utility.Log2(size)))
}</span>

func (tree LBST) verify(root *Node, size Size) <span class="cov0" title="0">{
   tree.verifySizes()
   tree.verifyBalance(root, size)
   tree.verifyHeight(root, size)
}</span>

func (tree LBST) Verify() <span class="cov0" title="0">{
   tree.verify(tree.root, tree.size)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package binarytree

import . "binarysearch/abstract/list"

//
// import (
//    . "trees/abstract/list"
//    "trees/math"
// )
//
// type LBST struct {
//    BST
//    SizeBalance
// }
//
// // Determines if the weights of two subtrees are balanced.
// //
// // For the scapegoat tree, we use the logarithmic balance rule, where the
// // discrete binary logarithm of the two sizes differ by at most 1.
// //
// //                 -1 &lt;= floor(log₂(s)) - floor(log₂(y)) &lt;= 1
// //
// // Considering the binary representation, we look at the left-most bit set to 1,
// // the most-significant bit. 00001101
// //                                ↖
// //                                 MSB at position 3
// //
// // The position of the most-significant bit, from the right starting at zero,
// // is equal to the floor of the binary logarithm. The balance test is then to
// // determine if the MSB is at most one step different in either direction.
// // For example:
// //
// //              ↓                       ↓                    ↓
// //       s:   00100000              00001000              00010001
// //       y:   00111001              00010001              01001101
// //              ↑ BALANCED             ↑ BALANCED          ↑ NOT BALANCED
// //
// // When `s` &lt;= `y`, as in the examples above, we can shift the bits of `y` one
// // position to the right, then, if the MSB of `s` is less than the MSB of `y`
// // it means that the MSB of `y` was at least 2 positions ahead - not balance.
// //
// // Complexity: O(1)
// //
// func (LBST) New(s ...Value) List {
//    return &amp;LBST{BST: BST{}.ofArray(s)}
// }
//
//
//
// func (tree LBST) Clone() List {
//    tree.root.share()
//    return &amp;tree
// }
//
//
//
//
//
// func (tree LBST) verify(root *Node, size Size) {
//    tree.verifyPosition(root)
//    tree.verifyWeight(root, size)
//    tree.verifyHeight(root, size)
// }
//
// func (tree LBST) Verify() {
//    tree.verify(tree.root, tree.size)
// }
//
// func (tree LBST) verifyHeight(root *Node, size Size) {
//    invariant(root.height() &lt;= MaximumPathLength(2 * math.Log2(size)))
// }
//
// func (tree LBST) verifyWeight(p *Node, s Size) {
//    tree.SizeBalance.verify(p, s)
// }
//
//
//
// func (tree *LBST) insert(p *Node, s Size, i Position, s Value) *Node {
//    if p == nil {
//       return &amp;Node{s: s}
//    }
//    p = p.Copy()
//    sl := p.s
//    sr := p.sizeR(s)
//
//    if i &lt;= p.s {
//       p.l = tree.insert(p.l, sl, i, s)
//       p.s++
//
//       if !tree.Balanced(sr, sl + 1) {
//          if !tree.singleRotation((*p).l.s, (*p).l.sizeR(p.s)) {
//             rotateLR(&amp;p)
//          } else {
//             rotateR(&amp;p)
//          }
//       }
//    } else {
//       p.r = tree.insert(p.r, sr, i - sl - 1, s)
//
//       if !tree.Balanced(sl, sr + 1) {
//          if !tree.singleRotation((*p).r.sizeR(sr + 1), (*p).r.s) {
//             rotateRL(&amp;p)
//          } else {
//             rotateL(&amp;p)
//          }
//       }
//    }
//    return p
// }
//
//
//
// // wbst Delete(key s, wbst t)
// // {  size sA, sB;
// //  if (s == t-&gt;k) return delete_root(t);
// //  t-&gt;s--;
// //  if (s &lt; t-&gt;k)
// //    { t-&gt;l = Delete(s, t-&gt;l);
// //      if (!balanced(t-&gt;l-&gt;s, t-&gt;r-&gt;s)) t = inc_left(t);
// //    }
// //   else
// //    { t-&gt;r = Delete(s, t-&gt;r);
// //      if (!balanced(t-&gt;r-&gt;s, t-&gt;l-&gt;s)) t = inc_right(t);
// //    }
// //  return t;
// // }
// //
// // wbst delete_root(wbst t)
// // { node *p;
// // if (t-&gt;s == 1) { freeNode(t); return null; }
// // if (t-&gt;l-&gt;s &gt; t-&gt;r-&gt;s)
// // { p-&gt;l = extract_maximum(t-&gt;l, &amp;p);
// // p-&gt;r = t-&gt;r;
// // }
// // else
// // { p-&gt;r = extract_minimum(t-&gt;r, &amp;p);
// // p-&gt;l = t-&gt;l;
// // }
// // p-&gt;s = t-&gt;s - 1;
// // freeNode(t);
// // return p;
// // }
// //
// // wbst delete_root(wbst t)
// // { node *p;
// //  if (t-&gt;s == 1) { freeNode(t); return null; }
// //  if (t-&gt;l-&gt;s &gt; t-&gt;r-&gt;s)
// //    { p-&gt;l = extract_maximum(t-&gt;l, &amp;p);
// //      p-&gt;r = t-&gt;r;
// //    }
// //   else
// //    { p-&gt;r = extract_minimum(t-&gt;r, &amp;p);
// //      p-&gt;l = t-&gt;l;
// //    }
// //  p-&gt;s = t-&gt;s - 1;
// //  freeNode(t);
// //  return p;
// // }
// //
// //
// // wbst delete_root(wbst t)
// // { node *p;
// //  if (t-&gt;s == 1) { freeNode(t); return null; }
// //  if (t-&gt;l-&gt;s &gt; t-&gt;r-&gt;s)
// //    { p-&gt;l = extract_maximum(t-&gt;l, &amp;p);
// //      p-&gt;r = t-&gt;r;
// //    }
// //   else
// //    { p-&gt;r = extract_minimum(t-&gt;r, &amp;p);
// //      p-&gt;l = t-&gt;l;
// //    }
// //  p-&gt;s = t-&gt;s - 1;
// //  freeNode(t);
// //  return p;
// // }
//
//
// // wbst extract_maximum(wbst t, wbst *u)
// // { size sA, sB;
// //  if (t-&gt;r == null) { *u = t; t = t-&gt;l; }
// //   else
// //    { t-&gt;r = extract_maximum(t-&gt;r, u);
// //      t-&gt;s--;
// //      if (!balanced(t-&gt;r-&gt;s, t-&gt;l-&gt;s)) t = inc_right(t);
// //    }
// //  return t;
// // }
// //
// // wbst extract_minimum(wbst t, wbst *u)
// // { size sA, sB;
// //  if (t-&gt;l == null) { *u = t; t = t-&gt;r; }
// //   else
// //    { t-&gt;l = extract_minimum(t-&gt;l, u);
// //      t-&gt;s--;
// //      if (!balanced(t-&gt;l-&gt;s, t-&gt;r-&gt;s)) t = inc_left(t);
// //    }
// //  return t;
// // }
// //
//
// // func (tree WeightBalancedDownUp) extractMin(p **Node, s Size) Value {
// //    if p == nil {
// //       return p
// //    }
// //    p = p.Copy()
// //
// //    sl := p.s
// //    sr := p.sizeR(s)
// //
// //    p.l = tree.extractMin(p.l, sl, s)
// //    p.s--
// //
// //    if !tree.Balanced(sl - 1, sr) {
// //       if !tree.singleRotation(p.r.sizeR(sr), p.r.s) {
// //          rotateRL(&amp;p)
// //       } else {
// //          rotateL(&amp;p)
// //       }
// //    }
// //    return p
// // }
// //
// // func (tree WeightBalancedDownUp) extractMax(p **Node, s Size) Value {
// //    if p == nil {
// //       return p
// //    }
// //    p = p.Copy()
// //
// //    sl := p.s
// //    sr := p.sizeR(s)
// //
// //    p.r = tree.extractMax(p.r, sr, s)
// //
// //    if !tree.Balanced(sr - 1, sl) {
// //       if !tree.singleRotation(p.l.s, p.l.sizeR(sl)) {
// //          rotateLR(&amp;p)
// //       } else {
// //          rotateR(&amp;p)
// //       }
// //    }
// //    return p
// // }
//
// //
//
// func (tree LBST) extractMin(p **Node, s Size) (s Value) {
//    *p = tree.delete(*p, s, 0, &amp;s)
//    return
// }
//
// func (tree LBST) extractMax(p **Node, s Size) (s Value) {
//    *p = tree.delete(*p, s, s - 1, &amp;s)
//    return
// }
// func (tree *LBST) dissolve(p *Node, s Size, s *Value) *Node {
//    p = p.Copy()
//
//    sl := p.s
//    sr := p.sizeR(s)
//
//    // assert(tree.Balanced(sl, sr))
//    // assert(tree.Balanced(sr, sl))
//
//    *s = p.s
//
//    if p.l == nil { return p.r }
//    if p.r == nil { return p.l }
//
//    if sr &gt; sl {
//       p.s = tree.extractMin(&amp;p.r, sr)
//    } else {
//       p.s = tree.extractMax(&amp;p.l, sl)
//       p.s--
//    }
//    return p
// }
//
// func (tree LBST) join(l *Node, r *Node, sl, sr Size) *Node {
//    if l == nil { return r }
//    if r == nil { return l }
//    if sl &lt;= sr {
//       return tree.build(tree.extractMin(&amp;r, sr), l, r, sl, sr - 1)
//    } else {
//       return tree.build(tree.extractMax(&amp;l, sl), l, r, sl - 1, sr)
//    }
// }
//
// func (tree *LBST) delete(p *Node, s Size, i Position, s *Value) *Node {
//
//
//
//    if i == p.s {
//       return tree.dissolve(p, s, s)
//       // return p
//       // dissolve
//    }
//    p = p.Copy()
//
//    sl := p.s
//    sr := p.sizeR(s)
//
//    if i &lt; p.s {
//       p.l = tree.delete(p.l, sl, i, s)
//       p.s--
//
//       if !tree.Balanced(sl - 1, sr) {
//          //
//          //
//          //
//          srl := (*p).r.s
//          srr := (*p).r.sizeR(sr)
//          //
//          if tree.singleRotation(srr, srl) {
//             rotateL(&amp;p)
//          } else {
//             rotateRL(&amp;p)
//          }
//       }
//
//    } else {
//       p.r = tree.delete(p.r, sr, i - sl - 1, s)
//
//       if !tree.Balanced(sr - 1, sl) {
//          //
//          //
//          //
//          sll := (*p).l.s
//          slr := (*p).l.sizeR(sr)
//          //
//          if tree.singleRotation(sll, slr) {
//             rotateR(&amp;p)
//          } else {
//             rotateLR(&amp;p)
//          }
//       }
//    }
//    return p
// }
//
// func (tree *LBST) Insert(i Position, s Value) {
//    // assert(i &lt;= tree.Size())
//    tree.root = tree.insert(tree.root, tree.size, i, s)
//    tree.size++
// }
//
// func (tree *LBST) Delete(i Position) (s Value) {
//    // assert(i &lt; tree.Size())
//    tree.root = tree.delete(tree.root, tree.size, i, &amp;s)
//    tree.size--
//    return
// }
//
// func (tree LBST) Join(that List) List {
//    l := tree
//    r := that.(*LBST)
//    return &amp;LBST{
//       BST: BST{
//          root: tree.join(l.root.share(), r.root.share(), l.size, r.size),
//          size: l.size + r.size,
//       },
//    }
// }
//
// func (tree LBST) build(s Value, l, r *Node, sl, sr Size) *Node {
//    if sl &lt;= sr {
//       return tree.joinR(s, l, r, sl, sr)
//    } else {
//       return tree.joinL(s, l, r, sl, sr)
//    }
// }
//
// func (tree *LBST) joinL(s Value, l, r *Node, sl, sr Size) *Node {
//    if tree.Balanced(sr, sl) {
//       return &amp;Node{
//          s: s,
//          l: l,
//          r: r,
//          s: sl,
//       }
//    }
//    l = pathcopy(l)
//
//    sll := l.s
//    slr := l.sizeR(sl)
//
//    l.r = tree.joinL(s, l.r, r, slr, sr)
//    slr = 1 + sr + slr
//
//    if !tree.Balanced(sll, slr) {
//       if tree.singleRotation(l.r.sizeR(slr), l.r.s) {
//          l = l.rotateL()
//       } else {
//          l = l.rotateRL()
//       }
//    }
//    return l
// }
//
// func (tree *LBST) joinR(s Value, l, r *Node, sl, sr Size) *Node {
//    if tree.Balanced(sl, sr) {
//       return &amp;Node{ // TODO: Why does this have to copy?
//          s: s,
//          l: l,
//          r: r,
//          s: sl,
//       }
//    }
//    r = pathcopy(r)
//
//    srl := r.s
//    srr := r.sizeR(sr)
//
//    r.l = tree.joinR(s, l, r.l, sl, srl)
//    r.s = 1 + sl + srl
//
//    if !tree.Balanced(srr, r.s) {
//       if tree.singleRotation(r.l.s, r.l.sizeR(r.s)) {
//          r = r.rotateR()
//       } else {
//          r = r.rotateLR()
//       }
//    }
//    return r
// }
//
// func (tree LBST) split(p *Node, i, s Size) (l, r *Node){
//    if p == nil {
//       return
//    }
//    p = p.Copy()
//    sl, sr := p.sizeLR(s)
//
//    if i &lt;= (*p).s {
//       l, r = tree.split(p.l, i, sl)
//          r = tree.build(p.s, r, p.r, sl - i, sr)
//    } else {
//       l, r = tree.split(p.r, i - sl - 1, sr)
//          l = tree.build(p.s, p.l, l, sl, i - sl - 1)
//    }
//    return l, r
// }
//
// func (tree LBST) Split(i Position) (List, List) {
//    // assert(i &lt;= tree.Size())
//
//    l, r := tree.split(tree.root.share(), i, tree.size)
//
//    return &amp;LBST{BST: BST{root: l, size: i}},
//           &amp;LBST{BST: BST{root: r, size: tree.size - i}}
// }

type LBSTBottomUp struct {
   LBST
}

// Determines if the weights of two subtrees are balanced.
//
// For the scapegoat tree, we use the logarithmic balance rule, where the
// discrete binary logarithm of the two sizes differ by at most 1.
//
//   -1 &lt;= floor(log₂(s)) - floor(log₂(y)) &lt;= 1
//
// Considering the binary representation, we look at the left-most bit set to 1,
// the most-significant bit. 00001101
//
//   ↖
//    MSB at position 3
//
// The position of the most-significant bit, from the right starting at zero,
// is equal to the floor of the binary logarithm. The balance test is then to
// determine if the MSB is at most one step different in either direction.
// For example:
//
//          ↓                       ↓                    ↓
//   s:   00100000              00001000              00010001
//   y:   00111001              00010001              01001101
//          ↑ BALANCED             ↑ BALANCED          ↑ NOT BALANCED
//
// When `s` &lt;= `y`, as in the examples above, we can shift the bits of `y` one
// position to the right, then, if the MSB of `s` is less than the MSB of `y`
// it means that the MSB of `y` was at least 2 positions ahead - not balance.
//
// Complexity: O(1)
func (LBSTBottomUp) New() List <span class="cov0" title="0">{
   return &amp;LBSTBottomUp{}
}</span>

func (tree *LBSTBottomUp) Clone() List <span class="cov0" title="0">{
   return &amp;LBSTBottomUp{
      LBST: LBST{
         Tree: tree.Tree.Clone(),
      },
   }
}</span>

func (tree *LBSTBottomUp) insert(p *Node, s Size, i Position, x Data) *Node <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return tree.allocate(Node{x: x})
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)
   sl := p.s
   sr := s - p.s - 1

   // assert(tree.isBalanced(sl, sr))
   // assert(tree.isBalanced(sr, sl))

   if i &lt;= p.s </span><span class="cov0" title="0">{
      p.l = tree.insert(p.l, sl, i, x)
      p.s = p.s + 1

      if !tree.isBalanced(sr, sl+1) </span><span class="cov0" title="0">{
         if !tree.singleRotation((*p).l.s, p.s-(*p).l.s-1) </span><span class="cov0" title="0">{
            tree.rotateLR(&amp;p)
         }</span> else<span class="cov0" title="0"> {
            tree.rotateR(&amp;p)
         }</span>
      }
   } else<span class="cov0" title="0"> {
      p.r = tree.insert(p.r, sr, i-sl-1, x)

      if !tree.isBalanced(sl, sr+1) </span><span class="cov0" title="0">{
         if !tree.singleRotation(sr+1-(*p).r.s-1, (*p).r.s) </span><span class="cov0" title="0">{
            tree.rotateRL(&amp;p)
         }</span> else<span class="cov0" title="0"> {
            tree.rotateL(&amp;p)
         }</span>
      }
   }
   <span class="cov0" title="0">return p</span>
}

func (tree *LBSTBottomUp) delete(p *Node, s Size, i Position, x *Data) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p)

   sl := p.s
   sr := s - p.s - 1

   // assert(tree.isBalanced(sl, sr))
   // assert(tree.isBalanced(sr, sl))

   if i == p.s </span><span class="cov0" title="0">{
      defer tree.release(p)
      *x = p.x
      if p.l == nil </span><span class="cov0" title="0">{
         return p.r
      }</span>
      <span class="cov0" title="0">if p.r == nil </span><span class="cov0" title="0">{
         return p.l
      }</span>
      <span class="cov0" title="0">if sl &gt; sr </span><span class="cov0" title="0">{
         var max *Node
         p.l = tree.extractMax(p.l, sl, &amp;max)
         p.x = max.x
         p.s--
      }</span> else<span class="cov0" title="0"> {
         var min *Node
         p.r = tree.extractMin(p.r, sr, &amp;min)
         p.x = min.x
      }</span>
      <span class="cov0" title="0">return p</span>
   }
   <span class="cov0" title="0">if i &lt; p.s </span><span class="cov0" title="0">{
      p.l = tree.delete(p.l, sl, i, x)
      p.s--

      if !tree.isBalanced(sl-1, sr) </span><span class="cov0" title="0">{
         srl := (*p).r.s
         srr := sr - (*p).r.s - 1
         if tree.singleRotation(srr, srl) </span><span class="cov0" title="0">{
            tree.rotateL(&amp;p)
         }</span> else<span class="cov0" title="0"> {
            tree.rotateRL(&amp;p)
         }</span>
      }

   } else<span class="cov0" title="0"> {
      p.r = tree.delete(p.r, sr, i-sl-1, x)

      if !tree.isBalanced(sr-1, sl) </span><span class="cov0" title="0">{
         sll := (*p).l.s
         slr := sl - (*p).l.s - 1
         if tree.singleRotation(sll, slr) </span><span class="cov0" title="0">{
            tree.rotateR(&amp;p)
         }</span> else<span class="cov0" title="0"> {
            tree.rotateLR(&amp;p)
         }</span>
      }
   }
   <span class="cov0" title="0">return p</span>
}

func (tree *LBSTBottomUp) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *LBSTBottomUp) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *LBSTBottomUp) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.root = tree.insert(tree.root, tree.size, i, x)
   tree.size++
}</span>

func (tree *LBSTBottomUp) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.root = tree.delete(tree.root, tree.size, i, &amp;x)
   tree.size--
   return
}</span>

func (tree LBSTBottomUp) Split(i Position) (List, List) <span class="cov0" title="0">{
   l, r := tree.LBST.Split(i)

   return &amp;LBSTBottomUp{l},
      &amp;LBSTBottomUp{r}
}</span>

func (tree LBSTBottomUp) Join(that List) List <span class="cov0" title="0">{
   return &amp;LBSTBottomUp{tree.LBST.Join(that.(*LBSTBottomUp).LBST)}
}</span>

// wbst Delete(key s, wbst t)
// {  size sA, sB;
//  if (s == t-&gt;k) return delete_root(t);
//  t-&gt;s--;
//  if (s &lt; t-&gt;k)
//    { t-&gt;l = Delete(s, t-&gt;l);
//      if (!balanced(t-&gt;l-&gt;s, t-&gt;r-&gt;s)) t = inc_left(t);
//    }
//   else
//    { t-&gt;r = Delete(s, t-&gt;r);
//      if (!balanced(t-&gt;r-&gt;s, t-&gt;l-&gt;s)) t = inc_right(t);
//    }
//  return t;
// }
//
// wbst delete_root(wbst t)
// { node *p;
// if (t-&gt;s == 1) { freeNode(t); return null; }
// if (t-&gt;l-&gt;s &gt; t-&gt;r-&gt;s)
// { p-&gt;l = extract_maximum(t-&gt;l, &amp;p);
// p-&gt;r = t-&gt;r;
// }
// else
// { p-&gt;r = extract_minimum(t-&gt;r, &amp;p);
// p-&gt;l = t-&gt;l;
// }
// p-&gt;s = t-&gt;s - 1;
// freeNode(t);
// return p;
// }
//
// wbst delete_root(wbst t)
// { node *p;
//  if (t-&gt;s == 1) { freeNode(t); return null; }
//  if (t-&gt;l-&gt;s &gt; t-&gt;r-&gt;s)
//    { p-&gt;l = extract_maximum(t-&gt;l, &amp;p);
//      p-&gt;r = t-&gt;r;
//    }
//   else
//    { p-&gt;r = extract_minimum(t-&gt;r, &amp;p);
//      p-&gt;l = t-&gt;l;
//    }
//  p-&gt;s = t-&gt;s - 1;
//  freeNode(t);
//  return p;
// }
//
//
// wbst delete_root(wbst t)
// { node *p;
//  if (t-&gt;s == 1) { freeNode(t); return null; }
//  if (t-&gt;l-&gt;s &gt; t-&gt;r-&gt;s)
//    { p-&gt;l = extract_maximum(t-&gt;l, &amp;p);
//      p-&gt;r = t-&gt;r;
//    }
//   else
//    { p-&gt;r = extract_minimum(t-&gt;r, &amp;p);
//      p-&gt;l = t-&gt;l;
//    }
//  p-&gt;s = t-&gt;s - 1;
//  freeNode(t);
//  return p;
// }

// func (tree WeightBalancedDownUp) extractMin(p **Node, s Size) Value {
//    if p == nil {
//       return p
//    }
//    p = p.Copy()
//
//    sl := p.s
//    sr := p.sizeR(s)
//
//    p.l = tree.extractMin(p.l, sl, s)
//    p.s--
//
//    if !tree.Balanced(sl - 1, sr) {
//       if !tree.singleRotation(p.r.sizeR(sr), p.r.s) {
//          rotateRL(&amp;p)
//       } else {
//          rotateL(&amp;p)
//       }
//    }
//    return p
// }
//
// func (tree WeightBalancedDownUp) extractMax(p **Node, s Size) Value {
//    if p == nil {
//       return p
//    }
//    p = p.Copy()
//
//    sl := p.s
//    sr := p.sizeR(s)
//
//    p.r = tree.extractMax(p.r, sr, s)
//
//    if !tree.Balanced(sr - 1, sl) {
//       if !tree.singleRotation(p.l.s, p.l.sizeR(sl)) {
//          rotateLR(&amp;p)
//       } else {
//          rotateR(&amp;p)
//       }
//    }
//    return p
// }

//

//
// This method removes the node p from its tree.
// It is replaced by either its inorder successor or predecessor.
//
// The dissolved node is written, and the root returned.
//
//
//
//
// func (tree *LBSTDownUp) dissolve(p *Node, s Size) *Node {
//    // *dissolved = p
//    return tree.join(p.l, p.r, p.s, p.sizeR(s))
//    //
//    // sl := p.s
//    // sr := p.sizeR(s)
//    //
//      // assert(tree.Balanced(sl, sr))
//      // assert(tree.Balanced(sr, sl))
//    //
//    // *dissolved = p // yeah man, this is the node is that going bye bye!
//    //
//    // if p.l == nil { return p.r }
//    // if p.r == nil { return p.l }
//    //
//    // if sr &gt; sl {
//    //    max := tree.deleteMax(&amp;p.l, sl)
//    //    max.l = p.l
//    //    max.r = p.r
//    //    max.s = sl
//    //    return max
//    //
//    //    // p.s =
//    //    // root, dissolved = tree.deleteMin(p.r, sr, &amp;p.s)
//    // } else {
//    //    // root, dissolved = tree.deleteMax(p.l, sl, &amp;p.s)
//    //    // p.s--
//    //
//    // }
// }
//
// func (tree LBSTDownUp) extractMin(p **Node, s Size) (s Value) {
//       *p = tree.delete(*p, s, 0, &amp;s)
//    return
// }
//
// func (tree LBSTDownUp) extractMax(p **Node, s Size) (s Value) {
//    *p = tree.delete(*p, s, s-1, &amp;s)
//    return
// }

// wbst extract_maximum(wbst t, wbst *u)
// { size sA, sB;
//  if (t-&gt;r == null) { *u = t; t = t-&gt;l; }
//   else
//    { t-&gt;r = extract_maximum(t-&gt;r, u);
//      t-&gt;s--;
//      if (!balanced(t-&gt;r-&gt;s, t-&gt;l-&gt;s)) t = inc_right(t);
//    }
//  return t;
// }
//
// wbst extract_minimum(wbst t, wbst *u)
// { size sA, sB;
//  if (t-&gt;l == null) { *u = t; t = t-&gt;r; }
//   else
//    { t-&gt;l = extract_minimum(t-&gt;l, u);
//      t-&gt;s--;
//      if (!balanced(t-&gt;l-&gt;s, t-&gt;r-&gt;s)) t = inc_left(t);
//    }
//  return t;
// }
//

//
// func (tree LBSTDownUp) Join(that List) List {
//    l := tree
//    r := that.(*LBSTDownUp)
//    return &amp;LBSTDownUp{
//       BST: BST{
//          root: tree.join(l.root.share(), r.root.share(), l.size, r.size),
//          size: l.size + r.size,
//       },
//    }
// }
//
// func (tree LBSTDownUp) build(s Value, l, r *Node, sl, sr Size) *Node {
//    if sl &lt;= sr {
//       return tree.joinR(s, l, r, sl, sr)
//    } else {
//       return tree.joinL(s, l, r, sl, sr)
//    }
// }
//
// func (tree *LBSTDownUp) joinL(s Value, l, r *Node, sl, sr Size) *Node {
//    if tree.Balanced(sr, sl) {
//       return &amp;Node{
//          s: s,
//          l: l,
//          r: r,
//          s: sl,
//       }
//    }
//    l = pathcopy(l)
//
//    sll := l.s
//    slr := l.sizeR(sl)
//
//    l.r = tree.joinL(s, l.r, r, slr, sr)
//    slr = 1 + sr + slr
//
//    if !tree.Balanced(sll, slr) {
//       if tree.singleRotation(l.r.sizeR(slr), l.r.s) {
//          l = l.rotateL()
//       } else {
//          l = l.rotateRL()
//       }
//    }
//    return l
// }
//
// func (tree *LBSTDownUp) joinR(s Value, l, r *Node, sl, sr Size) *Node {
//    if tree.Balanced(sl, sr) {
//       return &amp;Node{ // TODO: Why does this have to copy?
//          s: s,
//          l: l,
//          r: r,
//          s: sl,
//       }
//    }
//    r = pathcopy(r)
//
//    srl := r.s
//    srr := r.sizeR(sr)
//
//    r.l = tree.joinR(s, l, r.l, sl, srl)
//    r.s = 1 + sl + srl
//
//    if !tree.Balanced(srr, r.s) {
//       if tree.singleRotation(r.l.s, r.l.sizeR(r.s)) {
//          r = r.rotateR()
//       } else {
//          r = r.rotateLR()
//       }
//    }
//    return r
// }
//
// func (tree LBSTDownUp) split(p *Node, i, s Size) (l, r *Node) {
//    if p == nil {
//       return
//    }
//    p = p.Copy()
//    sl, sr := p.sizeLR(s)
//
//    if i &lt;= (*p).s {
//       l, r = tree.split(p.l, i, sl)
//       r = tree.build(p.s, r, p.r, sl-i, sr)
//    } else {
//       l, r = tree.split(p.r, i-sl-1, sr)
//       l = tree.build(p.s, p.l, l, sl, i-sl-1)
//    }
//    return l, r
// }
//
// func (tree LBSTDownUp) Split(i Position) (List, List) {
//    // assert(i &lt;= tree.Size())
//
//    l, r := tree.split(tree.root.share(), i, tree.size)
//
//    return &amp;LBSTDownUp{BST: BST{root: l, size: i}},
//       &amp;LBSTDownUp{BST: BST{root: r, size: tree.size - i}}
// }
</pre>
		
		<pre class="file" id="file11" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type LBSTJoinBased struct {
   LBST // TODO: Remove these, just use Tree at the base always
}

func (tree LBSTJoinBased) New() List <span class="cov0" title="0">{
   return &amp;LBSTJoinBased{}
}</span>

func (tree *LBSTJoinBased) Clone() List <span class="cov0" title="0">{
   return &amp;LBSTJoinBased{
      LBST: LBST{
         Tree: tree.Tree.Clone(),
      },
   }
}</span>

func (tree *LBSTJoinBased) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *LBSTJoinBased) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *LBSTJoinBased) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.root = JoinBased{Tree: tree.Tree, Joiner: tree}.insert(tree.root, i, tree.size, tree.allocate(Node{x: x}))
   tree.size++
}</span>

//
//func (tree LBSTBottomUp) Split(i Position) (List, List) {
//   l, r := tree.LBST.Split(i)
//
//   return &amp;LBSTBottomUp{l},
//      &amp;LBSTBottomUp{r}
//}
//
//func (tree LBSTBottomUp) Join(that List) List {
//   return &amp;LBSTBottomUp{tree.LBST.Join(that.(*LBSTBottomUp).LBST)}
//}

func (tree *LBSTJoinBased) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.root = JoinBased{Tree: tree.Tree, Joiner: tree}.delete(tree.root, i, tree.size, &amp;x)
   tree.size--
   return
}</span>

func (tree LBSTJoinBased) Split(i Position) (List, List) <span class="cov0" title="0">{
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: tree}.splitToBST(tree.root, i, tree.size)

   return &amp;LBSTJoinBased{LBST{l}},
      &amp;LBSTJoinBased{LBST{r}}
}</span>

func (tree LBSTJoinBased) Join(that List) List <span class="cov0" title="0">{
   l := tree
   r := that.(*LBSTJoinBased)
   tree.share(l.root)
   tree.share(r.root)
   return &amp;LBSTJoinBased{
      LBST{
         Tree: Tree{
            arena: tree.arena,
            root:  tree.join2(l.root, r.root, l.size, r.size),
            size:  l.size + r.size,
         },
      },
   }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/utility"
)

// LBSTRelaxed / Relaxed Weight-Balanced Tree (Experimental)
//
// Recap:
//    The _height_ of a tree is the longest path from the root to any other node.
//    The _depth_ of a node is the number of links to follow to reach the root.
//    The _weight_ of a tree is equal to its size; the number of reachable nodes.
//
//    To guarantee a tree height upper-bound, a weight-balanced tree maintains
//    strict weight-balance at _every_ node in the tree.
//
// This balancing strategy combines the ideas of weight- and height-balance by
// allowing some nodes to not be weight-balanced, as long as the height of the
// tree is less than or equal to some upper-bound.
//
// This strategy can therefore be considered a "relaxed weight-balanced tree",
// because the height can be valid even when some nodes are not weight-balanced.
//
// When the height of the tree exceeds the upper-bound for its size, any node
// along the tree's longest path which is _not_ weight-balanced can be balanced
// to reduce its height by at least 1, thereby restoring the height bound.
//
// When inserting a new node, we count the number of nodes top-down to determine
// if the path exceeded the height upper-bound; if the depth exceeds the tree's
// height upper-bound, then at least one node along the insertion path must not
// be weight-balanced - we call this node the "scapegoat".
//
// ---
//
// Usually, a scapegoat tree is implemented quite differently:
//
// An "alpha" parameter `α` is chosen between 0.5 and 1.0:
//
//       Balanced:
//
//          sl &lt;= α * s
//          sr &lt;= α * s
//
//       MaximumPathLength upper-bound:
//
//          ⌊log1/α(size)⌋
//
//       Where `s` is the size of the parent, `sl` and `sr` are subtree sizes.
//
// This parameter imposes the computation of a logarithm with a fractional base.
// Choosing a=0.5 would be log₂, however the balance is then so strict that the
// amount of rebalancing makes the strategy non-viable.
//
// In comparison, the bitwise logarithmic weight-balance rule is much simpler,
// avoiding the logarithm, integer multiplication, and potential for overflow.
//
//       sl &gt;= ~sl &amp; (sr &gt;&gt; 1)
//       sr &gt;= ~sr &amp; (sl &gt;&gt; 1)
//
//       Check: size &lt; (1 &lt;&lt; ((depth + 1) &gt;&gt; 1))
//
//       The maximum height is 2 * ⌊log₂(m)⌋, where `m` is the maximum size
//       that the tree has reached. Deletions do not consider balance at all.
//
//       This height upper-bound is similar to the worst-case height of a
//       red-black tree of size `m`. TODO: what is it exactly?
//
// Usually, a scapegoat tree explicitly tracks the ceiling size `m` to determine
// when to rebuild after a delete: when the distance between the current size
// and the ceiling is too great, rebuild the entire tree and reset the ceiling
// to equal the size. This implementation forgoes this step, taking inspiration
// from the relaxed AVL and relaxed red-black trees.
//
// Another difference is that the textbook scapegoat tree chooses the deepest
// weight-unbalanced ancestor, i.e. the one furthest away from the root. This
// is done _after_ a height violation is detected, bottom-up towards the root
// until the first weight-unbalanced node is found. This implementation instead
// looks for a scapegoat top-down, choosing the first weight-unbalanced node
// encountered and therefore the highest weight-unbalanced ancestor.
//
// Most insertions, however, do not require a rebuild.
//
// Split is implemented using a similar approach to treaps and zip trees:
// one pass top-down, without considering balance. Both sides of the split
// then inherit the implicit ceiling of the tree that was split.
//
// Join simply removes either the maximum node of the left tree or the minimum
// node of the right tree for the joining node, whichever is larger. It is not
// clear what effect this has over time, but successive insertions will again
// improve the balance. This implementation includes it for completeness.
//
// ---
//
// References:
//    - Andersson, A. (1989). Improving Partial Rebuilding by Using Simple Balance Criteria. WADS.
//    - Andersson, A. (1999). General Balanced Trees. J. Algorithms, 30, 1-18.
//    - Galperin, I., &amp; Rivest, R.L. (1993). LBSTRelaxed trees. SODA '93.
//    - Roura, S. (2001). A New Method for Balancing Binary Search Trees. ICALP.
//    - Muusse, I.J. (2017). An algorithm for balancing a binary search tree.
//

type LBSTRelaxed struct {
   Tree
}

// Creates a new LBSTRelaxed BST from existing values.
func (LBSTRelaxed) New() List <span class="cov0" title="0">{
   return &amp;LBSTRelaxed{}
}</span>

func (tree *LBSTRelaxed) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *LBSTRelaxed) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *LBSTRelaxed) Clone() List <span class="cov0" title="0">{
   return &amp;LBSTRelaxed{
      Tree: tree.Tree.Clone(),
   }
}</span>

// Inserts a value `s` at position `i` in the tree.
func (tree *LBSTRelaxed) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())

   var unbalancedNode **Node // An unbalanced node along the insertion path.
   var unbalancedSize Size   // The size of the unbalanced node.
   var depth uint64          // The depth of the insertion so far.

   p := &amp;tree.root
   s := tree.size

   // Search with increasing depth until the end of the path is reached.
   //
   for *p != nil </span><span class="cov0" title="0">{
      tree.copy(p)
      depth++

      sl := (*p).s         // Size of the left subtree.  O(1)
      sr := s - (*p).s - 1 // Size of the right subtree. O(1)

      if i &lt;= sl </span><span class="cov0" title="0">{
         //
         // LEFT
         //
         if unbalancedNode == nil &amp;&amp; !tree.isBalanced(sr, sl+1) </span><span class="cov0" title="0">{
            unbalancedNode = p
            unbalancedSize = s + 1
         }</span>
         <span class="cov0" title="0">p = insertL(*p)
         s = sl</span>

      } else<span class="cov0" title="0"> {
         //
         // RIGHT
         //
         if unbalancedNode == nil &amp;&amp; !tree.isBalanced(sl, sr+1) </span><span class="cov0" title="0">{
            unbalancedNode = p
            unbalancedSize = s + 1
         }</span>
         <span class="cov0" title="0">p = insertR(*p, &amp;i)
         s = sr</span>
      }
   }
   // Attach a new node at the end of the path.
   <span class="cov0" title="0">*p = tree.allocate(Node{x: x})
   tree.size++

   // Check if a rebuild is required.
   if tree.tooDeep(tree.size, depth) </span><span class="cov0" title="0">{
      tree.rebuild(unbalancedNode, unbalancedSize)
   }</span>
}

// Determines if the depth at which a new node was inserted was too deep, i.e.
// if the new height of the tree exceeds the upper-bound for its size.
//
//        tooDeep := depth &gt; 2 * ⌊log₂(size)⌋
//
//     because root.height() &lt;= MaximumPathLength(2 * math.FloorLog2(size))
//
//   depth is height + 1 ?
func (tree *LBSTRelaxed) tooDeep(size Size, depth uint64) bool <span class="cov0" title="0">{
   return (1 &lt;&lt; ((depth + 1) &gt;&gt; 1)) &gt; size
}</span>

func (tree *LBSTRelaxed) partition(p *Node, i uint64, l, r **Node) <span class="cov0" title="0">{
   for p != nil </span><span class="cov0" title="0">{
      tree.copy(&amp;p)
      if i &lt;= p.s </span><span class="cov0" title="0">{
         *r = p
         p.s = p.s - i
         r = &amp;p.l
         p = p.l
      }</span> else<span class="cov0" title="0"> {
         *l = p
         i = i - p.s - 1
         l = &amp;p.r
         p = p.r
      }</span>
   }
   <span class="cov0" title="0">*l = nil
   *r = nil</span>
}

func (tree *LBSTRelaxed) moveToRoot(p *Node, i Position) *Node <span class="cov0" title="0">{
   // assert(i &lt; p.size())
   n := Node{s: i}
   l := &amp;n
   r := &amp;n
   for i != p.s </span><span class="cov0" title="0">{
      tree.copy(&amp;p)
      if i &lt; p.s </span><span class="cov0" title="0">{
         p.s = p.s - i - 1
         r.l = p
         r = r.l
         p = p.l
      }</span> else<span class="cov0" title="0"> {
         i = i - p.s - 1
         l.r = p
         l = l.r
         p = p.r
      }</span>
   }
   <span class="cov0" title="0">tree.copy(&amp;p)
   l.r = p.l
   r.l = p.r
   p.r = n.l
   p.l = n.r
   p.s = n.s
   return p</span>
}
func (tree LBSTRelaxed) balance(p *Node, s Size) *Node <span class="cov0" title="0">{
   if s &lt; 3 </span><span class="cov0" title="0">{
      return p
   }</span>
   <span class="cov0" title="0">sl := p.sizeL()
   sr := s - p.s - 1

   // assert(tree.isBalanced(sl, sr) || sl &lt; sr)
   // assert(tree.isBalanced(sr, sl) || sr &lt; sl)
   if !tree.isBalanced(sl, sr) || !tree.isBalanced(sr, sl) </span><span class="cov0" title="0">{
      p = tree.moveToRoot(p, s&gt;&gt;1)
   }</span>
   <span class="cov0" title="0">p.l = tree.balance(p.l, p.sizeL())
   p.r = tree.balance(p.r, p.sizeR(s))
   return p</span>
}

func (tree *LBSTRelaxed) rebuild(p **Node, s Size) <span class="cov0" title="0">{
   *p = tree.balance(*p, s)
}</span>

func (tree *LBSTRelaxed) delete(p **Node, s Size, i Size) (x Data) <span class="cov0" title="0">{
   return tree.Tree.delete(p, s, i)
}</span>

// Deletes the node at position `i` from the tree.
// Returns the data that was in the deleted value.
func (tree *LBSTRelaxed) Delete(i Position) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   x := tree.delete(&amp;tree.root, tree.size, i)
   tree.size--
   return x
}</span>
func (tree *LBSTRelaxed) Split(i Size) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.size)

   var l, r *Node
   tree.share(tree.root)
   tree.partition(tree.root, i, &amp;l, &amp;r)

   return &amp;LBSTRelaxed{Tree{arena: tree.arena, root: l, size: i}},
      &amp;LBSTRelaxed{Tree{arena: tree.arena, root: r, size: tree.size - i}}
}</span>

// Determines if two sizes are balanced.
func (LBSTRelaxed) isBalanced(x, y Size) bool <span class="cov0" title="0">{
   return !utility.SmallerLog2(x, y &gt;&gt; 1)
}</span>

func (tree *LBSTRelaxed) joinLr(l, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   //if l == nil { return r }
   if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>
   <span class="cov0" title="0">if tree.isBalanced(sr, sl) </span><span class="cov0" title="0">{ // TODO: wrong way around?
      p := tree.deleteMax(&amp;l)
      p.l = l
      p.r = r
      p.s = sl - 1
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;l)
   l.r = tree.joinlR(l.r, r, sl-l.s-1, sr)
   return l</span>
}

func (tree *LBSTRelaxed) joinlR(l, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if tree.isBalanced(sl, sr) </span><span class="cov0" title="0">{ // TODO: wrong way around?
      p := tree.deleteMin(&amp;r)
      p.l = l
      p.r = r
      p.s = sl
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;r)
   r.l = tree.joinLr(l, r.l, sl, r.s)
   r.s = sl + r.s
   return r</span>
}

func (tree *LBSTRelaxed) join4(l, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   if sl &gt; sr </span><span class="cov0" title="0">{
      return tree.joinLr(l, r, sl, sr)
   }</span> else<span class="cov0" title="0"> {
      return tree.joinlR(l, r, sl, sr)
   }</span>
}

func (tree *LBSTRelaxed) join(l, r *LBSTRelaxed) *LBSTRelaxed <span class="cov0" title="0">{
   tree.share(l.root)
   tree.share(r.root)
   return &amp;LBSTRelaxed{Tree{
      arena: tree.arena,
      root:  tree.join4(l.root, r.root, l.size, r.size),
      size:  l.size + r.size,
   }}
}</span>

func (tree *LBSTRelaxed) Join(other List) List <span class="cov0" title="0">{
   return tree.join(tree, other.(*LBSTRelaxed))
}</span>

func (tree *LBSTRelaxed) Verify() <span class="cov0" title="0">{
   tree.verifySizes()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/utility"
)

type LBSTTopDown struct {
   LBST
}

func (LBSTTopDown) New() List <span class="cov0" title="0">{
   return &amp;LBSTTopDown{}
}</span>

func (tree *LBSTTopDown) Clone() List <span class="cov0" title="0">{
   return &amp;LBSTTopDown{LBST{Tree: tree.Tree.Clone()}} // TODO: format
}</span>

func (tree *LBSTTopDown) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *LBSTTopDown) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *LBSTTopDown) isBalanced(x, y Size) bool <span class="cov0" title="0">{
   return tree.LBST.isBalanced(x+1, y+1)
}</span>

func (tree *LBSTTopDown) singleRotation(x, y Size) bool <span class="cov0" title="0">{
   return tree.LBST.singleRotation(x+1, y+1)
}</span>

// -1 &lt;= ⌊log₂(L + 1)⌋ - ⌊log₂(R + 1)⌋ &lt;= 1
func (tree *LBSTTopDown) verifyBalance(p *Node, s Size) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant(utility.Difference(utility.Log2(p.sizeL()+1), utility.Log2(p.sizeR(s)+1)) &lt;= 1)

   tree.verifyBalance(p.l, p.sizeL())
   tree.verifyBalance(p.r, p.sizeR(s))</span>
}

func (tree *LBSTTopDown) verifyHeight(root *Node, size Size) <span class="cov0" title="0">{
   invariant(root.height() &lt;= int(2*utility.Log2(size)))
}</span>

// "the height of an LBST with n 􏰥 􏰅 keys is never larger than 􏰅 log􏰅 n"
func (tree *LBSTTopDown) verify(root *Node, size Size) <span class="cov0" title="0">{
   tree.verifySizes()
   tree.verifyBalance(root, size)
   tree.verifyHeight(root, size)
}</span>

func (tree *LBSTTopDown) Verify() <span class="cov0" title="0">{
   tree.verify(tree.root, tree.size)
}</span>

func (tree *LBSTTopDown) insert(p **Node, s Size, i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= s)
   // assert(s == (*p).size())
   for </span><span class="cov0" title="0">{
      if *p == nil </span><span class="cov0" title="0">{
         *p = tree.allocate(Node{x: x})
         return
      }</span>
      <span class="cov0" title="0">tree.copy(p)

      sl := (*p).sizeL()
      sr := (*p).sizeR(s)

      // assert(tree.isBalanced(sr, sl))
      // assert(tree.isBalanced(sl, sr))

      if i &lt;= (*p).s </span><span class="cov0" title="0">{
         if tree.isBalanced(sr, sl+1) </span><span class="cov0" title="0">{
            //
            // L BALANCED
            //
            tree.pathL(&amp;p, &amp;s)
         }</span> else<span class="cov0" title="0"> {
            if i &lt;= (*p).l.s </span><span class="cov0" title="0">{
               if tree.singleRotation((*p).l.sizeL()+1, (*p).l.sizeR(sl)) </span><span class="cov0" title="0">{
                  //
                  // LL SINGLE
                  //
                  tree.rotateR(p)
                  tree.pathL(&amp;p, &amp;s)
               }</span> else<span class="cov0" title="0"> {
                  //
                  // LL DOUBLE
                  //
                  tree.rotateLR(p)
                  tree.pathL(&amp;p, &amp;s)
                  tree.pathL(&amp;p, &amp;s)
               }</span>
            } else<span class="cov0" title="0"> {
               if tree.singleRotation((*p).l.sizeL(), (*p).l.sizeR(sl)+1) </span><span class="cov0" title="0">{
                  //
                  // LR SINGLE
                  //
                  tree.rotateR(p)
                  tree.pathR(&amp;p, &amp;s, &amp;i)
                  tree.pathL(&amp;p, &amp;s)
               }</span> else<span class="cov0" title="0"> {
                  if i &lt;= (*p).l.s+(*p).l.r.s+1 </span><span class="cov0" title="0">{
                     //
                     // LRL DOUBLE
                     //
                     tree.rotateLR(p)
                     tree.pathL(&amp;p, &amp;s)
                     tree.pathR(&amp;p, &amp;s, &amp;i)
                  }</span> else<span class="cov0" title="0"> {
                     //
                     // LRR DOUBLE
                     //
                     tree.rotateLR(p)
                     tree.pathR(&amp;p, &amp;s, &amp;i)
                     tree.pathL(&amp;p, &amp;s)
                  }</span>
               }
            }
         }
      } else<span class="cov0" title="0"> {
         //
         // R BALANCED
         //
         if tree.isBalanced(sl, sr+1) </span><span class="cov0" title="0">{
            tree.pathR(&amp;p, &amp;s, &amp;i)
            continue</span>
         }
         <span class="cov0" title="0">if i &gt; (*p).s+(*p).r.s+1 </span><span class="cov0" title="0">{
            if tree.singleRotation((*p).r.sizeR(sr)+1, (*p).r.sizeL()) </span><span class="cov0" title="0">{
               //
               // RR SINGLE
               //
               tree.rotateL(p)
               tree.pathR(&amp;p, &amp;s, &amp;i)
            }</span> else<span class="cov0" title="0"> {
               //
               // RR DOUBLE
               //
               tree.rotateRL(p)
               tree.pathR(&amp;p, &amp;s, &amp;i)
               tree.pathR(&amp;p, &amp;s, &amp;i)
            }</span>
         } else<span class="cov0" title="0"> {
            if tree.singleRotation((*p).r.sizeR(sr), (*p).r.sizeL()+1) </span><span class="cov0" title="0">{
               //
               // RL SINGLE
               //
               tree.rotateL(p)
               tree.pathL(&amp;p, &amp;s)
               tree.pathR(&amp;p, &amp;s, &amp;i)
            }</span> else<span class="cov0" title="0"> {
               if i &gt; (*p).s+(*p).r.l.s+1 </span><span class="cov0" title="0">{
                  //
                  // RLR DOUBLE
                  //
                  tree.rotateRL(p)
                  tree.pathR(&amp;p, &amp;s, &amp;i)
                  tree.pathL(&amp;p, &amp;s)
               }</span> else<span class="cov0" title="0"> {
                  //
                  // RLL DOUBLE
                  //
                  tree.rotateRL(p)
                  tree.pathL(&amp;p, &amp;s)
                  tree.pathR(&amp;p, &amp;s, &amp;i)
               }</span>
            }
         }
      }
   }
}

func (tree *LBSTTopDown) delete(p **Node, s Size, i Position) (deleted *Node) <span class="cov0" title="0">{
   // assert(i &lt; s)
   // assert(s == (*p).size())
   for </span><span class="cov0" title="0">{
      tree.copy(p)

      sl := (*p).s
      sr := s - (*p).s - 1

      // assert(tree.isBalanced(sl, sr))
      // assert(tree.isBalanced(sr, sl))

      if i == (*p).s </span><span class="cov0" title="0">{
         defer tree.release(*p)
         x := *p
         *p = tree.join2((*p).l, (*p).r, sl, sr)
         return x
      }</span>
      <span class="cov0" title="0">if i &lt;= (*p).s </span><span class="cov0" title="0">{
         if tree.isBalanced(sl-1, sr) </span><span class="cov0" title="0">{
            //
            // L BALANCED
            //
            tree.deleteL(&amp;p, &amp;s)
         }</span> else<span class="cov0" title="0"> {
            if tree.singleRotation(sr-(*p).r.s-1, (*p).r.s) </span><span class="cov0" title="0">{
               //
               // L SINGLE
               //
               tree.rotateL(p)
               tree.deleteL(&amp;p, &amp;s)
               tree.deleteL(&amp;p, &amp;s)
            }</span> else<span class="cov0" title="0"> {
               //
               // L DOUBLE
               //
               tree.rotateRL(p)
               tree.deleteL(&amp;p, &amp;s)
               tree.deleteL(&amp;p, &amp;s)
            }</span>
         }
      } else<span class="cov0" title="0"> {
         if tree.isBalanced(sr-1, sl) </span><span class="cov0" title="0">{
            //
            // R BALANCED
            //
            tree.deleteR(&amp;p, &amp;s, &amp;i)
         }</span> else<span class="cov0" title="0"> {
            if tree.singleRotation((*p).l.s, sl-(*p).l.s-1) </span><span class="cov0" title="0">{
               //
               // R SINGLE
               //
               tree.rotateR(p)
               tree.deleteR(&amp;p, &amp;s, &amp;i)
               tree.deleteR(&amp;p, &amp;s, &amp;i)
            }</span> else<span class="cov0" title="0"> {
               //
               // R DOUBLE
               //
               tree.rotateLR(p)
               tree.deleteR(&amp;p, &amp;s, &amp;i)
               tree.deleteR(&amp;p, &amp;s, &amp;i)
            }</span>
         }
      }
   }
}

func (tree *LBSTTopDown) rebalanceR(p **Node, sr Size) <span class="cov0" title="0">{
   if tree.singleRotation(sr-(*p).r.s-1, (*p).r.s) </span><span class="cov0" title="0">{
      tree.rotateL(p)
   }</span> else<span class="cov0" title="0"> {
      tree.rotateRL(p)
   }</span>
}

func (tree *LBSTTopDown) rebalanceL(p **Node, sl Size) <span class="cov0" title="0">{
   if tree.singleRotation((*p).l.s, sl-(*p).l.s-1) </span><span class="cov0" title="0">{ // R SINGLE
      tree.rotateR(p)
   }</span> else<span class="cov0" title="0"> { // R DOUBLE
      tree.rotateLR(p)
   }</span>
}

func (tree *LBSTTopDown) pathL(p ***Node, s *Size) <span class="cov0" title="0">{
   *s = (**p).s
   (**p).s++
   *p = &amp;(**p).l
}</span>

func (tree *LBSTTopDown) deleteL(p ***Node, s *Size) <span class="cov0" title="0">{
   *s = (**p).s
   (**p).s--
   *p = &amp;(**p).l
}</span>

func (tree *LBSTTopDown) pathR(p ***Node, s *Size, i *Position) <span class="cov0" title="0">{
   *s = *s - (**p).s - 1
   *i = *i - (**p).s - 1
   *p = &amp;(**p).r
}</span>

func (tree *LBSTTopDown) deleteR(p ***Node, s *Size, i *Position) <span class="cov0" title="0">{
   *s = *s - (**p).s - 1
   *i = *i - (**p).s - 1
   *p = &amp;(**p).r
}</span>

func (tree *LBSTTopDown) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.insert(&amp;tree.root, tree.size, i, x)
   tree.size++
}</span>

func (tree *LBSTTopDown) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   x = tree.delete(&amp;tree.root, tree.size, i).x
   tree.size--
   return
}</span>

func (tree *LBSTTopDown) Join(that List) List <span class="cov0" title="0">{
   l := tree
   r := that.(*LBSTTopDown)
   tree.share(l.root)
   tree.share(r.root)
   return &amp;LBSTTopDown{
      LBST{
         Tree: Tree{
            arena: tree.arena,
            root:  tree.join2(l.root, r.root, l.size, r.size),
            size:  l.size + r.size,
         },
      },
   }
}</span>
func (tree *LBSTTopDown) deleteMin(p **Node, s Size) *Node <span class="cov0" title="0">{
   return tree.delete(p, s, 0)
}</span>

func (tree *LBSTTopDown) deleteMax(p **Node, s Size) *Node <span class="cov0" title="0">{
   return tree.delete(p, s, s-1)
}</span>

func (tree *LBSTTopDown) join2(l *Node, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>
   <span class="cov0" title="0">if sl &lt;= sr </span><span class="cov0" title="0">{
      return tree.join3(l, tree.deleteMin(&amp;r, sr), r, sl, sr-1)
   }</span> else<span class="cov0" title="0"> {
      return tree.join3(l, tree.deleteMax(&amp;l, sl), r, sl-1, sr)
   }</span>
}

func (tree *LBSTTopDown) join3(l, p, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   if sl &lt;= sr </span><span class="cov0" title="0">{
      return tree.assembleRL(p, l, r, sl, sr)
   }</span> else<span class="cov0" title="0"> {
      return tree.assembleLR(p, l, r, sl, sr)
   }</span>
}

func (tree *LBSTTopDown) assembleLR(p *Node, l, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   if tree.isBalanced(sr, sl) </span><span class="cov0" title="0">{
      p.l = l
      p.r = r
      p.s = sl
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;l)

   l.r = tree.assembleLR(p, l.r, r, sl-l.s-1, sr)

   if !tree.isBalanced(l.s, sl+sr-l.s) </span><span class="cov0" title="0">{
      tree.rebalanceR(&amp;l, sr+sl-l.s)
   }</span>
   <span class="cov0" title="0">return l</span>
}

func (tree *LBSTTopDown) assembleRL(p *Node, l, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   if tree.isBalanced(sl, sr) </span><span class="cov0" title="0">{
      p.l = l
      p.r = r
      p.s = sl
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;r)

   r.l = tree.assembleRL(p, l, r.l, sl, r.s)
   r.s = 1 + sl + r.s

   if !tree.isBalanced(sl+sr-r.s, r.s) </span><span class="cov0" title="0">{
      tree.rebalanceL(&amp;r, r.s)
   }</span>
   <span class="cov0" title="0">return r</span>
}

func (tree *LBSTTopDown) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: tree}.splitToBST(tree.root, i, tree.size)
   return &amp;LBSTTopDown{LBST{l}},
      &amp;LBSTTopDown{LBST{r}}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package binarytree

import (
   "golang.org/x/exp/constraints"
)

func measurement[T constraints.Integer | constraints.Float](addr *T, delta T) <span class="cov0" title="0">{
   *addr = *addr + delta
}</span>

type Measurement interface {
   Reset()
   Measure(BinaryTree) any
}

type PartitionCount struct {

}

var partitionCount uint64 = 0

func (PartitionCount) Reset()  <span class="cov0" title="0">{
   partitionCount = 0
}</span>

func (PartitionCount) Measure(BinaryTree) any <span class="cov0" title="0">{
   return partitionCount
}</span>

type PartitionDepth struct {

}
var partitionDepth uint64 = 0

func (PartitionDepth) Reset()  <span class="cov0" title="0">{
   partitionDepth = 0
}</span>

func (PartitionDepth) Measure(BinaryTree) any <span class="cov0" title="0">{
   return partitionDepth
}</span>

type MaximumPathLength struct {

}

func (MaximumPathLength) Reset()  {<span class="cov0" title="0">
}</span>

func (MaximumPathLength) Measure(tree BinaryTree) any <span class="cov0" title="0">{
   return tree.Root().MaximumPathLength()
}</span>

type AveragePathLength struct {
}

func (accumulator *AveragePathLength) Measure(tree BinaryTree) any <span class="cov0" title="0">{
   return tree.Root().AveragePathLength()
}</span>
func (AveragePathLength) Reset()  {<span class="cov0" title="0">
}</span>
var allocations uint64 = 0

type Allocations struct {
}

func (Allocations) Reset()  <span class="cov0" title="0">{
   allocations = 0
}</span>

func (Allocations) Measure(BinaryTree) any <span class="cov0" title="0">{
   return allocations
}</span>

var rotations uint64 = 0

type Rotations struct {
}

func (accumulator *Rotations) Reset()  <span class="cov0" title="0">{
   rotations = 0
}</span>

func (accumulator *Rotations) Measure(BinaryTree) any <span class="cov0" title="0">{
   return rotations
}</span>


//
//
//
//
//type Allocations struct {
//   runtime.MemStats
//}
//func (measurement *Allocations) Reset()  {
//   runtime.ReadMemStats(&amp;measurement.MemStats)
//}
//func (measurement *Allocations) Measure(result abstract.List) string {
//   var stats runtime.MemStats
//   runtime.ReadMemStats(&amp;stats)
//   return strconv.FormatUint(stats.Mallocs - measurement.MemStats.Mallocs, 10)
//}
//
//
//
//
//
//
//
//type Measurements struct {
//   Operation operations.Operation
//   Lists []abstract.List // TODO: Measurable ??
//   Distributions []number.Distribution
//   Measurements []Measurement
//
//   Resolution uint64
//   Scale      uint64
//}
//
//func info(values ...any) {
//   fmt.Fprintln(os.Stderr, values...)
//}
//
//func line(values ...any) {
//   fmt.Fprintln(os.Stdout, values...)
//}
//
//func (ms Measurements) Run() {
//   if ms.Resolution &gt; ms.Scale {
//      ms.Resolution = ms.Scale
//   }
//
//   //
//   header := []any{"#", "x"}
//   for _, measure := range ms.Measurements {
//      header = append(header, utility.TypeName(measure))
//   }
//   line(header...)
//
//   for _, impl := range ms.Lists {
//      line(utility.TypeName(impl))
//      info(utility.TypeName(impl))
//
//      for _, distribution := range ms.Distributions {
//         x := uint64(0)
//         if distribution != nil {
//            distribution = distribution.Seed(1234)
//         }
//         list := ms.Operation.Setup(impl, ms.Scale)
//         for _, measurement := range ms.Measurements {
//            measurement.Reset()
//         }
//         for ms.Operation.Valid(list, ms.Scale) {
//            list = ms.Operation.Update(list, distribution)
//
//            if x++; x % (ms.Scale / ms.Resolution) == 0 {
//               var row []any
//               row = append(row, x)
//               for _, measure := range ms.Measurements {
//                  row = append(row, measure.Measure(list))
//               }
//               line(row...)
//            }
//         }
//      }
//      line()
//      line()
//   }
//}</pre>
		
		<pre class="file" id="file15" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/utility"
)

type BinaryTreeNode interface {
   Height() int
   TotalInternalPathLength(Size) Size
   TotalReferenceCount() Size
}

// Node
//
// A node is a simple structure that can be linked to other nodes. Each node has
// a left and right outgoing link to other nodes. TODO: parent, binary tree
// The node at the top of the tree with no parent is called the _root_ node.
//
//
//                                   (P)arent
//                                 ↙     ↘
//                               (L)eft  (R)ight
//
//
// A node is a container for a unit of information.
// When multiple nodes are linked together they form a binary tree.
// This structure allows the ability to organize information.
// One type of organization is a sequence - linear, list, etc.
//
// A sequence is implied by binary search tree, where the parent appears in the
// sequence after the left node and before the right node.
//
// This can be viewed as a binary search tree ordered by sequential position.
//
// Every node tracks its 0-based position relative to the start of its sequence,
// equal to the number of nodes in its left subtree. Given the total size of a
// node, we can calculate the sizes of both subtrees without referencing them.
//
//
//          Position:     0   1   2   3   4   5   6
//
//          Sequence:    [e,  x,  a,  m,  p,  l,  e]
//
//                                    3
//          ParseAnimation:                    (m)
//                            1   ↙       ↘   1
//                           (x)             (l)
//                        0 ↙   ↘ 0       0 ↙   ↘ 0
//                       (e)     (a)     (p)     (e)
//
//
// Notice the vertical projection of the sequence onto the tree, which follows
// the in-order traversal from the root, recursively left-self-right.
//

// Multiple trees may share the same node, allowing independent trees to be made
// up of common subtrees shared in memory. Making a change to one tree data
// in a new tree that shares most of the previous structure. The reference count
// of a node is the number of other trees that reference it, thus zero indicates
// that a node is only referenced by its own tree and is not shared by others.

type Node struct {
   ReferenceCounter

   l *Node // Pointers to the left and right subtrees.
   r *Node

   s uint64 // Size, usually of the left subtree and therefore also position.
   x uint64 // Data
   y uint64 // Rank
}

//func (p Node) Position() Size {
//   return p.s
//}
//
//func (p Node) SizeOfRightSubtree(size Size) Size {
//   return p.sizeR(size)
//}

//func (p Node) Count() Size {
//  return p.size()
//}
//
//func (p Node) Left() BinaryTreeNode {
//   return p.l
//}
//
//func (p Node) Right() BinaryTreeNode {
//   return p.r
//}
//
//func (p Node) Data() Data {
//   return p.x
//}

// https://aofa.cs.princeton.edu/online/slides/AA06-Trees.pdf
// https://dl.acm.org/doi/pdf/10.1145/126459.126463

// Data Structures and Algorithms in Python by Michael T. Goodrich, Roberto Tamassia, and Michael H. Goldwasser. This book provides an explanation and implementation of the algorithm in Python.
// Introduction to Algorithms by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. This book provides a detailed explanation of the algorithm and its analysis in Chapter 12.
// Algorithms by Sanjoy Dasgupta, Christos Papadimitriou, and Umesh Vazirani. This book provides an explanation and implementation of the algorithm in Python in Chapter 6.
//
// ??
func averagePathLength(p *Node, depth uint64, totalDepth *uint64, totalNodes *uint64) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">*totalNodes = *totalNodes + 1
   *totalDepth = *totalDepth + depth
   averagePathLength(p.l, depth+1, totalDepth, totalNodes)
   averagePathLength(p.r, depth+1, totalDepth, totalNodes)</span>
}

// long IPL(lbst t)
// { if (t == null) return 0;
//
//    return IPL(t-&gt;l) + IPL(t-&gt;r) + t-&gt;s;
//   }
func (p *Node) AveragePathLength() float64 <span class="cov0" title="0">{
   var totalDepth uint64
   var totalNodes uint64
   averagePathLength(p, 0, &amp;totalDepth, &amp;totalNodes)
   return float64(totalDepth) / float64(totalNodes)
}</span>

//

// TODO: maybe this can be moved to tree.pathcopy(**Node) when all trees
//       use the same node structure and most node functions are moved inline,
//       then we can consider `t` as a type label instead of `tree` and move the
//       scope to be as local as possibe within the file.
//
//       Using the reference means we just need to dereference to read the refs,
//      and if non-zero, we construct and assign. When it is zero, we only did
//      dereference and did not assign. Also, it means you only specify the Data
//      once, and also if the pattern is always A = pathcopy(A) then that A is
//      clearly redundant and can simplified to pathcopy(&amp;A).
//
//

// TODO: Maybe put this on each tree where used
func rank(p *Node) uint64 <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return 0
   }</span> else<span class="cov0" title="0"> {
      return p.y
   }</span>
}

func (p Node) isLeaf() bool <span class="cov0" title="0">{ // TODO conc can have its own that doesn't check p.r for nil
   return p.l == nil &amp;&amp; p.r == nil
}</span>

// Max: 2n - 1
// Min: 0
//
// Complexity: O(n)
//

func (p *Node) MaximumPathLength() int <span class="cov0" title="0">{
   return p.height()
}</span>

func (p *Node) height() int <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return -1
   }</span>
   <span class="cov8" title="1">return 1 + utility.Max(p.l.height(), p.r.height())</span>
}

// Counts the number of nodes reachable from p*, including itself.
func (p *Node) size() Size <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return 0
   }</span> else<span class="cov0" title="0"> {
      return 1 + p.l.size() + p.r.size()
   }</span>
}

// Returns the number of nodes in the left subtree of p*.
// TODO: This is not the case for all tree implementations - should this be up to the tree? Maybe mix it in?
func (p *Node) sizeL() Size <span class="cov8" title="1">{
   return p.s
}</span>

// Returns the number of nodes in the right subtree of p*, given the s of p*.
func (p *Node) sizeR(s Size) Size <span class="cov8" title="1">{
   return s - p.s - 1
}</span>

// Recursive in-order traversal of p*, left-self-right.
// This will call the given function for every Node in the sequence of p*.
// func (p *Node) inorder(visit func(Node)) {
//    if p == nil {
//       return
//    }
//    p.l.inorder(visit)
//    visit(*p)
//    p.r.inorder(visit)
// }

//func (p *Node) inorder2(visit func(Node)) {
//   if p == nil {
//      return
//   }
//   p.l.inorder2(visit)
//   visit(*p)
//   p.r.inorder2(visit)
//}

func (p *Node) inorder(visit func(Data)) <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return
   }</span>
   <span class="cov8" title="1">p.l.inorder(visit)
   visit(p.x)
   p.r.inorder(visit)</span>
}

func (p *Node) rotateL() (r *Node) <span class="cov8" title="1">{
   // measurement(&amp;rotations, 1)
   r = p.r
   p.r = r.l
   r.l = p
   r.s = r.s + p.s + 1
   return r
}</span>

func (p *Node) rotateR() (l *Node) <span class="cov8" title="1">{
   // measurement(&amp;rotations, 1)
   l = p.l
   p.l = l.r
   l.r = p
   p.s = p.s - l.s - 1
   return l
}</span>

// Rotates the LEFT subtree LEFT, then rotates the root RIGHT.
func (p *Node) rotateLR() *Node <span class="cov8" title="1">{
   p.l = p.l.rotateL()
   return p.rotateR()
}</span>

// Rotates the RIGHT subtree RIGHT, then rotates the root LEFT.
func (p *Node) rotateRL() *Node <span class="cov8" title="1">{
   p.r = p.r.rotateR()
   return p.rotateL()
}</span>

// `i` is the number of nodes that will be attached to the left still
// so we are not tracking the total size at any point.
// we reduce the size of the left subtree of p by i - 1
//
// size left reduces by (i + 1)
//
// the resulting size of p is then (s - p.s - 1 + i)
// the size before
//
//
//    1. Link `p` to the left of `r`
//    2. Set r
//
//
//       (p)            (r)
//                     ↙
//
//
//

//func (p *Node) deleteL(r **Node, s Size, i Position) (**Node, Size, Position) {
//   s = p.s
//   p.s--
//  *r = p
//   r = &amp;p.l
//   return r, s, i
//}
//
//func (p *Node) deleteR(n **Node, s Size, i Position) (**Node, Size, Position) {
//   i = i - (*p).s - 1
//   s = s - (*p).s - 1
//  *n = p
//   n = &amp;p.r
//   return n, s, i
//}
//
// // (*p).s = (*p).s + 1    // The size of the left subtree increases.
// //      p = &amp;(*p).l       // The search path continues to the left.
// //      s = sl            // Track the subtree size going left.
// func (p *Node) pathL(r **Node, s Size, i Position) (**Node, Size, Position) {
//    s = p.s
//    p.s++
//   *r = p
//    return &amp;p.l, s, i
// }
// //  i = i - sl - 1    // Skip all the nodes to the left, including p*
// //  p = &amp;(*p).r       // The search path continues to the right.
// //  s = sr            // Track the subtree size going right.
// func (p *Node) pathR(n **Node, s Size, i Position) (**Node, Size, Position) {
//    i = i - (*p).s - 1
//    s = s - (*p).s - 1
//   *n = p
//    return &amp;p.r, s, i
// }
// func (p *Node) insertLR(n **Node, s Size, i Position) (**Node, Size, Position) {
//    n, s, i = p.pathL(n, s, i)
//    return (*n).pathR(n, s, i)
// }
// func (p *Node) insertLL(n **Node, s Position, i Position) (**Node, Size, Position) {
//    n, s, i = p.pathL(n, s, i)
//    return (*n).pathL(n, s, i)
// }
// func (p *Node) insertRR(n **Node, s Size, i Position) (**Node, Size, Position) {
//    n, s, i = p.pathR(n, s, i)
//    return (*n).pathR(n, s, i)
// }
// func (p *Node) insertRL(n **Node, s Size, i Position) (**Node, Size, Position) {
//    n, s, i = p.pathR(n, s, i)
//    return (*n).pathL(n, s, i)
// }
//
//
// func (p *Node) isParentOf(child *Node) bool {
//    return child == p.l || child == p.r
// }

//
//func (p *Node) hasLeft() bool {
//   return p.l != nil
//}
//
//func (p *Node) hasRight() bool {
//   return p.r != nil
//}

func (tree Tree) verifySize(p *Node, s Size) Size <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return 0
   }</span>
   <span class="cov8" title="1">sl := tree.verifySize(p.l, p.sizeL())
   sr := tree.verifySize(p.r, p.sizeR(s))

   invariant(s == sl+sr+1)
   return s</span>
}

// func partition2(root *Node, i Position) (*Node, *Node) {
//    p := root
//    n := Node{}
//    l := &amp;n
//    r := &amp;n
//    for {
//       if p == nil {
//          l.r = nil
//          r.l = nil
//          return n.r, n.l
//          // break
//       }
//       p = p.Copy()
//       if i == p.s {
//          l.r = p.l
//          r.l = p
//          p.l = nil
//          p.s = 0
//          return n.r, n.l
//       }
//       if i &lt; p.s {
//          p.s = p.s - i
//          r.l = p
//          r = r.l
//          p = p.l
//       } else {
//          i = i - p.s - 1
//          l.r = p
//          l = l.r
//          p = p.r
//       }
//    }
// }

//func (tree *Tree) emplace(p **Node, i Position, n *Node) {
//   tree.split(*p, i, &amp;n.l, &amp;n.r)
//   n.s = i
//   *p = n
//}
//
// // func dissolve(tree joinable, p **Node, s Size, s *Data) {
// //    *s = (*p).s
// //    *p = tree.join((*p).l, (*p).r, (*p).s, (*p).sizeR(s))
// // }
//
// func join(l, r *Node, sl, sr Size) *Node {
//    // sl := (*p).s
//    // sr := (*p).sizeR(s)
//    if l == nil { return r }
//    if r == nil { return l }
//
//    if sl &lt;= sr {
//       // return &amp;No
//       r = r.Copy()
//       root := extractMin(&amp;r)
//       root.s = sl
//       root.l = l
//       root.r = r
//       return root
//    } else {
//       l.s--
//       l = l.Copy()
//       root := extractMax(&amp;l)
//       root.s = sl - 1
//       root.l = l
//       root.r = r
//
//       return root
//    }
//    //
//    //
//    // s := (*p).s
//    //
//    // if (*p).l == nil { *p = (*p).r; return s }
//    // if (*p).r == nil { *p = (*p).l; return s }
//    //
//    // if sl &lt;= sr {
//    //    (*p).s = extractMin(&amp;(*p).r)
//    // } else {
//    //    (*p).s = extractMax(&amp;(*p).l).s
//    //    (*p).s--
//    // }
//    // return s
// }

//func lookup(p *Node, i Position) *Node {
//   for {
//      if i == p.i {
//         return p
//      }
//      if i &lt; p.i {
//         p = p.l
//      } else {
//         i = i - p.i - 1
//         p = p.r
//      }
//   }
//}

func (tree *Tree) replacedByRightSubtree(p **Node) *Node <span class="cov0" title="0">{
   tree.copy(p)
   r := *p
   *p = (*p).r
   return r
}</span>

func (tree *Tree) replacedByLeftSubtree(p **Node) *Node <span class="cov0" title="0">{
   tree.copy(p)
   l := *p
   *p = (*p).l
   return l
}</span>

//
//func (tree *Tree) deleteMin2(p **Node) *Node {
//   for {
//      if (*p).l == nil {
//         tree.pathcopy(p)
//         r := *p
//         *p = (*p).r
//         return r
//         // return replacedByRightSubtree(p)
//      }
//      tree.pathcopy(p)
//      (*p).i--
//      p = &amp;(*p).l
//   }
//}
//

func (tree *Tree) deleteMin2(p *Node) (root *Node, deleted *Node) <span class="cov0" title="0">{
   // assert(p != nil)
   n := Node{}
   l := &amp;n
   for </span><span class="cov0" title="0">{
      tree.copy(&amp;p)
      if p.l == nil </span><span class="cov0" title="0">{
         l.l = p.r
         break</span>
      }
      <span class="cov0" title="0">p.s = p.s - 1
      l.l = p
      l = l.l
      p = p.l</span>
   }
   <span class="cov0" title="0">return n.l, p</span>
}

func (tree *Tree) deleteMin(p **Node) *Node <span class="cov8" title="1">{
   for </span><span class="cov8" title="1">{
      tree.copy(p)
      if (*p).l == nil </span><span class="cov8" title="1">{
         r := *p
         *p = (*p).r
         return r
      }</span>
      <span class="cov8" title="1">(*p).s--
      p = &amp;(*p).l</span>
   }
}

func (tree *Tree) deleteMax(p **Node) *Node <span class="cov8" title="1">{
   for </span><span class="cov8" title="1">{
      if (*p).r == nil </span><span class="cov8" title="1">{
         tree.copy(p)
         l := *p
         *p = (*p).l
         return l
      }</span>
      <span class="cov8" title="1">tree.copy(p)
      p = &amp;(*p).r</span>
   }
}

//
// func (Node) joinLr(l, r *Node, sl, sr Size) *Node {
//    if l.sizeR(sl) &lt; sr {
//       return &amp;Node{
//          s: extractMax(&amp;l),
//          s: sl - 1,
//          l: l,
//          r: r,
//       }
//    }
//    l = l.Copy()
//    l.r = Node{}.joinLr(l.r, r, l.sizeR(sl), sr)
//    return l
// }
//
// func (Node) joinRl(l, r *Node, sl, sr Size) *Node {
//    if r.s &lt; sl {
//       return &amp;Node{
//          s: extractMin(&amp;r),
//          s: sl,
//          l: l,
//          r: r,
//       }
//    }
//    r = r.Copy()
//    r.l = Node{}.joinRl(l, r.l, sl, r.s)
//    r.s = sl + r.s
//    return r
// }

func (tree *Tree) update(p *Node, i Position, x Data) <span class="cov8" title="1">{
   for </span><span class="cov8" title="1">{
      if i == p.s </span><span class="cov8" title="1">{
         p.x = x
         return
      }</span>
      <span class="cov8" title="1">if i &lt; p.s </span><span class="cov8" title="1">{
         tree.copy(&amp;p.l)
         p = p.l
      }</span> else<span class="cov8" title="1"> {
         tree.copy(&amp;p.r)
         i = i - p.s - 1
         p = p.r
      }</span>
   }
}

// func (Node) update(root **Node, i Position, s Data) {
//    p := root
//    for {
//       *p = (*p).copy()
//       if i == (*p).s {
//          (*p).s = s
//          return
//       }
//       if i &lt; (*p).s {
//          p = &amp;(*p).l
//       } else {
//          i = i - (*p).s - 1
//          p = &amp;(*p).r
//       }
//    }
// }

//
// func (p *Node) unzip(i Position) (*Node, *Node) {
//    n := Node{}
//    l := &amp;n
//    r := &amp;n
//    for {
//       if p == nil {
//          return n.r, n.l
//       }
//       mutable(&amp;p)
//       if i == p.s {
//          l.r = p.l
//          r.l = p
//          p.l = nil
//          p.s = 0
//          return n.r, n.l
//       }
//       if i &lt; p.s {
//          p.s = p.s - i // There will be `i` nodes attached to l**.
//          r.l = p
//          r = r.l
//          p = p.l
//
//       } else {
//          l.r = p
//          i = i - p.s - 1 // Skip all the nodes to the left, incl. p*.
//          l = l.r
//          p = p.r
//       }
//    }
// }
//
// func (p *Node) unzip2(i Position) (*Node, *Node) {
//    n := Node{}
//    l := &amp;n
//    r := &amp;n
//    for p != nil {
//       mutable(&amp;p)
//       if i &lt;= p.s {
//          p.s = p.s - i           // There will be `i` nodes attached to l**.
//          r.l = p
//          r = r.l
//          p = p.l
//
//       } else {
//          l.r = p
//          i = i - p.s - 1         // Skip all the nodes to the left, incl. p*.
//          l = l.r
//          p = p.r
//       }
//    }
//    l.r = nil
//    r.l = nil
//    return n.r, n.l
// }

// func (Node) split(p *Node, i Position, l, r **Node) {
//    *l, *r = p.unzip(i)
// }

//
// type BST struct {
//    List
//    Root *Node
//    Size Size
//    Strategy
// }
//
// type BST = BST
//
// type Strategy interface {
//
//    //
//    new(...Data) *BST
//
//    //
//    access(p **Node, i Position) Data
//
//    //
//    update(p **Node, i Position, s Data)
//
//    //
//    delete(p **Node, i Position, s Size) *Node
//
//    //
//    insert(p **Node, i Position, s Size, s Data)
//
//    //
//    join(l *Node, r *Node, sl, sr Size) *Node
//
//    //
//    split(p *Node, i Position, s Size, l, r **Node)
//
//    //
//    each(p *Node, visit func(Node))
//
//    //
//    filter(p *Node, predicate func(*Node) bool) (*Node, Size)
//
//    //
//    apply(p *Node, mutator func(Data) Data) *Node
//
//    //
//    verify(p *Node, s Size)
// }
// //
// // // TODO delete this
// func (BST) FromStrategy(strategy Strategy) *BST {
//    return strategy.new()
// }
// //
// // func (t BST) New(s ...Data) abstract.List {
// //    return t.Strategy.new(s...)
// // }
// //
// // // Verifies that the tree structure is valid according to the strategy in use.
// // func (tree BST) Verify() {
// //    tree.Strategy.verify(tree.Root, tree.Size)
// // }
// //
// func (tree BST) Len() Size {
//    return tree.Size
// }
// //
// // // Clones a BST
// // func (tree *BST) Clone() abstract.List {
// //    return &amp;BST{
// //       Root:     tree.Root.reference(),
// //       Size:     tree.Size,
// //       Strategy: tree.Strategy,
// //    }
// // }
// //
// // func (tree BST) MaximumPathLength() Size {
// //    return tree.Root.MaximumPathLength()
// // }
// //
// // // Creates a tree from an existing sequence.
// // // TODO BST from array is not a great pattern, because some strategies have their own "new"
// func (tree BST) ofArray(array []Data) *BST {
//    debug(tree.Strategy != nil)
//    tree.Root = Node{}.ofArray(array)
//    tree.Size = Size(len(array))
//    return &amp;tree
// }
// //
// // func (tree BST) Apply(mutator func (Data) Data) abstract.List {
// //    tree.Root = tree.Strategy.apply(tree.Root, func(s Data) Data {
// //       return mutator(s)
// //    })
// //    return &amp;tree
// // }
// //
// // func (tree BST) Each(visit func(Data)) {
// //    tree.Strategy.each(tree.Root, func(p Node) {
// //       visit(p.s)
// //    })
// // }
// //
// // func (tree BST) Array() []Data {
// //    array := make([]Data, tree.Size)
// //    index := 0
// //    tree.Strategy.each(tree.Root, func(p Node) {
// //       array[index] = p.s; index++
// //    })
// //    return array
// // }
// //
// // func (tree *BST) Access(i Position) (s Data) {
// //    debug(i &lt; tree.Size)
// //    return tree.Strategy.access(&amp;tree.Root, i)
// // }
// //
// // func (tree *BST) Update(i Position, s Data) {
// //    debug(i &lt; tree.Size)
// //    tree.Strategy.update(&amp;tree.Root, i, s)
// // }
// // func (tree *BST) Set2(i Position, s Data) {
// //    debug(i &lt; tree.Size)
// //    tree.Strategy.update(&amp;tree.Root, i, s)
// // }
// //
// // func (tree *BST) Insert(i Position, s Data) {
// //    debug(i &lt;= tree.Size)
// //    tree.Strategy.insert(&amp;tree.Root, i, tree.Size, s)
// //    tree.Size++
// // }
// //
// // func (tree *BST) Delete(i Position) (s Data) {
// //    debug(i &lt; tree.Size)
// //    s = tree.Strategy.delete(&amp;tree.Root, i, tree.Size).s
// //    tree.Size--
// //    return
// // }
// //
// // func (tree *BST) Join(rest abstract.List) abstract.List {
// //    if tree.Size() == 0 { return rest }
// //    if rest.Size() == 0 { return tree }
// //
// //    // Clone the two joining trees to preserve them.
// //    l := tree.Clone().(*BST)
// //    r := rest.Clone().(*BST)
// //
// //    // Join the two roots into the root of the New tree.
// //    return &amp;BST{
// //       Strategy: tree.Strategy,
// //       Root:     tree.Strategy.join(l.Root, r.Root, l.Size, r.Size),
// //       Size:     l.Size + r.Size,
// //    }
// // }
// //
// // func (tree *BST) Split(i Position) (abstract.List, abstract.List) {
// //    debug(i &lt;= tree.Size)
// //
// //    // Create New containers for the left and right partitions.
// //    l := tree.Clone().(*BST)
// //    r := tree.Clone().(*BST)
// //
// //    // Split the tree at `i` into the left and right partitions.
// //    tree.Strategy.split(tree.Root, i, tree.Size, &amp;l.Root, &amp;r.Root)
// //
// //    l.Size = i
// //    r.Size = tree.Size - i
// //
// //    return l, r
// // }

//func searchL(p *Node, i Position) bool {
//   return i &lt;= p.s
//}
//
//func searchLL(p *Node, i Position) bool {
//   return i &lt;= p.l.s
//}

//func searchR(p *Node, i Position) bool {
//   return i &gt; p.i
//}
//
//func searchRR(p *Node, i Position) bool {
//   return i &gt; p.i+ p.r.i+ 1
//}

func insertL(p *Node) **Node <span class="cov8" title="1">{
   p.s++
   return &amp;p.l
}</span>

func insertR(p *Node, i *Position) **Node <span class="cov8" title="1">{
   *i = *i - p.s - 1
   return &amp;p.r
}</span>

func deleteL(p *Node) **Node <span class="cov0" title="0">{
   //println("deleteL")
   p.s--
   return &amp;p.l
}</span>

func deleteR(p *Node, i *Position) **Node <span class="cov0" title="0">{
   //println("deleteR")
   *i = *i - p.s - 1
   return &amp;p.r
}</span>

/*
func (tree *Tree) pathL(p *Node) **Node {
   // assert(p.l != nil)
   tree.copy(&amp;p.l)
   return pathL(p)
}

func (tree *Tree) pathR(p *Node, i *Position) **Node {
   // assert(p.r != nil)
   tree.copy(&amp;p.r)
   return pathR(p, i)
}
*/
// TODO: these are nuts
func (tree *Tree) pathLeft(p ***Node) <span class="cov0" title="0">{
   // assert((**p).l != nil)
   tree.copy(&amp;(**p).l)
   *p = insertL(**p)
}</span>
func (tree *Tree) pathRight(p ***Node, i *Position) <span class="cov0" title="0">{
   // assert((**p).r != nil)
   tree.copy(&amp;(**p).r)
   *p = insertR(**p, i)
}</span>
func (tree *Tree) attach(p **Node, x Data) <span class="cov0" title="0">{
   *p = tree.allocate(Node{x: x})
}</span>
func (tree *Tree) attachL(p *Node, x Data) <span class="cov0" title="0">{
   p.s++
   p.l = tree.allocate(Node{x: x})
}</span>

func (tree *Tree) attachLL(p *Node, x Data) <span class="cov0" title="0">{
   tree.copy(&amp;p.l)
   p.s++
   p.l.s++
   p.l.l = tree.allocate(Node{x: x})
}</span>
func (tree *Tree) attachRR(p *Node, x Data) <span class="cov0" title="0">{
   tree.copy(&amp;p.r)
   p.r.r = tree.allocate(Node{x: x})
}</span>
func (tree *Tree) attachLR(p *Node, x Data) <span class="cov0" title="0">{
   tree.copy(&amp;p.l)
   p.s++
   p.l.r = tree.allocate(Node{x: x})
}</span>

func (tree *Tree) attachRL(p *Node, x Data) <span class="cov0" title="0">{
   tree.copy(&amp;p.r)
   p.r.s++
   p.r.l = tree.allocate(Node{x: x})
}</span>

func (tree *Tree) attachR(p *Node, x Data) <span class="cov0" title="0">{
   p.r = tree.allocate(Node{x: x})
}</span>

func pathDeletingRightIgnoringIndex(p *Node) **Node <span class="cov0" title="0">{
   return &amp;p.r
}</span>

func (tree Tree) rotateL(p **Node) <span class="cov8" title="1">{
   tree.copy(&amp;(*p).r)
   *p = (*p).rotateL()
}</span>

func (tree Tree) rotateR(p **Node) <span class="cov8" title="1">{
   tree.copy(&amp;(*p).l)
   *p = (*p).rotateR()
}</span>

func (tree Tree) rotateRL(p **Node) <span class="cov8" title="1">{
   tree.copy(&amp;(*p).r)
   tree.copy(&amp;(*p).r.l)
   *p = (*p).rotateRL()
}</span>

func (tree Tree) rotateLR(p **Node) <span class="cov8" title="1">{
   tree.copy(&amp;(*p).l)
   tree.copy(&amp;(*p).l.r)
   *p = (*p).rotateLR()
}</span>

// // Creates a new path starting at p* by descending to the left until there is
// // no further left child, returning a pointer to the last node on that path.
//
//   func followL(p **Node) **Node {
//      if *p != nil {
//         for (*p).hasL() {
//            p = &amp;(shadow(p)).l
//         }
//      }
//      return p
//   }
//
// // Creates a new path starting at p* by descending to the right until there is
// // no further right child, returning a pointer to the last node on that path.
//
//   func followR(p **Node) **Node {
//      if *p != nil {
//         for (*p).hasR() {
//            p = &amp;(shadow(p)).r
//         }
//      }
//      return p
//   }
//
// // Creates a new path starting at p* by descending to the right until there is
// // no right child, then appends n* to the right of the last node on the path.
// //
// //    1. p* → ◯ → ◯ → ◯
// //    2. p* → ◯ → ◯ → ◯ → n*
// //
func (tree *Tree) appendR(p **Node, n *Node) <span class="cov0" title="0">{
   for *p != nil </span><span class="cov0" title="0">{
      tree.copy(p)
      p = &amp;(*p).r
   }</span>
   <span class="cov0" title="0">*p = n</span>
}

// // Creates a new path starting at p* by descending to the left until there is
// // no left child, then appends n* to the left of the last node on the path.
func (tree *Tree) appendL(p **Node, n *Node) <span class="cov0" title="0">{
   for *p != nil </span><span class="cov0" title="0">{
      tree.copy(p)
      p = &amp;(*p).l
   }</span>
   <span class="cov0" title="0">*p = n</span>
}

//// TODO put this under linked list ?
//func (tree *Tree) truncateL(p **Node) *Node {
//   // assert(*p != nil)
//   tree.copy(p)
//   for (*p).l != nil {
//      p = &amp;(*p).l
//      tree.copy(p)
//   }
//   q := *p
//   *p = nil
//   return q
//}
//
//func (tree *Tree) truncateR(p **Node) *Node {
//   // assert(*p != nil)
//   tree.copy(p)
//   for (*p).r != nil {
//      p = &amp;(*p).r
//      tree.copy(p)
//   }
//   q := *p
//   *p = nil
//   return q
//}

//
//func flipSize(p *Node, s Size) {
//   p.i = s - p.i - 1
//}

//
//// Prepends p* to a right path at g**, returning the previous right child of p*.
////
////    1. p* → r*                        p* has a right child r*.
////
////       g** → ◯ → ◯ → ◯                g** is the head of a path going right.
////
////    2. g** → p* → ◯ → ◯ → ◯           p* is prepended to the path at g**, and
////                                      g** is adjusted to have p* as the head.
////    3. Return r*
////
//func prependR(p *Node, g **Node) (r *Node) {
//   r, p.r, *g = p.r, *g, p
//   return
//}
//
//// Prepends p* to a left path at g**, returning the previous left child of p*.
//func prependL(p *Node, g **Node) (l *Node) {
//   l, p.l, *g = p.l, *g, p
//   return
//}

// Reverses the order of the nodes along the right spine of p*.
// Example:
//
//       p*
//       ↓
//      (A) → (B) → (C) → (D) → nil
//
// A given node r* replaces the nil right child of the last node on the path as
// it becomes the right child of p*, the initial head of the path.
//
// Returns the last node of the initial path, ie. the head of the reversed path.
//

//
//                        (A) → r*     Prepend (A) to  r*, p* becomes (B)
//                  (B) → (A) → r*     Prepend (B) to (A), p* becomes (C)
//            (C) → (B) → (A) → r*     Prepend (C) to (B), p* becomes (D)
//      (D) → (C) → (B) → (A) → r*     Prepend (D) to (C), p* becomes nil
//       ↑
//       return
//
//func reverseR(p *Node, r *Node) *Node {
//   for p != nil {
//      p = p.Copy()
//       p = prependR(p, &amp;r).copyOrNil()
//   }
//   return r
//}
//
//// Reverses the order of the nodes along the left spine of p*.
//func reverseL(p *Node, l *Node) *Node {
//   for p != nil {
//       p = p.Copy()
//       p = prependL(p, &amp;l).copyOrNil()
//   }
//   return l
//}
//
// func (tree FingerTree) toTreap() *Treap {
//    if tree.root == nil {
//       return &amp;tree.Treap
//    }
//    tree.root = tree.root.Copy()
//    tree.root.l = reverseL(tree.root.l.copyOrNil(), nil)
//    tree.root.r = reverseR(tree.root.r.copyOrNil(), nil)
//
//    p := tree.root.l // this is now the shoulder as connected, but they are all sizeL
//    s := tree.root.s
//    for p != nil {
//       p.s = s - p.s - 1
//       s = p.s
//       p = p.l
//    }
//    return &amp;tree.Treap
// }
//
</pre>
		
		<pre class="file" id="file16" style="display: none">package binarytree


// Moves the node at position `i` in the tree of `p` to its root and returns the
// resulting root. This algorithm is identical to splay with no rotation steps.
//
func (tree Tree) partition(p *Node, i uint64) *Node <span class="cov8" title="1">{
   // assert(i &lt; p.size())
   // measurement(&amp;partitionCount, 1)

   n := Node{s: i}
   l := &amp;n
   r := &amp;n
   for i != p.s </span><span class="cov8" title="1">{
      // measurement(&amp;partitionDepth, 1)
      tree.copy(&amp;p)
      if i &lt; p.s </span><span class="cov8" title="1">{
         p.s = p.s - i - 1
         r.l = p
         r = r.l
         p = p.l
      }</span> else<span class="cov8" title="1"> {
         i = i - p.s - 1
         l.r = p
         l = l.r
         p = p.r
      }</span>
   }
   <span class="cov8" title="1">tree.copy(&amp;p)
   l.r = p.l
   r.l = p.r
   p.l = n.r
   p.r = n.l
   p.s = n.s
   return p</span>
}

// TODO: temp because randomize uses partition
func (tree Tree) partition2(p *Node, i uint64) *Node <span class="cov0" title="0">{
   // assert(i &lt; p.size())

   n := Node{s: i}
   l := &amp;n
   r := &amp;n
   for i != p.s </span><span class="cov0" title="0">{
      //tree.copy(&amp;p)
      if i &lt; p.s </span><span class="cov0" title="0">{
         p.s = p.s - i - 1
         r.l = p
         r = r.l
         p = p.l
      }</span> else<span class="cov0" title="0"> {
         i = i - p.s - 1
         l.r = p
         l = l.r
         p = p.r
      }</span>
   }
   //tree.copy(&amp;p)
   <span class="cov0" title="0">r.l = p.r
   l.r = p.l
   p.l = n.r
   p.r = n.l
   p.s = n.s
   return p</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/random"
)

type Randomized struct {
   Tree
   random.Source // compare performance vs making this directly xoshiro
}

func (Randomized) New() List <span class="cov0" title="0">{
   return &amp;Randomized{
      Source: random.New(random.Uint64()),
   }
}</span>

//func (tree *Randomized) build(values []Data) *Node {
//   if len(values) == 0 {
//      return nil
//   }
//   m := random.LessThan(uint64(len(values)), tree.Source)
//
//   return tree.allocate(Node{
//      x: values[m],
//      s: m,
//      l: tree.build(values[:m]),
//      r: tree.build(values[m+1:]),
//   })
//}

func (tree *Randomized) Clone() List <span class="cov0" title="0">{
   return &amp;Randomized{
      Tree:   tree.Tree.Clone(),
      Source: tree.Source, // TODO: a copy method? or clone?
   }
}</span>

//  1. Node a new node for the value `s`.
//  2. Split the root into the left and right subtrees of the new node, such
//     that the first `i` nodes are on the left and the rest on the right.
//  3. Replace the previous root with the new node.
func (tree *Randomized) Insert(i Position, x Data) <span class="cov0" title="0">{
   p := &amp;tree.root
   s := tree.size
   tree.size++
   for </span><span class="cov0" title="0">{
      if random.LessThan(s+1, tree.Source) == s </span><span class="cov0" title="0">{
         n := tree.allocate(Node{x: x})
         tree.splitInto(*p, i, &amp;n.l, &amp;n.r)
         n.s = i
         *p = n
         return
      }</span>
      <span class="cov0" title="0">tree.copy(p)     //
      if i &lt;= (*p).s </span><span class="cov0" title="0">{ //
         s = (*p).s  //
         (*p).s++    //
         p = &amp;(*p).l //
      }</span> else<span class="cov0" title="0"> {
         s -= (*p).s + 1 //
         i -= (*p).s + 1 //
         p = &amp;(*p).r     //
      }</span>
   }
}

func (tree *Randomized) Delete(i Position) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   p := &amp;tree.root
   s := tree.size
   tree.size--
   for </span><span class="cov0" title="0">{
      tree.copy(p)
      if i == (*p).s </span><span class="cov0" title="0">{
         defer tree.release(*p)
         x := (*p).x
         *p = tree.join2((*p).l, (*p).r, (*p).s, s-(*p).s-1)
         return x
      }</span>
      <span class="cov0" title="0">if i &lt; (*p).s </span><span class="cov0" title="0">{
         s = (*p).s
         (*p).s--
         p = &amp;(*p).l
      }</span> else<span class="cov0" title="0"> {
         s -= (*p).s + 1
         i -= (*p).s + 1
         p = &amp;(*p).r
      }</span>
   }
}

func (tree *Randomized) join2(l *Node, r *Node, sl, sr Size) (root *Node) <span class="cov0" title="0">{
   p := &amp;root
   for </span><span class="cov0" title="0">{
      if l == nil </span><span class="cov0" title="0">{
         *p = r
         return
      }</span>
      <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
         *p = l
         return
      }</span>

      <span class="cov0" title="0">if random.LessThan(sl+sr, tree.Source) &lt; sl </span><span class="cov0" title="0">{
         tree.copy(&amp;l)
         sl = sl - l.s - 1
         *p = l
         p = &amp;l.r
         l = *p
      }</span> else<span class="cov0" title="0"> {
         tree.copy(&amp;r)
         sr = r.s
         r.s = r.s + sl
         *p = r
         p = &amp;r.l
         r = *p
      }</span>
   }
}

func (tree *Randomized) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *Randomized) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *Randomized) splitInto(p *Node, i uint64, l, r **Node) <span class="cov0" title="0">{
   for p != nil </span><span class="cov0" title="0">{
      tree.copy(&amp;p)
      if i &lt;= p.s </span><span class="cov0" title="0">{
         *r = p
         p.s = p.s - i
         r = &amp;p.l
         p = p.l
      }</span> else<span class="cov0" title="0"> {
         *l = p
         i = i - p.s - 1
         l = &amp;p.r
         p = p.r
      }</span>
   }
   <span class="cov0" title="0">*l = nil
   *r = nil</span>
}

func (tree *Randomized) split(i Size) (Tree, Tree) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   var l, r *Node
   tree.splitInto(tree.root, i, &amp;l, &amp;r)

   return Tree{arena: tree.arena, root: l, size: i},
      Tree{arena: tree.arena, root: r, size: tree.size - i}
}</span>

func (tree *Randomized) Split(i Position) (List, List) <span class="cov0" title="0">{
   l, r := tree.split(i)
   return &amp;Randomized{l, tree.Source},
      &amp;Randomized{r, tree.Source}
}</span>

// TODO check that the random source is independent
func (tree *Randomized) Join(that List) List <span class="cov0" title="0">{ // TODO check if benchmarks are affected by poointer receivers here
   l := tree
   r := that.(*Randomized)
   tree.share(l.root)
   tree.share(r.root)
   return &amp;Randomized{
      Tree{
         arena: tree.arena,
         root:  l.join2(l.root, r.root, l.size, r.size),
         size:  l.size + r.size,
      },
      tree.Source,
   }
}</span>

func (tree *Randomized) Verify() <span class="cov0" title="0">{
   tree.verifySizes()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package binarytree

// TODO: just inline all of this ? then remove the rank_balanced filename prefix?

type RankBalanced struct {
}

func (RankBalanced) rank(p *Node) int <span class="cov0" title="0">{
   return p.rank()
}</span>

func (RankBalanced) promote(p *Node)<span class="cov0" title="0">{
   p.y++
}</span>

// Deprecated
func (p *Node) rank() int <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return -1
   }</span> else<span class="cov8" title="1"> {
      return int(p.y)
   }</span>
}

func promote(p *Node) <span class="cov8" title="1">{
   p.y++
}</span>

func demote(p *Node) <span class="cov0" title="0">{
   p.y--
}</span>

func isZeroZero(p *Node) bool <span class="cov0" title="0">{
   return isZeroChild(p, p.l) &amp;&amp; isZeroChild(p, p.r)
}</span>

func isOneOne(p *Node) bool <span class="cov0" title="0">{
   return isOneChild(p, p.l) &amp;&amp; isOneChild(p, p.r)
}</span>

func isTwoTwo(p *Node) bool <span class="cov0" title="0">{
   return isTwoChild(p, p.l) &amp;&amp; isTwoChild(p, p.r)
}</span>

func rankDifference(parent, child *Node) int <span class="cov0" title="0">{
   // assert(parent.rank() &gt;= child.rank())
   return parent.rank() - child.rank()
}</span>

func isZeroChild(parent, child *Node) bool <span class="cov8" title="1">{
   return parent.rank() == child.rank() //rankDifference(parent, child) == 0
}</span>

func isOneChild(parent, child *Node) bool <span class="cov0" title="0">{
   return rankDifference(parent, child) == 1
}</span>

func isTwoChild(parent, child *Node) bool <span class="cov0" title="0">{
   return rankDifference(parent, child) == 2
}</span>

func isThreeChild(parent, child *Node) bool <span class="cov0" title="0">{
   return rankDifference(parent, child) == 3
}</span>

</pre>
		
		<pre class="file" id="file19" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type AVLRelaxedBottomUp struct {
   AVLWeakBottomUp
}

func (tree AVLRelaxedBottomUp) verifyValidRankDiffs(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant(tree.rank(p) &gt;= p.height())
   invariant(tree.rank(p) &gt; tree.rank(p.l))
   invariant(tree.rank(p) &gt; tree.rank(p.r))

   tree.verifyValidRankDiffs(p.l)
   tree.verifyValidRankDiffs(p.r)</span>
}

func (tree AVLRelaxedBottomUp) Verify() <span class="cov0" title="0">{
   tree.verifySizes()
   tree.verifyValidRankDiffs(tree.root)
}</span>

func (AVLRelaxedBottomUp) New() List <span class="cov0" title="0">{
   return &amp;AVLRelaxedBottomUp{
      AVLWeakBottomUp: *AVLWeakBottomUp{}.New().(*AVLWeakBottomUp), // TODO: ew
   }
}</span>

func (tree *AVLRelaxedBottomUp) Clone() List <span class="cov0" title="0">{
   return &amp;AVLRelaxedBottomUp{
      AVLWeakBottomUp: AVLWeakBottomUp{
         WAVL: WAVL{
            Tree: tree.Tree.Clone(),
         },
      },
   }
}</span>

func (tree *AVLRelaxedBottomUp) Delete(i Position) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   x := tree.Tree.delete(&amp;tree.root, tree.size, i)
   tree.size--
   return x
}</span>

func (tree AVLRelaxedBottomUp) join(l, r *Node, sl Size) (p *Node) <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>

   <span class="cov0" title="0">if tree.rank(l) &lt;= tree.rank(r) </span><span class="cov0" title="0">{
      return tree.build(l, tree.deleteMin(&amp;r), r, sl)
   }</span> else<span class="cov0" title="0"> {
      return tree.build(l, tree.deleteMax(&amp;l), r, sl-1)
   }</span>
}

func (tree AVLRelaxedBottomUp) Join(other List) List <span class="cov0" title="0">{
   l := tree
   r := other.(*AVLRelaxedBottomUp)

   tree.share(l.root)
   tree.share(r.root)

   return &amp;AVLRelaxedBottomUp{
      AVLWeakBottomUp: AVLWeakBottomUp{
         WAVL: WAVL{
            Tree: Tree{
               arena: tree.arena,
               root:  tree.join(l.root, r.root, l.size),
               size:  l.size + r.size,
            },
         },
      },
   }
}</span>

func (tree AVLRelaxedBottomUp) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: tree}.split(tree.root, i, tree.size)

   return &amp;AVLRelaxedBottomUp{AVLWeakBottomUp: AVLWeakBottomUp{WAVL: WAVL{Tree: Tree{arena: tree.arena, root: l, size: i}}}},
      &amp;AVLRelaxedBottomUp{AVLWeakBottomUp: AVLWeakBottomUp{WAVL: WAVL{Tree: Tree{arena: tree.arena, root: r, size: tree.size - i}}}}
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type AVLRelaxedTopDown struct {
   AVLWeakTopDown
}

func (AVLRelaxedTopDown) New() List <span class="cov0" title="0">{
   return &amp;AVLRelaxedTopDown{
      AVLWeakTopDown: *AVLWeakTopDown{}.New().(*AVLWeakTopDown),
   }
}</span>

func (tree *AVLRelaxedTopDown) Clone() List <span class="cov0" title="0">{
   return &amp;AVLRelaxedTopDown{
      AVLWeakTopDown: AVLWeakTopDown{
         WAVL: WAVL{
            Tree: tree.Tree.Clone(),
         },
      },
   }
}</span>

func (tree AVLRelaxedTopDown) Verify() <span class="cov0" title="0">{
   tree.Tree.verifySizes()
   tree.verifyValidRankDiffs(tree.root)
}</span>

func (tree AVLRelaxedTopDown) verifyValidRankDiffs(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant(tree.rank(p) &gt;= p.height())
   invariant(tree.rank(p) &gt; tree.rank(p.l))
   invariant(tree.rank(p) &gt; tree.rank(p.r))

   tree.verifyValidRankDiffs(p.l)
   tree.verifyValidRankDiffs(p.r)</span>
}

func (tree *AVLRelaxedTopDown) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *AVLRelaxedTopDown) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *AVLRelaxedTopDown) Delete(i Position) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   x := tree.Tree.delete(&amp;tree.root, tree.size, i)
   tree.size--
   return x
}</span>

func (tree AVLRelaxedTopDown) join(l, r *Node, sl Size) (p *Node) <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>

   <span class="cov0" title="0">if tree.rank(l) &lt;= tree.rank(r) </span><span class="cov0" title="0">{
      return tree.build(l, tree.deleteMin(&amp;r), r, sl)
   }</span> else<span class="cov0" title="0"> {
      return tree.build(l, tree.deleteMax(&amp;l), r, sl-1)
   }</span>
}

func (tree AVLRelaxedTopDown) Join(other List) List <span class="cov0" title="0">{
   l := tree
   r := other.(*AVLRelaxedTopDown)
   tree.share(l.root)
   tree.share(r.root)

   p := tree.join(l.root, r.root, l.size)

   return &amp;AVLRelaxedTopDown{AVLWeakTopDown: AVLWeakTopDown{WAVL{Tree: Tree{arena: tree.arena, root: p, size: l.size + r.size}}}}
}</span>

func (tree AVLRelaxedTopDown) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: tree}.split(tree.root, i, tree.size)

   return &amp;AVLRelaxedTopDown{AVLWeakTopDown: AVLWeakTopDown{WAVL: WAVL{Tree: Tree{arena: tree.arena, root: l, size: i}}}},
      &amp;AVLRelaxedTopDown{AVLWeakTopDown: AVLWeakTopDown{WAVL: WAVL{Tree: Tree{arena: tree.arena, root: r, size: tree.size - i}}}}
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">//
//In a ranked binary tree obeying the red-black rule,
//the 0-children are the red nodes, the 1-children are the black nodes. All missing nodes have rank
//difference 1 and are black. The rank of a node is the number of black nodes on a path from the node
//to a leaf, not counting the node itself: this number is independent of the path. Some authors require
//that the root of a red-black tree be black, others allow it to be either red or black. In our formulation,
//the root has no rank difference, and hence no color. Since all rank differences are 0 or 1, we can
//store the balance information in one bit per node, indicating whether its rank difference is zero (it is
//red) or one (it is black).
//
//[Guibas and Sedgewick 1978],
//
//Red-Black Rule: All rank differences are 0 or 1, and no parent of a 0-child is a 0-child

package binarytree

import . "binarysearch/abstract/list"

type RedBlackBottomUp struct {
   Tree
}

func (RedBlackBottomUp) New() List <span class="cov8" title="1">{
   return &amp;RedBlackBottomUp{}
}</span>

func (tree *RedBlackBottomUp) Clone() List <span class="cov8" title="1">{
   return &amp;RedBlackBottomUp{
      Tree: tree.Tree.Clone(),
   }
}</span>

func (tree *RedBlackBottomUp) Select(i Size) Data <span class="cov8" title="1">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *RedBlackBottomUp) Update(i Size, x Data) <span class="cov8" title="1">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *RedBlackBottomUp) rank(p *Node) int <span class="cov8" title="1">{
   return p.rank()
}</span>

func (tree *RedBlackBottomUp) Delete(i Position) (x Data) <span class="cov8" title="1">{
   // assert(i &lt; tree.size)
   tree.size = tree.size - 1
   tree.root = tree.delete(tree.root, i, &amp;x)
   return x
}</span>

func (tree *RedBlackBottomUp) delete(p *Node, i Position, x *Data) *Node <span class="cov8" title="1">{
   tree.copy(&amp;p)
   if i == p.s </span><span class="cov8" title="1">{
      *x = p.x
      defer tree.release(p)
      return tree.join(p.l, p.r, p.s)
   }</span>
   <span class="cov8" title="1">if i &lt; p.s </span><span class="cov8" title="1">{
      p.s = p.s - 1
      p.l = tree.delete(p.l, i, x)
      return tree.fixL(p)
   }</span> else<span class="cov8" title="1"> {
      p.r = tree.delete(p.r, i-p.s-1, x)
      return tree.fixR(p)
   }</span>
}

func (tree *RedBlackBottomUp) insert(p *Node, i Position, x Data) *Node <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return tree.allocate(Node{x: x})
   }</span>
   <span class="cov8" title="1">tree.copy(&amp;p)
   if i &lt;= p.s </span><span class="cov8" title="1">{
      p.s = p.s + 1
      p.l = tree.insert(p.l, i, x)
      return tree.fixL(p)
   }</span> else<span class="cov8" title="1"> {
      p.r = tree.insert(p.r, i-p.s-1, x)
      return tree.fixR(p)
   }</span>
}

func (tree *RedBlackBottomUp) Insert(i Position, x Data) <span class="cov8" title="1">{
   // assert(i &lt;= tree.size)
   tree.size = tree.size + 1
   tree.root = tree.insert(tree.root, i, x)
   return
}</span>

func (tree RedBlackBottomUp) split(p *Node, i, s Size) (l, r *Node) <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return
   }</span>
   <span class="cov8" title="1">tree.copy(&amp;p)

   sl := p.s
   sr := s - p.s - 1

   if i &lt;= (*p).s </span><span class="cov8" title="1">{
      l, r = tree.split(p.l, i, sl)
      r = tree.build(r, p, p.r, sl-i)
   }</span> else<span class="cov8" title="1"> {
      l, r = tree.split(p.r, i-sl-1, sr)
      l = tree.build(p.l, p, l, sl)
   }</span>
   <span class="cov8" title="1">return l, r</span>
}

func (tree RedBlackBottomUp) Split(i Position) (List, List) <span class="cov8" title="1">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := tree.split(tree.root, i, tree.size)
   return &amp;RedBlackBottomUp{Tree: Tree{arena: tree.arena, root: l, size: i}},
          &amp;RedBlackBottomUp{Tree: Tree{arena: tree.arena, root: r, size: tree.size - i}}
}</span>

func (tree RedBlackBottomUp) build(l, p, r *Node, sl Size) *Node <span class="cov8" title="1">{
   if tree.rank(l) == tree.rank(r) </span><span class="cov8" title="1">{
      p.l = l
      p.r = r
      p.s = sl
      p.y = uint64(p.l.rank() + 1)
      return p
   }</span>
   <span class="cov8" title="1">if tree.rank(l) &lt; tree.rank(r) </span><span class="cov8" title="1">{
      tree.copy(&amp;r)
      r.s = 1 + sl + r.s
      r.l = tree.build(l, p, r.l, sl)
      return tree.fixL(r)
   }</span> else<span class="cov8" title="1"> {
      tree.copy(&amp;l)
      l.r = tree.build(l.r, p, r, sl-l.s-1)
      return tree.fixR(l)
   }</span>
}

func (tree RedBlackBottomUp) join(l, r *Node, sl Size) (p *Node) <span class="cov8" title="1">{
   if l == nil </span><span class="cov8" title="1">{ return r }</span>
   <span class="cov8" title="1">if r == nil </span><span class="cov8" title="1">{ return l }</span>
   <span class="cov8" title="1">if tree.rank(l) &lt; tree.rank(r) </span><span class="cov8" title="1">{
      return tree.build(l, tree.deleteMin(&amp;r), r, sl)
   }</span> else<span class="cov8" title="1"> {
      return tree.build(l, tree.deleteMax(&amp;l), r, sl-1)
   }</span>
}

func (tree RedBlackBottomUp) Join(other List) List <span class="cov8" title="1">{
   tree.share(tree.root)
   tree.share(other.(*RedBlackBottomUp).root)
   return &amp;RedBlackBottomUp{
      Tree: Tree{
         arena: tree.arena,
         root:  tree.join(tree.root, other.(*RedBlackBottomUp).root, tree.size),
         size:  tree.size + other.(*RedBlackBottomUp).size,
      },
   }
}</span>

func (tree RedBlackBottomUp) fixL(p *Node) *Node <span class="cov8" title="1">{
   if isZeroChild(p, p.l) </span><span class="cov8" title="1">{
      if isZeroChild(p, p.r) </span><span class="cov8" title="1">{
         if isZeroChild(p.l, p.l.l) || isZeroChild(p.l, p.l.r) </span><span class="cov8" title="1">{
            promote(p)
         }</span>
      } else<span class="cov8" title="1"> {
         if isZeroChild(p.l, p.l.l) </span><span class="cov8" title="1">{
            return p.rotateR()
         }</span>
         <span class="cov8" title="1">if isZeroChild(p.l, p.l.r) </span><span class="cov8" title="1">{
            return p.rotateLR()
         }</span>
      }
   }
   <span class="cov8" title="1">return p</span>
}

func (tree RedBlackBottomUp) fixR(p *Node) *Node <span class="cov8" title="1">{
   if isZeroChild(p, p.r) </span><span class="cov8" title="1">{
      if isZeroChild(p, p.l) </span><span class="cov8" title="1">{
         if isZeroChild(p.r, p.r.r) || isZeroChild(p.r, p.r.l) </span><span class="cov8" title="1">{
            promote(p)
         }</span>
      } else<span class="cov8" title="1"> {
         if isZeroChild(p.r, p.r.r) </span><span class="cov8" title="1">{
            return p.rotateL()
         }</span>
         <span class="cov8" title="1">if isZeroChild(p.r, p.r.l) </span><span class="cov8" title="1">{
            return p.rotateRL()
         }</span>
      }
   }
   <span class="cov8" title="1">return p</span>
}

func (tree RedBlackBottomUp) verifyRanks(p *Node) <span class="cov8" title="1">{
   if p == nil </span><span class="cov8" title="1">{
      return
   }</span>
   <span class="cov8" title="1">invariant(tree.rank(p) &gt;= tree.rank(p.l))
   invariant(tree.rank(p) &gt;= tree.rank(p.r))

   // No zero-child has a zero-child as a parent
   if isZeroChild(p, p.l) </span><span class="cov8" title="1">{
      invariant(!isZeroChild(p.l, p.l.l))
      invariant(!isZeroChild(p.l, p.l.r))
   }</span>
   <span class="cov8" title="1">if isZeroChild(p, p.r) </span><span class="cov8" title="1">{
      invariant(!isZeroChild(p.r, p.r.l))
      invariant(!isZeroChild(p.r, p.r.r))
   }</span>
   <span class="cov8" title="1">tree.verifyRanks(p.l)
   tree.verifyRanks(p.r)</span>
}

func (tree RedBlackBottomUp) Verify() <span class="cov8" title="1">{
   tree.Tree.Verify()
   tree.verifyRanks(tree.root)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type RedBlackRelaxed struct {
   Tree
   RankBalanced
}

func (tree *RedBlackRelaxed) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   x = tree.Tree.delete(&amp;tree.root, tree.size, i)
   tree.size--
   return x
}</span>

func (tree RedBlackRelaxed) split(p *Node, i, s Size) (l, r *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)

   sl := p.s
   sr := s - p.s - 1

   if i &lt;= (*p).s </span><span class="cov0" title="0">{
      l, r = tree.split(p.l, i, sl)
      r = tree.build(r, p, p.r, sl-i)
   }</span> else<span class="cov0" title="0"> {
      l, r = tree.split(p.r, i-sl-1, sr)
      l = tree.build(p.l, p, l, sl)
   }</span>
   <span class="cov0" title="0">return l, r</span>
}

func (tree RedBlackRelaxed) Split(i Position) (RedBlackRelaxed, RedBlackRelaxed) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := tree.split(tree.root, i, tree.size)
   return RedBlackRelaxed{Tree: Tree{arena: tree.arena, root: l, size: i}},
      RedBlackRelaxed{Tree: Tree{arena: tree.arena, root: r, size: tree.size - i}}
}</span>

func (tree RedBlackRelaxed) build(l, p, r *Node, sl Size) *Node <span class="cov0" title="0">{
   if tree.rank(l) == tree.rank(r) </span><span class="cov0" title="0">{
      p.l = l
      p.r = r
      p.s = sl
      p.y = uint64(p.l.rank() + 1)
      return p
   }</span>
   <span class="cov0" title="0">if tree.rank(l) &lt; tree.rank(r) </span><span class="cov0" title="0">{
      tree.copy(&amp;r)
      r.s = 1 + sl + r.s
      r.l = tree.build(l, p, r.l, sl)
      return tree.fixL(r)
   }</span> else<span class="cov0" title="0"> {
      tree.copy(&amp;l)
      l.r = tree.build(l.r, p, r, sl-l.s-1)
      return tree.fixR(l)
   }</span>
}

func (tree RedBlackRelaxed) join(l, r *Node, sl Size) (p *Node) <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>
   <span class="cov0" title="0">if tree.rank(l) &lt; tree.rank(r) </span><span class="cov0" title="0">{
      return tree.build(l, tree.deleteMin(&amp;r), r, sl)
   }</span> else<span class="cov0" title="0"> {
      return tree.build(l, tree.deleteMax(&amp;l), r, sl-1)
   }</span>
}

func (tree RedBlackRelaxed) Join(other RedBlackRelaxed) RedBlackRelaxed <span class="cov0" title="0">{
   tree.share(tree.root)
   tree.share(other.root)
   return RedBlackRelaxed{
      Tree: Tree{
         arena: tree.arena,
         root:  tree.join(tree.root, other.root, tree.size),
         size:  tree.size + other.size,
      },
   }
}</span>

func (tree RedBlackRelaxed) fixL(p *Node) *Node <span class="cov0" title="0">{
   if isZeroChild(p, p.l) </span><span class="cov0" title="0">{
      if isZeroChild(p, p.r) </span><span class="cov0" title="0">{
         if isZeroChild(p.l, p.l.l) || isZeroChild(p.l, p.l.r) </span><span class="cov0" title="0">{
            promote(p)
            return p
         }</span>
      } else<span class="cov0" title="0"> {
         if isZeroChild(p.l, p.l.l) </span><span class="cov0" title="0">{
            return p.rotateR()
         }</span>
         <span class="cov0" title="0">if isZeroChild(p.l, p.l.r) </span><span class="cov0" title="0">{
            return p.rotateLR()
         }</span>
      }
   }
   <span class="cov0" title="0">return p</span>
}

func (tree RedBlackRelaxed) fixR(p *Node) *Node <span class="cov0" title="0">{
   if isZeroChild(p, p.r) </span><span class="cov0" title="0">{
      if isZeroChild(p, p.l) </span><span class="cov0" title="0">{
         if isZeroChild(p.r, p.r.r) || isZeroChild(p.r, p.r.l) </span><span class="cov0" title="0">{
            promote(p)
         }</span>
      } else<span class="cov0" title="0"> {
         if isZeroChild(p.r, p.r.r) </span><span class="cov0" title="0">{
            return p.rotateL()
         }</span>
         <span class="cov0" title="0">if isZeroChild(p.r, p.r.l) </span><span class="cov0" title="0">{
            return p.rotateRL()
         }</span>
      }
   }
   <span class="cov0" title="0">return p</span>
}

func (tree RedBlackRelaxed) verifyRanks(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant(tree.rank(p) &gt;= tree.rank(p.l))
   invariant(tree.rank(p) &gt;= tree.rank(p.r))

   // No zero-child has a zero-child as a parent
   if isZeroChild(p, p.l) </span><span class="cov0" title="0">{
      invariant(!isZeroChild(p.l, p.l.l))
      invariant(!isZeroChild(p.l, p.l.r))
   }</span>
   <span class="cov0" title="0">if isZeroChild(p, p.r) </span><span class="cov0" title="0">{
      invariant(!isZeroChild(p.r, p.r.l))
      invariant(!isZeroChild(p.r, p.r.r))
   }</span>
   <span class="cov0" title="0">tree.verifyRanks(p.l)
   tree.verifyRanks(p.r)</span>
}

func (tree RedBlackRelaxed) Verify() <span class="cov0" title="0">{
   tree.Tree.Verify()
   tree.verifyRanks(tree.root)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type RedBlackRelaxedBottomUp struct {
   RedBlackRelaxed
}

func (RedBlackRelaxedBottomUp) New() List <span class="cov0" title="0">{
   return &amp;RedBlackRelaxedBottomUp{}
}</span>

func (tree *RedBlackRelaxedBottomUp) Clone() List <span class="cov0" title="0">{
   return &amp;RedBlackRelaxedBottomUp{
      RedBlackRelaxed: RedBlackRelaxed{
         Tree: tree.Tree.Clone(),
      },
   }
}</span>

func (tree *RedBlackRelaxedBottomUp) insert(p *Node, i Position, x Data) *Node <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return tree.allocate(Node{x: x})
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)
   if i &lt;= p.s </span><span class="cov0" title="0">{
      p.s = p.s + 1
      p.l = tree.insert(p.l, i, x)
      return tree.fixL(p)
   }</span> else<span class="cov0" title="0"> {
      p.r = tree.insert(p.r, i-p.s-1, x)
      return tree.fixR(p)
   }</span>
}

func (tree *RedBlackRelaxedBottomUp) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.size = tree.size + 1
   tree.root = tree.insert(tree.root, i, x)
   return
}</span>

func (tree *RedBlackRelaxedBottomUp) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *RedBlackRelaxedBottomUp) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *RedBlackRelaxedBottomUp) Join(other List) List <span class="cov0" title="0">{
   return &amp;RedBlackRelaxedBottomUp{
      tree.RedBlackRelaxed.Join(other.(*RedBlackRelaxedBottomUp).RedBlackRelaxed),
   }
}</span>

func (tree *RedBlackRelaxedBottomUp) Split(i Position) (List, List) <span class="cov0" title="0">{
   l, r := tree.RedBlackRelaxed.Split(i)
   return &amp;RedBlackRelaxedBottomUp{l},
          &amp;RedBlackRelaxedBottomUp{r}
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type RedBlackRelaxedTopDown struct {
   RedBlackRelaxed
}

func (RedBlackRelaxedTopDown) New() List <span class="cov0" title="0">{
   return &amp;RedBlackRelaxedTopDown{}
}</span>

func (tree *RedBlackRelaxedTopDown) Clone() List <span class="cov0" title="0">{
   return &amp;RedBlackRelaxedTopDown{
      RedBlackRelaxed: RedBlackRelaxed{
         Tree: tree.Tree.Clone(),
      },
   }
}</span>

// This top-down insertion algorithm was translated and paraphrased from the
// _Deletion Without Rebalancing in Binary Search Trees_ paper referenced above.
func (tree *RedBlackRelaxedTopDown) insert(p **Node, i Position, x Data) <span class="cov0" title="0">{
   //
   // "If the tree is empty, create a new node of rank zero containing the item
   //  to be inserted and make it the root, completing the insertion."
   //
   if *p == nil </span><span class="cov0" title="0">{
      tree.attach(p, x)
      return
   }</span>
   <span class="cov0" title="0">tree.copy(p)
   //
   // "Otherwise, promote the root if 0,0."
   //
   if isZeroZero(*p) </span><span class="cov0" title="0">{
      promote(*p)
   }</span>
   //
   // "This establishes the invariant for the main loop of the algorithm:
   //  *p is a non-nil node that is not a 0,0-node and not a 0-child.
   <span class="cov0" title="0">for </span><span class="cov0" title="0">{
      // assert(!isZeroZero(*p))
      //
      // "From *p, take one step down the search path..."
      //
      if i &lt;= (*p).s </span><span class="cov0" title="0">{
         //
         // LEFT
         //
         // "If the next node on the search path is nil, replace it by a new
         //  node of rank 0 containing the item to be inserted. This completes
         //  the insertion: the new node may be a 0-child, but *p is not."
         //
         if (*p).l == nil </span><span class="cov0" title="0">{
            tree.attachL(*p, x)
            return
         }</span>
         <span class="cov0" title="0">if !isZeroZero((*p).l) &amp;&amp; !isZeroChild(*p, (*p).l) </span><span class="cov0" title="0">{
            tree.pathLeft(&amp;p)
            continue</span>
         }
         <span class="cov0" title="0">if isZeroZero((*p).l) </span><span class="cov0" title="0">{
            tree.pathLeft(&amp;p)
            promote(*p)
            continue</span>
         }
         // In the remaining cases, y is a 0-child, and hence neither of its children is a 0-child
         // assert(isZeroChild(*p, (*p).l))
         // assert(!isZeroChild((*p).l, (*p).l.l))
         // assert(!isZeroChild((*p).l, (*p).l.l))

         // From y, take one step down the
         // search path to z. If z is null, replace z by a new node of rank 0 containing the item to
         // be inserted; if the new node is a 0-child, do a rotate or double rotate step to restore
         // the rank rule (Figure 6(d), (e), and (f)). This completes the insertion.
         <span class="cov0" title="0">if i &lt;= (*p).l.s </span><span class="cov0" title="0">{
            //
            // LEFT LEFT
            //
            // "If this node is nil, replace it by a new node containing the
            //  item to be inserted. "
            //
            if (*p).l.l == nil </span><span class="cov0" title="0">{
               tree.attachLL(*p, x)
               if isZeroChild((*p).l, (*p).l.l) </span><span class="cov0" title="0">{ // or is p.l.rank == 0 ?
                  tree.rotateR(p)
               }</span>
               <span class="cov0" title="0">return</span>
            }
            //If z is not a 0,0-node, replace w by y and x by z, completing the
            // step (Figure 6(g)).
            <span class="cov0" title="0">if !isZeroZero((*p).l.l) </span><span class="cov0" title="0">{
               tree.pathLeft(&amp;p)
               tree.pathLeft(&amp;p)
               continue</span>
            }
            // If z is a 0,0-node but not a 1-child, promote z, and replace w by y and
            // x by z, completing the step (Figure 6(g)).
            <span class="cov0" title="0">if !isOneChild((*p).l, (*p).l.l) </span><span class="cov0" title="0">{
               tree.pathLeft(&amp;p)
               tree.pathLeft(&amp;p)
               tree.promote(*p)
               continue</span>
            }
            // Otherwise (z is a 0,0-node and a 1-child), do a rotate or double rotate step to restore the rank rule (Figure 6(h) and (i), respectively).
            //  (i) Node z is a 0,0-node and a 1-child, and y and z are both left or
            //both right children: promote z, do a rotate step, and replace w by z and x by the child of z along the search
            //path.
            <span class="cov0" title="0">tree.rotateR(p)
            tree.pathLeft(&amp;p)
            tree.promote(*p)
            continue</span>

         } else<span class="cov0" title="0"> {
            //
            // LEFT RIGHT
            //
            if (*p).l.r == nil </span><span class="cov0" title="0">{
               tree.attachLR(*p, x)
               if isZeroChild((*p).l, (*p).l.r) </span><span class="cov0" title="0">{ // or is p.l.rank == 0 ?
                  tree.rotateLR(p)
               }</span>
               <span class="cov0" title="0">return</span>
            }
            // In the remaining cases, y is a 0-child, and hence neither of its children is a 0-child.

            //If z is not a 0,0-node, replace w by y and x by z, completing the
            // step (Figure 6(g)).
            <span class="cov0" title="0">if !isZeroZero((*p).l.r) </span><span class="cov0" title="0">{
               tree.pathLeft(&amp;p)
               tree.pathRight(&amp;p, &amp;i)
               continue</span>
            }
            // If z is a 0,0-node but not a 1-child, promote z, and replace w by y and
            // x by z, completing the step (Figure 6(g)).
            <span class="cov0" title="0">if !isOneChild((*p).l, (*p).l.r) </span><span class="cov0" title="0">{
               tree.pathLeft(&amp;p)
               tree.pathRight(&amp;p, &amp;i)
               tree.promote(*p)
               continue</span>
            }
            // Otherwise (z is a 0,0-node and a 1-child), do a rotate or double rotate step to restore the rank rule (Figure 6(h) and (i), respectively).

            // (j) Node z is a 0,0-node and a 1-child, and exactly one of y and z is a left child: promote z, do a double
            //            //rotate step, replace w by whichever of x and y is on the search path from z after the rotations, and replace x
            //            //by the child of the new w on the search path.
            <span class="cov0" title="0">tree.rotateLR(p)
            tree.promote(*p)
            //
            // "If a double rotation is done, take one further step down the
            //  search path after the rotation. Ths completes the step."
            //
            if i &lt;= (*p).s </span><span class="cov0" title="0">{
               tree.pathLeft(&amp;p) // LRL
            }</span> else<span class="cov0" title="0"> {
               tree.pathRight(&amp;p, &amp;i) // LRR
            }</span>
         }
      } else<span class="cov0" title="0"> {
         //
         // RIGHT
         //
         // "If the next node on the search path is nil, replace it by a new
         //  node of rank 0 containing the item to be inserted. This completes
         //  the insertion: the new node may be a 0-child, but *p is not."
         //
         if (*p).r == nil </span><span class="cov0" title="0">{
            tree.attachR(*p, x)
            return
         }</span>
         <span class="cov0" title="0">if !isZeroZero((*p).r) &amp;&amp; !isZeroChild(*p, (*p).r) </span><span class="cov0" title="0">{
            tree.pathRight(&amp;p, &amp;i)
            continue</span>
         }
         <span class="cov0" title="0">if isZeroZero((*p).r) </span><span class="cov0" title="0">{
            tree.pathRight(&amp;p, &amp;i)
            promote(*p)
            continue</span>
         }
         // In the remaining cases, y is a 0-child, and hence neither of its children is a 0-child

         // From y, take one step down the
         // search path to z. If z is null, replace z by a new node of rank 0 containing the item to
         // be inserted; if the new node is a 0-child, do a rotate or double rotate step to restore
         // the rank rule (Figure 6(d), (e), and (f)). This completes the insertion.
         <span class="cov0" title="0">if i &gt; (*p).s+(*p).r.s+1 </span><span class="cov0" title="0">{
            //
            // RIGHT RIGHT
            //
            // "If this node is nil, replace it by a new node containing the
            //  item to be inserted. "
            //
            if (*p).r.r == nil </span><span class="cov0" title="0">{
               tree.attachRR(*p, x)
               if isZeroChild((*p).r, (*p).r.r) </span><span class="cov0" title="0">{ // or is p.r.rank == 0 ?
                  tree.rotateL(p)
               }</span>
               <span class="cov0" title="0">return</span>
            }
            // In the remaining cases, y is a 0-child, and hence neither of its children is a 0-child.

            //If z is not a 0,0-node, replace w by y and x by z, completing the
            // step (Figure 6(g)).
            <span class="cov0" title="0">if !isZeroZero((*p).r.r) </span><span class="cov0" title="0">{
               tree.pathRight(&amp;p, &amp;i)
               tree.pathRight(&amp;p, &amp;i)
               continue</span>
            }
            // If z is a 0,0-node but not a 1-child, promote z, and replace w by y and
            // x by z, completing the step (Figure 6(g)).
            <span class="cov0" title="0">if !isOneChild((*p).r, (*p).r.r) </span><span class="cov0" title="0">{
               tree.pathRight(&amp;p, &amp;i)
               tree.pathRight(&amp;p, &amp;i)
               tree.promote(*p)
               continue</span>
            }
            // Otherwise (z is a 0,0-node and a 1-child), do a rotate or double rotate step to restore the rank rule (Figure 6(h) and (i), respectively).
            //  (i) Node z is a 0,0-node and a 1-child, and y and z are both left or
            //both right children: promote z, do a rotate step, and replace w by z and x by the child of z along the search
            //path.
            <span class="cov0" title="0">tree.rotateL(p)
            tree.pathRight(&amp;p, &amp;i)
            tree.promote(*p)
            continue</span>

         } else<span class="cov0" title="0"> {
            //
            // RIGHT LEFT
            //
            if (*p).r.l == nil </span><span class="cov0" title="0">{
               tree.attachRL(*p, x)
               if isZeroChild((*p).r, (*p).r.l) </span><span class="cov0" title="0">{ // or is p.l.rank == 0 ?
                  tree.rotateRL(p)
               }</span>
               <span class="cov0" title="0">return</span>
            }
            // In the remaining cases, y is a 0-child, and hence neither of its children is a 0-child.

            //If z is not a 0,0-node, replace w by y and x by z, completing the
            // step (Figure 6(g)).
            <span class="cov0" title="0">if !isZeroZero((*p).r.l) </span><span class="cov0" title="0">{
               tree.pathRight(&amp;p, &amp;i)
               tree.pathLeft(&amp;p)
               continue</span>
            }
            // If z is a 0,0-node but not a 1-child, promote z, and replace w by y and
            // x by z, completing the step (Figure 6(g)).
            <span class="cov0" title="0">if !isOneChild((*p).r, (*p).r.l) </span><span class="cov0" title="0">{
               tree.pathRight(&amp;p, &amp;i)
               tree.pathLeft(&amp;p)
               tree.promote(*p)
               continue</span>
            }
            // Otherwise (z is a 0,0-node and a 1-child), do a rotate or double rotate step to restore the rank rule (Figure 6(h) and (i), respectively).

            // (j) Node z is a 0,0-node and a 1-child, and exactly one of y and z is a left child: promote z, do a double
            //            //rotate step, replace w by whichever of x and y is on the search path from z after the rotations, and replace x
            //            //by the child of the new w on the search path.
            <span class="cov0" title="0">tree.rotateRL(p)
            tree.promote(*p)
            //
            // "If a double rotation is done, take one further step down the
            //  search path after the rotation. Ths completes the step."
            //
            if i &gt; (*p).s </span><span class="cov0" title="0">{
               tree.pathRight(&amp;p, &amp;i) // RLR
            }</span> else<span class="cov0" title="0"> {
               tree.pathLeft(&amp;p) // RLL
            }</span>
         }
      }
   }
}

func (tree *RedBlackRelaxedTopDown) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *RedBlackRelaxedTopDown) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *RedBlackRelaxedTopDown) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.size++
   tree.insert(&amp;tree.root, i, x)
}</span>

func (tree *RedBlackRelaxedTopDown) Join(other List) List <span class="cov0" title="0">{
   return &amp;RedBlackRelaxedTopDown{
      tree.RedBlackRelaxed.Join(other.(*RedBlackRelaxedTopDown).RedBlackRelaxed),
   }
}</span>

func (tree *RedBlackRelaxedTopDown) Split(i Position) (List, List) <span class="cov0" title="0">{
   l, r := tree.RedBlackRelaxed.Split(i)
   return &amp;RedBlackRelaxedTopDown{l},
      &amp;RedBlackRelaxedTopDown{r}
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/utility"
)

type WAVL struct {
   Tree
   RankBalanced
}

func (tree WAVL) calculateRank(p *Node) <span class="cov0" title="0">{
   p.y = uint64(utility.Max(p.l.rank(), p.r.rank())) + 1
}</span>

//func (tree WAVL) assignRanksFromScratch(p *Node) {
//   if p == nil {
//      return
//   }
//   tree.assignRanksFromScratch(p.l)
//   tree.assignRanksFromScratch(p.r)
//   tree.calculateRank(p)
//}

func (tree WAVL) Verify() <span class="cov0" title="0">{
   tree.verifySizes()
   tree.verifyRanks(tree.root)
   tree.verifyHeight(tree.root, tree.size)
}</span>

func (tree WAVL) joinL(l *Node, p *Node, r *Node, sl Size) (root *Node) <span class="cov0" title="0">{
   if tree.rank(l)-tree.rank(r) &lt;= 1 </span><span class="cov0" title="0">{
      p.l = l
      p.r = r
      p.s = sl
      tree.calculateRank(p)
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;l)
   l.r = tree.joinL(l.r, p, r, sl-l.s-1)
   return tree.rebalanceBottomUpAfterInsertingRight(l)</span>
}

func (tree WAVL) joinR(l *Node, p *Node, r *Node, sl Size) (root *Node) <span class="cov0" title="0">{
   if tree.rank(r)-tree.rank(l) &lt;= 1 </span><span class="cov0" title="0">{
      p.l = l
      p.r = r
      p.s = sl
      tree.calculateRank(p)
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;r)
   r.s = 1 + sl + r.s
   r.l = tree.joinR(l, p, r.l, sl)
   return tree.rebalanceBottomUpAfterInsertingLeft(r)</span>
}

func (tree WAVL) build(l, p, r *Node, sl Size) *Node <span class="cov0" title="0">{
   if tree.rank(l) &lt;= tree.rank(r) </span><span class="cov0" title="0">{
      return tree.joinR(l, p, r, sl)
   }</span> else<span class="cov0" title="0"> {
      return tree.joinL(l, p, r, sl)
   }</span>
}

// Rebalancing is only necessary when p.r is 0-child, which is when the ranks
// are equal, given that both p and p.r are non-nil.
func (tree WAVL) rebalanceBottomUpAfterInsertingLeft(p *Node) *Node <span class="cov0" title="0">{
   if isZeroChild(p, p.l) </span><span class="cov0" title="0">{
      if isOneChild(p, p.r) </span><span class="cov0" title="0">{
         promote(p)
      }</span> else<span class="cov0" title="0"> if isTwoChild(p.l, p.l.r) </span><span class="cov0" title="0">{ // SINGLE ROTATION
         tree.rotateR(&amp;p)
         demote(p.r)
      }</span> else<span class="cov0" title="0"> { // DOUBLE ROTATION
         tree.rotateLR(&amp;p)
         promote(p)
         demote(p.l)
         demote(p.r)
      }</span>
   }
   <span class="cov0" title="0">return p</span>
}

// Rebalancing is only necessary when p.r is 0-child, which is when the ranks
// are equal, given that both p and p.r are non-nil.
func (tree WAVL) rebalanceBottomUpAfterInsertingRight(p *Node) *Node <span class="cov0" title="0">{
   if isZeroChild(p, p.r) </span><span class="cov0" title="0">{
      if isOneChild(p, p.l) </span><span class="cov0" title="0">{
         promote(p)
      }</span> else<span class="cov0" title="0"> if isTwoChild(p.r, p.r.l) </span><span class="cov0" title="0">{ // SINGLE ROTATION
         tree.rotateL(&amp;p)
         demote(p.l)
      }</span> else<span class="cov0" title="0"> { // DOUBLE ROTATION
         tree.rotateRL(&amp;p)
         promote(p)
         demote(p.l)
         demote(p.r)
      }</span>
   }
   <span class="cov0" title="0">return p</span>
}

//func (tree WAVL) verify(root *Node, size Size) {
//   tree.verifyHeight(root, size)
//   tree.verifyRanks(root)
//}

func (tree WAVL) verifyHeight(root *Node, size Size) <span class="cov0" title="0">{
   if root == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">height := root.height()

   invariant(tree.rank(root) &gt;= height || height == 0)
   invariant(tree.rank(root) &lt;= 2*height)
   invariant(tree.rank(root) &lt;= 2*int(utility.Log2(size)))</span>
}

func (tree WAVL) rebalanceOnDelete(p *Node) *Node <span class="cov0" title="0">{
   if p.isLeaf() &amp;&amp; isTwoTwo(p) </span><span class="cov0" title="0">{
      demote(p)
      return p
   }</span>
   <span class="cov0" title="0">if isThreeChild(p, p.r) </span><span class="cov0" title="0">{
      if isTwoChild(p, p.l) </span><span class="cov0" title="0">{
         demote(p)

      }</span> else<span class="cov0" title="0"> if isTwoTwo(p.l) </span><span class="cov0" title="0">{
         demote(p.l)
         demote(p)

      }</span> else<span class="cov0" title="0"> if isOneChild(p.l, p.l.l) </span><span class="cov0" title="0">{
         tree.rotateR(&amp;p)
         promote(p)
         demote(p.r)

         // assert(isTwoChild(p, p.l))
         // assert(isOneChild(p, p.r))

         if p.r.l == nil </span><span class="cov0" title="0">{
            // assert(isTwoTwo(p.r))
            demote(p.r)
         }</span>
      } else<span class="cov0" title="0"> {
         tree.rotateLR(&amp;p)
         promote(p)
         promote(p)
         demote(p.l)
         demote(p.r)
         demote(p.r)

         // assert(isTwoChild(p, p.l))
         // assert(isTwoChild(p, p.r))
      }</span>
   } else<span class="cov0" title="0"> if isThreeChild(p, p.l) </span><span class="cov0" title="0">{
      if isTwoChild(p, p.r) </span><span class="cov0" title="0">{
         demote(p)

      }</span> else<span class="cov0" title="0"> if isTwoTwo(p.r) </span><span class="cov0" title="0">{
         demote(p.r)
         demote(p)

      }</span> else<span class="cov0" title="0"> if isOneChild(p.r, p.r.r) </span><span class="cov0" title="0">{
         tree.rotateL(&amp;p)
         promote(p)
         demote(p.l)

         // assert(isOneChild(p, p.l))
         // assert(isTwoChild(p, p.r))

         if p.l.r == nil </span><span class="cov0" title="0">{
            // assert(isTwoTwo(p.l))
            demote(p.l)
         }</span>
      } else<span class="cov0" title="0"> {
         tree.rotateRL(&amp;p)
         promote(p)
         promote(p)
         demote(p.l)
         demote(p.l)
         demote(p.r)

         // assert(isTwoChild(p, p.l))
         // assert(isTwoChild(p, p.r))
      }</span>
   }
   <span class="cov0" title="0">return p</span>
}

func (tree WAVL) verifyRanks(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">if p.isLeaf() </span><span class="cov0" title="0">{
      invariant(tree.rank(p) == 0)
   }</span>
   <span class="cov0" title="0">invariant(tree.rank(p) &gt; tree.rank(p.l))
   invariant(tree.rank(p) &gt; tree.rank(p.r))

   invariant(isOneChild(p, p.l) || isTwoChild(p, p.l))
   invariant(isOneChild(p, p.r) || isTwoChild(p, p.r))

   tree.verifyRanks(p.l)
   tree.verifyRanks(p.r)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type AVLWeakBottomUp struct {
   WAVL // TODO: just use tree
}

func (AVLWeakBottomUp) New() List <span class="cov0" title="0">{
   return &amp;AVLWeakBottomUp{}
}</span>

func (tree *AVLWeakBottomUp) Clone() List <span class="cov0" title="0">{
   return &amp;AVLWeakBottomUp{
      WAVL{
         Tree: tree.Tree.Clone(),
      },
   }
}</span>

func (tree *AVLWeakBottomUp) insert(p *Node, i Position, x Data) *Node <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return tree.allocate(Node{x: x})
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)
   if i &lt;= p.s </span><span class="cov0" title="0">{
      p.s = p.s + 1
      p.l = tree.insert(p.l, i, x)
      return tree.rebalanceBottomUpAfterInsertingLeft(p)
   }</span> else<span class="cov0" title="0"> {
      p.r = tree.insert(p.r, i-p.s-1, x)
      return tree.rebalanceBottomUpAfterInsertingRight(p)
   }</span>
}

//
// "Deletion of a leaf may convert its parent, previously a 1,2 node
//  into a 2,2 leaf, violating the rank rule. In this case we begin
//  by demoting the parent, which may make it a 3-child."
//
// func (tree AVLWeakBottomUp) rebalanceBottomUpDeletingLeft(p *Node) *Node {
//    return tree.rebalanceDeletingLeft(p)
// }

//
// "Deletion of a leaf may convert its parent, previously a 1,2 node
//  into a 2,2 leaf, violating the rank rule. In this case we begin
//  by demoting the parent, which may make it a 3-child."
//
// func (tree AVLWeakBottomUp) rebalanceBottomUpDeletingRight(p *Node) *Node {
//    return tree.rebalanceDeletingRight(p)
// }

func (tree AVLWeakBottomUp) delete(p *Node, i Position, x *Data) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p)
   if i == p.s </span><span class="cov0" title="0">{
      *x = p.x
      defer tree.release(p)
      return tree.join(p.l, p.r, p.s)
   }</span>
   <span class="cov0" title="0">if i &lt; p.s </span><span class="cov0" title="0">{
      p.s = p.s - 1
      p.l = tree.delete(p.l, i, x)
   }</span> else<span class="cov0" title="0"> {
      p.r = tree.delete(p.r, i-p.s-1, x)
   }</span>
   <span class="cov0" title="0">return tree.rebalanceOnDelete(p)</span>
}

func (tree *AVLWeakBottomUp) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.root = tree.delete(tree.root, i, &amp;x)
   tree.size = tree.size - 1
   return
}</span>

func (tree *AVLWeakBottomUp) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.size = tree.size + 1
   tree.root = tree.insert(tree.root, i, x)
}</span>

func (tree AVLWeakBottomUp) extractMin(p *Node, min **Node) *Node <span class="cov0" title="0">{
   if p.l == nil </span><span class="cov0" title="0">{
      *min = tree.replacedByRightSubtree(&amp;p)
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)
   p.s--
   p.l = tree.extractMin(p.l, min)
   return tree.rebalanceOnDelete(p)</span>
}

func (tree AVLWeakBottomUp) extractMax(p *Node, max **Node) *Node <span class="cov0" title="0">{
   if p.r == nil </span><span class="cov0" title="0">{
      *max = tree.replacedByLeftSubtree(&amp;p)
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)
   p.r = tree.extractMax(p.r, max)
   return tree.rebalanceOnDelete(p)</span>
}

func (tree AVLWeakBottomUp) join2(l, r *Node, sl, sr Size) (p *Node) <span class="cov0" title="0">{
   return nil // TODO: unused tree.join(l, r, sl)
}</span>

func (tree AVLWeakBottomUp) join3(l, p, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   return tree.build(l, p, r, sl)
}</span>

func (tree AVLWeakBottomUp) join(l, r *Node, sl Size) (p *Node) <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>

   <span class="cov0" title="0">if tree.rank(l) &lt;= tree.rank(r) </span><span class="cov0" title="0">{
      return tree.build(l, p, tree.extractMin(r, &amp;p), sl)
   }</span> else<span class="cov0" title="0"> {
      return tree.build(tree.extractMax(l, &amp;p), p, r, sl-1)
   }</span>
}

func (tree *AVLWeakBottomUp) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *AVLWeakBottomUp) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree AVLWeakBottomUp) Join(that List) List <span class="cov0" title="0">{
   tree.share(tree.root)
   tree.share(that.(*AVLWeakBottomUp).root)
   return &amp;AVLWeakBottomUp{
      WAVL{
         Tree: Tree{
            arena: tree.arena,
            root:  tree.join(tree.root, that.(*AVLWeakBottomUp).root, tree.size),
            size:  tree.size + that.(*AVLWeakBottomUp).size,
         },
      },
   }
}</span>

func (tree AVLWeakBottomUp) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: tree}.split(tree.root, i, tree.size)

   return &amp;AVLWeakBottomUp{WAVL{Tree: Tree{arena: tree.arena, root: l, size: i}}},
      &amp;AVLWeakBottomUp{WAVL{Tree: Tree{arena: tree.arena, root: r, size: tree.size - i}}}
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type AVLWeakJoinBased struct {
   WAVL
}

func (AVLWeakJoinBased) New() List <span class="cov0" title="0">{
   return &amp;AVLWeakJoinBased{}
}</span>

func (tree *AVLWeakJoinBased) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *AVLWeakJoinBased) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *AVLWeakJoinBased) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.root = JoinBased{Tree: tree.Tree, Joiner: tree}.insert(tree.root, i, tree.size, tree.allocate(Node{x: x}))
   tree.size++
}</span>

func (tree *AVLWeakJoinBased) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.root = JoinBased{Tree: tree.Tree, Joiner: tree}.delete(tree.root, i, tree.size, &amp;x)
   tree.size--
   return
}</span>

func (tree *AVLWeakJoinBased) Clone() List <span class="cov0" title="0">{
   return &amp;AVLWeakJoinBased{
      WAVL{
         Tree: tree.Tree.Clone(),
      },
   }
}</span>

func (tree AVLWeakJoinBased) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: tree}.splitToBST(tree.root, i, tree.size)
   return &amp;AVLWeakJoinBased{WAVL{Tree: l}},
      &amp;AVLWeakJoinBased{WAVL{Tree: r}}
}</span>

func (tree AVLWeakJoinBased) extractMin(p *Node, min **Node) *Node <span class="cov0" title="0">{
   if p.l == nil </span><span class="cov0" title="0">{
      *min = tree.replacedByRightSubtree(&amp;p)
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)
   p.s--
   p.l = tree.extractMin(p.l, min)
   return tree.rebalanceOnDelete(p)</span>
}

func (tree AVLWeakJoinBased) extractMax(p *Node, max **Node) *Node <span class="cov0" title="0">{
   if p.r == nil </span><span class="cov0" title="0">{
      *max = tree.replacedByLeftSubtree(&amp;p)
      return p
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p)
   p.r = tree.extractMax(p.r, max)
   return tree.rebalanceOnDelete(p)</span>
}

func (tree AVLWeakJoinBased) join2(l, r *Node, sl, sr Size) (p *Node) <span class="cov0" title="0">{
   return tree.join(l, r, sl)
}</span>

func (tree AVLWeakJoinBased) join3(l, p, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   return tree.build(l, p, r, sl)
}</span>

func (tree AVLWeakJoinBased) join(l, r *Node, sl Size) (p *Node) <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>

   <span class="cov0" title="0">if tree.rank(l) &lt;= tree.rank(r) </span><span class="cov0" title="0">{
      return tree.build(l, p, tree.extractMin(r, &amp;p), sl)
   }</span> else<span class="cov0" title="0"> {
      return tree.build(tree.extractMax(l, &amp;p), p, r, sl-1)
   }</span>
}

func (tree AVLWeakJoinBased) Join(other List) List <span class="cov0" title="0">{
   l := tree
   r := other.(*AVLWeakJoinBased)

   tree.share(l.root)
   tree.share(r.root)
   return &amp;AVLWeakJoinBased{
      WAVL{
         Tree: Tree{
            arena: tree.arena,
            root:  tree.join(l.root, r.root, l.size),
            size:  l.size + r.size,
         },
      },
   }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type AVLWeakTopDown struct {
   WAVL
}

func (AVLWeakTopDown) New() List <span class="cov0" title="0">{
   return &amp;AVLWeakTopDown{}
}</span>

func (tree *AVLWeakTopDown) Clone() List <span class="cov0" title="0">{
   return &amp;AVLWeakTopDown{
      WAVL{
         Tree: tree.Tree.Clone(),
      },
   }
}</span>

// This top-down insertion algorithm was translated and paraphrased from the
// _Deletion Without Rebalancing in Binary Search Trees_ paper referenced above.
func (tree *AVLWeakTopDown) insert(p **Node, i Position, x Data) <span class="cov0" title="0">{
   //
   // "If the tree is empty, create a new node containing the item to be inserted
   //  and make it the root, completing the insertion."
   //
   if *p == nil </span><span class="cov0" title="0">{
      tree.attach(p, x)
      return
   }</span>
   <span class="cov0" title="0">tree.copy(p)
   //
   // "Otherwise, promote the root if it is not 1,1."
   //
   if isOneOne(*p) </span><span class="cov0" title="0">{
      promote(*p)
   }</span>
   // "This establishes the invariant for the main loop for the algorithm:
   //  *p is a non-nil node that is not a 1,1-node."
   //
   <span class="cov0" title="0">for </span><span class="cov0" title="0">{
      // assert(!isOneOne(*p))

      // "From *p, take one step down the search path..."
      //
      if i &lt;= (*p).s </span><span class="cov0" title="0">{
         //
         // LEFT
         //
         // "If the next node on the search path is nil, replace it by a new
         //  node containing the item to be inserted, completing the insertion.
         //
         //  The new node cannot be a 0-child since the parent is not a 1,1-node
         //  and hence has positive rank."
         //
         if (*p).l == nil </span><span class="cov0" title="0">{
            tree.attachL(*p, x)
            return
         }</span>
         //
         // "If the next node on the search path is not a 1,1-node, continue."
         //
         <span class="cov0" title="0">if !isOneOne((*p).l) </span><span class="cov0" title="0">{
            tree.pathLeft(&amp;p)
            continue</span>
         }
         // "If the next node on the search path is not a 1-child, promote it,
         //  then continue to the next step."
         //
         <span class="cov0" title="0">if !isOneChild(*p, (*p).l) </span><span class="cov0" title="0">{
            tree.pathLeft(&amp;p)
            promote(*p)
            continue</span>
         }
         // "In the remaining cases, the next node is a 1,1-node and a 1-child."
         //
         // assert(isOneOne((*p).l) &amp;&amp; isOneChild(*p, (*p).l))
         //
         // "From this node, take one further step down the search path..."
         //
         <span class="cov0" title="0">if i &lt;= (*p).l.s </span><span class="cov0" title="0">{
            //
            // LEFT LEFT
            //
            // "If this node is nil, replace it by a new node containing the
            //  item to be inserted. If the new node and its parent are both
            //  left children, or, symmetrically, both right children, do a
            //  rotate step, completing the insertion."
            //
            if (*p).l.l == nil </span><span class="cov0" title="0">{
               tree.attachLL(*p, x)
               tree.rotateR(p)
               promote(*p)
               demote((*p).r)
               return
            }</span>
            //
            // "If the new node is a right child and its parent a left child, or
            //  symmetrically if the new node is a left child and its parent a
            //  right child, do a double rotate step, completing the insertion."
            //
            //  ^That is not the case here because we know this is a left-left.
            //
            // "If this node is not a 1,1-node, continue with both search steps."
            //
            <span class="cov0" title="0">if !isOneOne((*p).l.l) </span><span class="cov0" title="0">{
               tree.pathLeft(&amp;p)
               tree.pathLeft(&amp;p)
               continue</span>
            }
            // "Otherwise promote the new node and its parent, making its parent
            //  a 0-child, then do a rotate or double rotate step to make all
            //  rank differences positive."
            <span class="cov0" title="0">tree.rotateR(p)
            promote(*p)
            demote((*p).r)
            tree.pathLeft(&amp;p)
            promote(*p)
            continue</span>

         } else<span class="cov0" title="0"> {
            //
            // LEFT RIGHT
            //
            // "If the new node is a right child and its parent a left child, or
            //  symmetrically if the new node is a left child and its parent a
            //  right child, do a double rotate step, completing the insertion."
            //
            // ^That is the case here because we know this is a left-right step,
            //  which requires a double rotation, follows by the right and left
            //  steps down the search path after the rotation.
            //
            if (*p).l.r == nil </span><span class="cov0" title="0">{
               tree.attachLR(*p, x)
               tree.rotateLR(p)
               promote(*p)
               demote((*p).r)
               return
            }</span>
            //
            // "If this node is not a 1,1-node, continue with both search steps."
            //
            <span class="cov0" title="0">if !isOneOne((*p).l.r) </span><span class="cov0" title="0">{
               tree.pathLeft(&amp;p)
               tree.pathRight(&amp;p, &amp;i)
               continue</span>
            }
            // "Otherwise promote the new node and its parent, making its parent
            //  a 0-child, then do a rotate or double rotate step to make all
            //  rank differences positive."
            //
            <span class="cov0" title="0">tree.rotateLR(p)
            promote(*p)
            promote(*p)
            demote((*p).r)
            //
            // "If a double rotation is done, take one further step down the
            //  search path after the rotation. Ths completes the step."
            //
            if i &lt;= (*p).s </span><span class="cov0" title="0">{
               tree.pathLeft(&amp;p) // LRL
            }</span> else<span class="cov0" title="0"> {
               tree.pathRight(&amp;p, &amp;i) // LRR
            }</span>
         }
      } else<span class="cov0" title="0"> {
         //
         // RIGHT
         //
         // Comments follow symmetrically from above.
         //
         if (*p).r == nil </span><span class="cov0" title="0">{
            tree.attachR(*p, x)
            return
         }</span>
         <span class="cov0" title="0">if !isOneOne((*p).r) </span><span class="cov0" title="0">{
            tree.pathRight(&amp;p, &amp;i)
            continue</span>
         }
         <span class="cov0" title="0">if !isOneChild(*p, (*p).r) </span><span class="cov0" title="0">{
            tree.pathRight(&amp;p, &amp;i)
            promote(*p)
            continue</span>
         }

         <span class="cov0" title="0">if i &gt; (*p).s+(*p).r.s+1 </span><span class="cov0" title="0">{
            //
            // RIGHT RIGHT
            //
            if (*p).r.r == nil </span><span class="cov0" title="0">{
               tree.attachRR(*p, x)
               tree.rotateL(p)
               promote(*p)
               demote((*p).l)
               return
            }</span>
            <span class="cov0" title="0">if !isOneOne((*p).r.r) </span><span class="cov0" title="0">{
               tree.pathRight(&amp;p, &amp;i)
               tree.pathRight(&amp;p, &amp;i)
               continue</span>
            }
            <span class="cov0" title="0">tree.rotateL(p)
            promote(*p)
            demote((*p).l)
            tree.pathRight(&amp;p, &amp;i)
            promote(*p)
            continue</span>

         } else<span class="cov0" title="0"> {
            //
            // RIGHT LEFT
            //
            if (*p).r.l == nil </span><span class="cov0" title="0">{
               tree.attachRL(*p, x)
               tree.rotateRL(p)
               demote((*p).l)
               promote(*p)
               return
            }</span>
            <span class="cov0" title="0">if !isOneOne((*p).r.l) </span><span class="cov0" title="0">{
               tree.pathRight(&amp;p, &amp;i)
               tree.pathLeft(&amp;p)
               continue</span>
            }
            <span class="cov0" title="0">tree.rotateRL(p)
            promote(*p)
            promote(*p)
            demote((*p).l)

            if i &gt; (*p).s </span><span class="cov0" title="0">{
               tree.pathRight(&amp;p, &amp;i) // RLR
            }</span> else<span class="cov0" title="0"> {
               tree.pathLeft(&amp;p) // RLL
            }</span>
         }
      }
   }
}

func (tree *AVLWeakTopDown) dissolve(p **Node, x *Data) <span class="cov0" title="0">{
   tree.copy(p)
   defer tree.release(*p)
   *x = (*p).x
   *p = tree.join((*p).l, (*p).r, (*p).s)
}</span>

func (tree *AVLWeakTopDown) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *AVLWeakTopDown) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *AVLWeakTopDown) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.size++
   tree.insert(&amp;tree.root, i, x)
}</span>

func (tree *AVLWeakTopDown) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   x = tree.delete(&amp;tree.root, i)
   tree.size--
   return
}</span>

func (tree AVLWeakTopDown) join3(l, p, r *Node, sl, sr Size) *Node <span class="cov0" title="0">{
   return tree.build(l, p, r, sl)
}</span>

func (tree AVLWeakTopDown) join2(l, r *Node, sl, sr Size) (p *Node) <span class="cov0" title="0">{
   return nil // TODO: unused tree.join(l, r, sl)
}</span>

func (tree AVLWeakTopDown) join(l, r *Node, sl Size) (p *Node) <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
      return l
   }</span>

   <span class="cov0" title="0">if l.y &lt;= r.y </span><span class="cov0" title="0">{
      return tree.build(l, tree.extractMin(&amp;r), r, sl)
   }</span> else<span class="cov0" title="0"> {
      return tree.build(l, tree.extractMax(&amp;l), r, sl-1)
   }</span>
}

func (tree AVLWeakTopDown) Join(other List) List <span class="cov0" title="0">{
   l := tree
   r := other.(*AVLWeakTopDown)
   tree.share(l.root)
   tree.share(r.root)
   return &amp;AVLWeakTopDown{
      WAVL{
         Tree: Tree{
            arena: tree.arena,
            root:  tree.join(l.root, r.root, l.size),
            size:  l.size + r.size,
         },
      },
   }
}</span>

func (tree AVLWeakTopDown) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: tree}.splitToBST(tree.root, i, tree.size)

   return &amp;AVLWeakTopDown{WAVL{Tree: l}},
      &amp;AVLWeakTopDown{WAVL{Tree: r}}
}</span>

// "In a deletion, if the current node is 2,2 or it is 1,2 and its 1-child
//
//   is 2,2, we can force a reset on the next search step by demoting the
//   current node in the former case, or the current node and its 1-child
//   in the latter, and rebalancing top-down from the safe node."
func (tree AVLWeakTopDown) resetSafeNode(p *Node) bool <span class="cov0" title="0">{
   if isTwoTwo(p) </span><span class="cov0" title="0">{
      demote(p)
      return true
   }</span>
   <span class="cov0" title="0">if isTwoChild(p, p.l) &amp;&amp; isTwoTwo(p.r) </span><span class="cov0" title="0">{
      // assert(isOneChild(p, p.r))
      tree.copy(&amp;p.r)
      demote(p)
      demote(p.r)
      return true
   }</span>
   <span class="cov0" title="0">if isTwoChild(p, p.r) &amp;&amp; isTwoTwo(p.l) </span><span class="cov0" title="0">{
      // assert(isOneChild(p, p.l))
      tree.copy(&amp;p.l)
      demote(p)
      demote(p.l)
      return true
   }</span>
   <span class="cov0" title="0">return false</span> // Could not reset the safe node.
}

func (tree AVLWeakTopDown) rebalanceTopDownOnDelete(p **Node) <span class="cov0" title="0">{
   *p = tree.rebalanceOnDelete(*p)
}</span>

// "Deletion of a unary node converts the child that replaces it
//
//   into a 2- or 3-child; the latter violates the rank rule."
func (tree AVLWeakTopDown) rebalanceAfterDissolve(g **Node, p **Node) <span class="cov0" title="0">{
   //
   // "Deletion of a leaf may convert its parent, previously a 1,2 node
   //  into a 2,2 leaf, violating the rank rule. In this case we begin
   //  by demoting the parent, which may make it a 3-child."
   //
   if (*p).isLeaf() &amp;&amp; isTwoTwo(*p) </span><span class="cov0" title="0">{
      demote(*p)
      tree.rebalanceTopDownOnDelete(g)
   }</span> else<span class="cov0" title="0"> {
      tree.rebalanceTopDownOnDelete(p)
   }</span>
}

func (tree AVLWeakTopDown) delete(p **Node, i Position) (x Data) <span class="cov0" title="0">{
   //
   // Deleting the root does not require any rebalancing steps because a join
   // will always produce a valid tree.
   //
   if (*p).s == i </span><span class="cov0" title="0">{
      tree.dissolve(p, &amp;x)
      return
   }</span>
   // This is the parent of the current node; the grandparent and "safe node".
   <span class="cov0" title="0">g := p
   for </span><span class="cov0" title="0">{
      tree.copy(p)
      if tree.resetSafeNode(*p) </span><span class="cov0" title="0">{
         tree.rebalanceTopDownOnDelete(g)
      }</span>
      <span class="cov0" title="0">if i &lt; (*p).s </span><span class="cov0" title="0">{
         //
         // LEFT
         //
         l := deleteL(*p)
         if (*l).s == i </span><span class="cov0" title="0">{
            //
            // The node delete is on the left; path to it then replace it by a
            // join of its subtrees, followed by a rebalancing step.
            //
            tree.dissolve(l, &amp;x)
            tree.rebalanceAfterDissolve(g, p)
            return
         }</span>
         <span class="cov0" title="0">g = p
         p = l</span>

      } else<span class="cov0" title="0"> {
         //
         // RIGHT
         //
         r := deleteR(*p, &amp;i)
         if (*r).s == i </span><span class="cov0" title="0">{
            //
            // The node delete is on the right; path to it then replace it by a
            // join of its subtrees, followed by a rebalancing step.
            //
            tree.dissolve(r, &amp;x)
            tree.rebalanceAfterDissolve(g, p)
            return
         }</span>
         <span class="cov0" title="0">g = p
         p = r</span>
      }
   }
}
func (tree AVLWeakTopDown) extractMax(p **Node) (max *Node) <span class="cov0" title="0">{
   g := p
   if (*p).r == nil </span><span class="cov0" title="0">{
      return tree.replacedByLeftSubtree(p)
   }</span>
   <span class="cov0" title="0">for </span><span class="cov0" title="0">{
      tree.copy(p)
      right := pathDeletingRightIgnoringIndex(*p)
      if tree.resetSafeNode(*p) </span><span class="cov0" title="0">{
         tree.rebalanceTopDownOnDelete(g)
      }</span>
      <span class="cov0" title="0">if (*p).r.r == nil </span><span class="cov0" title="0">{
         max = tree.replacedByLeftSubtree(right)
         tree.rebalanceAfterDissolve(g, p)
         return
      }</span>
      <span class="cov0" title="0">g = p
      p = right</span>
   }
}

func (tree AVLWeakTopDown) extractMin(p **Node) (min *Node) <span class="cov0" title="0">{
   g := p
   if (*p).l == nil </span><span class="cov0" title="0">{
      return tree.replacedByRightSubtree(p)
   }</span>
   <span class="cov0" title="0">for </span><span class="cov0" title="0">{
      tree.copy(p)
      left := deleteL(*p)
      if tree.resetSafeNode(*p) </span><span class="cov0" title="0">{
         tree.rebalanceTopDownOnDelete(g)
      }</span>
      <span class="cov0" title="0">if (*p).l.l == nil </span><span class="cov0" title="0">{
         min = tree.replacedByRightSubtree(left)
         tree.rebalanceAfterDissolve(g, p)
         return
      }</span>
      <span class="cov0" title="0">g = p
      p = left</span>
   }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "os"
)

func init() {<span class="cov8" title="1">
   //spew.Config.Indent = "       "
}</span>

//
//func CompareBalancerPartitions(balancer Balancer, measurement Measurement) {
//      const scale = 1_000_000
//      const step = 10_000
//      const iterations = 10
//      tree := Tree{}.New()
//      for size := list.Size(step); size &lt;= scale; size += step {
//         for tree.size &lt; size {
//             tree.Insert(random.Uint64() % (size + 1), 0)
//         }
//         measurement.Reset()
//         for i := 1; i &lt;= iterations; i++ {
//            tree = tree.Randomize(size)
//            tree = measurement.Measure(tree, func(tree Tree) Tree {
//               return balancer.Restore(tree)
//            })
//         }
//         fmt.Println(size, measurement.Result())
//      }
//      tree.Free()
//
//   //
//   //for name, rows := range results {
//   //   fmt.Println("#" + name)
//   //   for _, row := range rows {
//   //      fmt.Println(row...)
//   //   }
//   //   fmt.Println()
//   //   fmt.Println()
//   //}
//
//
//
//   //
//   ////
//   ////
//   ////
//   //fmt.Println("#Median")
//   //for _, size := range sizes {
//   //   tree = Tree{}.Vine(size)
//   //   tree = tree.Randomize(size)
//   //   tree.partitions = 0
//   //   tree.partitionSteps = 0
//   //   start := time.Now()
//   //   tree = Median{}.Restore(tree)
//   //   taken := time.Now().Sub(start)
//   //   fmt.Println("Median", size, tree.partitions, tree.partitionSteps, tree.root.AveragePathLength(), tree.root.MaximumPathLength(), taken.Nanoseconds())
//   //   tree.Free()
//   //}
//   //fmt.Println()
//   //fmt.Println()
//   ////
//   ////
//   ////
//   //fmt.Println("#Height")
//   //for _, size := range sizes {
//   //   tree = Tree{}.Vine(size)
//   //   tree = tree.Randomize(size)
//   //   tree.partitions = 0
//   //   tree.partitionSteps = 0
//   //   start := time.Now()
//   //   tree = Height{}.Restore(tree)
//   //   taken := time.Now().Sub(start)
//   //   fmt.Println("Height", size, tree.partitions, tree.partitionSteps, tree.root.AveragePathLength(), tree.root.MaximumPathLength(), taken.Nanoseconds())
//   //   tree.Free()
//   //}
//   //fmt.Println()
//   //fmt.Println()
//   ////
//   ////
//   ////
//   //fmt.Println("#Weight")
//   //for _, size := range sizes {
//   //   tree = Tree{}.Vine(size)
//   //   tree = tree.Randomize(size)
//   //   tree.partitions = 0
//   //   tree.partitionSteps = 0
//   //   start := time.Now()
//   //   tree = Weight{}.Restore(tree)
//   //   taken := time.Now().Sub(start)
//   //   fmt.Println("Weight", size, tree.partitions, tree.partitionSteps, tree.root.AveragePathLength(), tree.root.MaximumPathLength(), taken.Nanoseconds())
//   //   tree.Free()
//   //}
//   //
//   ////
//   //////
//   //////
//   //////
//   ////fmt.Println("#Median")
//   ////
//   ////   tree = Tree{}.Vine(size)
//   ////   tree = tree.Randomize(size)
//   ////   tree = Weight{}.Restore(tree)
//   ////   partitions = 0
//   ////   partition_steps = 0
//   ////   tree = Median{}.Restore(tree)
//   ////   fmt.Println("Median", size, partitions, partition_steps, tree.root.AveragePathLength(), tree.root.MaximumPathLength())
//   ////   tree.Free()
//   ////}
//   ////fmt.Println()
//   ////fmt.Println()
//   //////
//   //////
//   //////
//   ////fmt.Println("#Height")
//   ////for _, size := range sizes {
//   ////   tree = Tree{}.Vine(size)
//   ////   tree = tree.Randomize(size)
//   ////   tree = Weight{}.Restore(tree)
//   ////   partitions = 0
//   ////   partition_steps = 0
//   ////   tree = Height{}.Restore(tree)
//   ////   fmt.Println("Height", size, partitions, partition_steps, tree.root.AveragePathLength(), tree.root.MaximumPathLength())
//   ////   tree.Free()
//   ////}
//   ////fmt.Println()
//   ////fmt.Println()
//   //////
//   //////
//   //////
//   ////fmt.Println("#Weight")
//   ////for _, size := range sizes {
//   ////   tree = Tree{}.Vine(size)
//   ////   tree = tree.Randomize(size)
//   ////   partitions = 0
//   ////   partition_steps = 0
//   ////   tree = Weight{}.Restore(tree)
//   ////   fmt.Println("Weight", size, partitions, partition_steps, tree.root.AveragePathLength(), tree.root.MaximumPathLength())
//   ////   tree.Free()
//   ////}
//}

func Sandbox() <span class="cov0" title="0">{

   tree := &amp;Splay{}

   for i := 0; i &lt; 100; i++ </span><span class="cov0" title="0">{
      tree.Insert(Position(i), Data(i))
   }</span>

   <span class="cov0" title="0">Weight{}.Restore(tree.Tree).Draw(os.Stdout)</span>



   //t := time.Now()
   //for j := 0; j &lt; 100; j++ {
   //   tree := &amp;LBSTRelaxed{}
   //   for i := 0; i &lt; 1000000; i++ {
   //      tree.Insert(random.Uint64() % (tree.Size() + 1), Data(i))
   //   }
   //   tree.Free()
   //}
   //fmt.Println(time.Since(t))
   //
   //

   //for seed := uint64(time.Now().UnixNano()); ; seed++ {
   //   t := LBSTTopDown{}.New()
   //   r := random.New(seed)
   //   fmt.Println(seed, "---")
   //   for i := uint64(1); i &lt;= 16; i++ {
   //      j := random.LessThan(t.Size()+1, r)
   //      fmt.Println(j)
   //      t.(*LBSTTopDown).Draw(os.Stderr)
   //      t.Insert(j, 0)
   //      t.(*LBSTTopDown).Draw(os.Stderr)
   //      t.Verify()
   //   }
   //   t.Free()
   //}

   //
   //a := LBSTRelaxed{}.New().(*LBSTRelaxed)
   //b := AVLBottomUp{}.New().(*AVLBottomUp)
   //c := Splay{}.New().(*Splay)
   //
   //for i := 0; i &lt; 7; i++ {
   //  a.Insert(random.Uint64() % (uint64(i) + 1), 0)
   //  b.Insert(random.Uint64() % (uint64(i) + 1), 0)
   //  c.Insert(random.Uint64() % (uint64(i) + 1), 0)
   //}
   //a.Tree = a.Tree.Randomize(distribution.Zipf{}.New(1))
   //b.Tree = b.Tree.Randomize(distribution.Zipf{}.New(2))
   //c.Tree = c.Tree.Randomize(distribution.Zipf{}.New(3))
   //
   //a.Draw()
   //b.Draw()
   //c.Draw()
   //
   //a.Tree = a.Tree.Randomize(distribution.Zipf{}.New(1))
   //b.Tree = b.Tree.Randomize(distribution.Zipf{}.New(2))
   //c.Tree = c.Tree.Randomize(distribution.Zipf{}.New(3))
   //
   //a.Draw()
   //b.Draw()
   //c.Draw()

   //CompareBalancerPartitions(Weight{}, &amp;Duration{})
   //
   //r := random.New(123)
   //t := LBSTRelaxed{}.New()
   //start := time.Now()
   //for i := list.Size(0); i &lt; 10_000_000; i++ {
   //  t.Insert(random.LessThan(i + 1, r), 0)
   //}
   //fmt.Println(time.Now().Sub(start))
   //t.Free()
   //tree := Tree{}.Vine(10)
   //tree = tree.Randomize(123)
   //tree.Draw()
   //
   //tree = tree.Randomize(345)
   //
   //tree = tree.Randomize(123)
   //tree.Draw()
   //
   //tree = DSW{}.toVine(tree)
   //tree = tree.Randomize(123)
   //tree.Draw()
   //
   //Tree{}.Vine(10).Randomize(123).Draw()

   //MicroBenchmarkSmallerLog2()
   //
   //tree := AVLBottomUp{}.New().(*AVLBottomUp)
   //
   //fmt.Println("i", "apl")
   //for i := 0; i &lt;= 8; i++ {
   //  tree.Insert(Position(i), 0)
   //  tree.Draw()
   //}

   //Tree{}.Vine(5).Randomize(random.New(123)).Balance().Draw()
   ////Tree{}.Vine(7).Randomize(random.New(345)).Balance().Draw()
   ////
   ////tree := AVLBottomUp{}.New().(*AVLBottomUp)
   ////
   ////fmt.Println("i", "apl")
   ////for i := 0; i &lt;= 1_000_000; i++ {
   ////   tree.Insert(random.Uint64() % uint64(i + 1), 0)
   ////   if i % 1000 == 0 {
   ////      t := math.Log(float64(i))
   ////      a := tree.root.AveragePathLength()
   ////      fmt.Println(i, a, t, a / t, t / a)
   ////   }
   ////}

   //Tree{}.New().WorstCaseMedian(7).Draw()

   //Tree{}.New().Vine(6).Balance().ToWorstCaseMedian().Draw()
   //Tree{}.New().Vine(7).Balance().Draw()

   //start := time.Now()
   //
   //r := random.New(123)
   //for i := 0; i &lt; 100; i++ {
   //   Tree{}.New().Vine(1_000_000).Randomize(r).toVine().Free()
   //}
   //fmt.Println(time.Now().Sub(start))

   //Tree{}.New().WorstCaseMedian(1).Draw()
   //Tree{}.New().WorstCaseMedian(2).Draw()
   //Tree{}.New().WorstCaseMedian(3).Draw()
   //Tree{}.New().WorstCaseMedian(4).Draw()
   //Tree{}.New().WorstCaseMedian(5).Draw()
   //Tree{}.New().WorstCaseMedian(6).Draw()
   //Tree{}.New().WorstCaseMedian(7).Draw()

   //   balancers := []Balancer{
   //      Weight{},
   //      //Height{},
   //      //Median{},
   //   }
   //&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
   //   fmt.Println(numberOfCopies)
   //   t.Free()
   //=======
   //
   //   for _, balancer := range balancers {
   //
   //      scale := uint64(10000)
   //
   //      tree := Tree{}.New()
   //
   //      dist := random.New(123)
   //
   //      for tree.size &lt; scale {
   //
   //         tree.Insert(random.LessThan(tree.size+1, dist), 0)
   //
   //         //t.Run("already balanced", func(t *testing.T) {
   //         tree = tree.Clone()
   //         tree = balancer.Restore(tree)
   //         //balancer.Verify(tree)
   //         //})
   //
   //         //t.Run("randomized", func(t *testing.T) {
   //         tree = tree.Clone().Randomize()
   //         tree = balancer.Restore(tree)
   //         //balancer.Verify(tree)
   //         //})
   //
   //         //t.Run("linked list", func(t *testing.T) {
   //         tree = tree.Clone().toVine()
   //         tree = balancer.Restore(tree)
   //         //balancer.Verify(tree)
   //         //})
   //      }
   //      //tree.Verify()
   //      tree.Free()
   //   }
   //
   //   fmt.Println(__partitioning_counter, __copy_counter)
   //
   //   //
   //t := AVLBottomUp{}.New()
   //for i := uint64(0);  i &lt; 1000000; i++ {
   //   t = t.Clone()
   //   t.Insert(random.LessThan(t.Size() + 1, random.Uniform()), 0)
   //}
   //fmt.Println(__copy_counter)
   //t.Free()

   //t := TreapFingerTree{}.New()
   //for i := uint64(0);  i &lt; 1000000; i++ {
   //   t = t.Clone()
   //   t.Insert(random.LessThan(t.Size() + 1, random.Uniform()), 0)
   //}
   //fmt.Println(numberOfCopies)
   //t.Free()
   //
   //for {
   //   a := AVLBottomUp{}.New()
   //   b := AVLBottomUp{}.New()
   //
   //   n1 := random.Uint64() % 10
   //   for i := uint64(0); i &lt; n1; i++ {
   //      b.Insert(random.Uint64()%(a.Size()+1), Value(i))
   //   }
   //   n2 := random.Uint64() % 10
   //   for i := uint64(0); i &lt; n2; i++ {
   //      a.Insert(random.Uint64()%(a.Size()+1), Value(i))
   //   }
   //
   //   c := a.Join(b)
   //
   //   c.(*AVLBottomUp).Draw()
   //
   //   c.Verify()
   //
   //   a.Free()
   //   b.Free()
   //   c.Free()
   //}

   //
   //t := TreapFingerTree{Tree: Tree{}.New(), Source: random.New(123)}
   //
   //t.size = 8
   //t.root = &amp;Node{
   //  x: 3,
   //  y: 7,
   //  i: 2,
   //  t: &amp;Node{
   //     x: 1,
   //     y: 3,
   //     i: 0,
   //     t: &amp;Node{
   //        x: 2,
   //        y: 5,
   //        i: 0,
   //     },
   //  },
   //  r: &amp;Node{
   //     x: 8,
   //     y: 4,
   //     i: 3,
   //     t: &amp;Node{
   //        x: 7,
   //        y: 2,
   //        i: 2,
   //        t: &amp;Node{
   //           x: 5,
   //           y: 1,
   //           i: 0,
   //           r: &amp;Node{
   //              x: 6,
   //              y: 0,
   //              i: 0,
   //           },
   //        },
   //     },
   //     r: &amp;Node{
   //        x: 4,
   //        y: 6,
   //        i: 0,
   //     },
   //  },
   //}
   //t.Verify()
   //t.Draw()
   //
   //t, r := t.Split(5)
   //
   //t.(*TreapFingerTree).Draw()
   //r.(*TreapFingerTree).Draw()
   //
   //t.Verify()
   //r.Verify()
   //t.Verify()
   //
   //n := list.Size(8)
   //
   //for i := list.Size(0); i &lt; n; i++ {
   //   t.Insert(i, i + 1)
   //}
   //for i := list.Size(0); i &lt; n; i++ {
   //   fmt.Println("===")
   //   fmt.Println(i)
   //   t, r := t.Split(i)
   //   t.(*TreapFingerTree).Draw(os.Stdout)
   //   t.(*TreapFingerTree).Draw(os.Stdout)
   //   r.(*TreapFingerTree).Draw(os.Stdout)
   //   t.Verify()
   //   r.Verify()
   //   t.Verify()
   //
   //   t = t.Join(r)
   //   fmt.Println("---")
   //   t.(*TreapFingerTree).Draw(os.Stdout)
   //}
   //t.Free()
   //}

   //for {
   //   t := TreapFingerTree{}.New()
   //   n := list.Size(8)
   //
   //   for i := list.Size(0); i &lt; n; i++ {
   //       t.Insert(i, i + 1)
   //   }
   //   for i := list.Size(0); i &lt; n; i++ {
   //      fmt.Println("===")
   //      fmt.Println(i)
   //      t, r := t.Split(i)
   //      t.(*TreapFingerTree).Draw(os.Stdout)
   //      t.(*TreapFingerTree).Draw(os.Stdout)
   //      r.(*TreapFingerTree).Draw(os.Stdout)
   //      t.Verify()
   //      r.Verify()
   //      t.Verify()
   //
   //      t = t.Join(r)
   //      fmt.Println("---")
   //      t.(*TreapFingerTree).Draw(os.Stdout)
   //   }
   //   t.Free()
   //}

   //Tree{}.New(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 50, 100).Draw(os.Stdout)
   //
   //
   //  Tree{
   //     root: &amp;Node{
   //        x: 5,
   //        r: &amp;Node{
   //           x: 6,
   //        },
   //        t: &amp;Node{
   //           x: 4,
   //           t: &amp;Node{
   //              x: 3,
   //              t: &amp;Node{
   //                 x: 2,
   //                 t: &amp;Node{
   //                    x: 1,
   //                 },
   //              },
   //           },
   //        },
   //     }}.Draw(os.Stdout)
   //
   //t.Run("linked list right", func(t *testing.T) {
   //   expect(Draw(Tree{
   //      root: &amp;Node{
   //         x: 2,
   //         t: &amp;Node{x: 1},
   //         r: &amp;Node{
   //            x: 3,
   //            r: &amp;Node{
   //               x: 4,
   //               r: &amp;Node{
   //                  x: 5,
   //                  r: &amp;Node{
   //                     x: 6,
   //                  },
   //               },
   //            },
   //         },
   //      },
   //   }), `
   //                           123
   //                            ╰───────────────╮
   //                                           234
   //                                            ╰───────╮
   //                                                   345
   //                                                    ╰───╮
   //                                                       456
   //                                                        ╰─╮
   //                                                         567`,
   //   )
   //})

   //r := random.New(123)
   //i := 0
   //for {
   //  fmt.Println("-------------")
   //  t := TreapFingerTree{}.New().(*TreapFingerTree)
   //
   //  for n := random.LessThan(16, r); n &gt; 0; n-- {
   //     t.Insert(random.LessThan(t.size, r), n)
   //  }
   //  x, y := t.Split(random.LessThan(t.size + 1, r))
   //  //x.(*TreapFingerTree).Draw(os.Stdout)
   //  //y.(*TreapFingerTree).Draw(os.Stdout)
   //  x.Verify()
   //  y.Verify()
   //  t.Verify()
   //  t.Free()
   //
   //  fmt.Println(i)
   //  i++
   //}

   //rand := distribution.Uniform{}.Seed(1223)
   //for {
   //   tree := RedBlackRankBalanced{}.New().(*RedBlackRankBalanced)
   //   for i, n := uint64(0), uint64(32); i &lt; n; i++ {
   //      tree.Insert(rand.LessThan(tree.size+1), i)
   //   }
   //   draw(tree.root)
   //}

   //draw := Draw{}
   //rand := distribution.Uniform{}.Seed(123)
   //for {
   //   tree := RedBlackRelaxedBottomUp{}.New().(*RedBlackRelaxedBottomUp)
   //   fmt.Println("---------")
   //   for i, n := uint64(0), uint64(32); i &lt; n; i++ {
   //      tree.Insert(rand.LessThan(tree.size+1), i)
   //   }
   //
   //   joined := tree.Join(tree).(*RedBlackRelaxedBottomUp)
   //
   //   draw.draw(tree.root)
   //   draw.draw(joined.root)
   //   joined.Verify()
   //}

   //for {
   //   draw := Draw{}
   //   spew.Dump("========================================")
   //
   //
   //   L := RedBlackRelaxedBottomUp{}.New().(*RedBlackRelaxedBottomUp)
   //   R := RedBlackRelaxedBottomUp{}.New().(*RedBlackRelaxedBottomUp)
   //
   //   for i, n := uint64(0), rand.LessThan(16); i &lt; n; i++ { L.Insert(rand.LessThan(L.size + 1), i) }
   //   for i, n := uint64(0), rand.LessThan(16); i &lt; n; i++ { R.Insert(rand.LessThan(R.size + 1), i) }
   //
   //   draw.draw(L.root)
   //   draw.draw(R.root)
   //
   //   draw.draw(L.Join(R).(*RedBlackRelaxedBottomUp).root)
   //   L.Join(R).Verify()
   //
   //   draw.draw(R.Join(L).(*RedBlackRelaxedBottomUp).root)
   //   R.Join(L).Verify()
   //}

   //treap := TreapTopDown{}.from([]abstract.Value{1,2, 3, 4,5,6,7,8,9,10})
   //
   //treap.BST.Draw()

   //treap.Verify()
   //
   //
   //n := 1 &lt;&lt; 15
   //
   //strategies := []abstract.List{
   //  &amp;Zip{},
   //  &amp;Randomized{},
   //  &amp;TreapTopDown{},
   //}
   //results := make([][]int, n)
   //
   //for _, strategy := range strategies {
   //  fmt.Print(utility.TypeName(strategy), " ")
   //}
   //fmt.Println()
   //
   //for _, strategy := range strategies {
   //
   //  operation := DeletePersistent{}
   //
   //  distribution := &amp;Ascending{}
   //
   //  instance := operation.Setup(strategy, abstract.Size(n))
   //
   //  x := 0
   //  for operation.Valid(instance) {
   //     instance, _ = operation.Update(instance, distribution)
   //     results[x] = append(results[x], instance.(BinaryTree).Root().Height())
   //     x++
   //  }
   //}
   //for _, heights := range results {
   //  for _, h := range heights {
   //     fmt.Print(h, " ")
   //  }
   //  fmt.Println()
   //}
   //
   //

   //AVLBottomUp{}.New(make([]list.Value, 1 &lt;&lt; 4 - 1)...).(*AVLBottomUp).Draw()

   //values := make([]abstract.Value, 15)
   //for i := 0; i &lt; 15; i++ {
   //   values[i] = abstract.Value(i)
   //}
   ////tree := Zip{}.New(values...)
   //tree := TreapTopDown{}.New(values...)
   //
   ////spew.Dump(tree)
   //
   //dist := distribution.Ascending{}
   //
   //for i := 0; i &lt; 3; i++ {
   //   tree = tree.Clone()
   //   tree.Delete(dist.LessThan(tree.Size()))
   //   spew.Dump(numberOfCopies)
   //}

   //
   //tree := BST{}.New(make([]abstract2.Value, 100)...)
   //
   //randomized := randomize2(tree.(*BST).root, tree.Size(), (&amp;distributions.Skewed{}).Seed(1))
   //
   ////spew.Dump(randomized.ExteriorHeightsAlongTheSpines())
   //
   //console.Histogram{
   //   Series: randomized.ExteriorHeightsAlongTheSpines(),
   //   MaximumPathLength: 20,
   //   Offset: 0,
   //}.Print(os.Stdout)
   //
   //
   //dist := (&amp;distributions.Skewed{}).Seed(1)
   //
   //tree = BST{}.New()
   //for i := 0; i &lt; 100; i++ {
   //   tree.Insert(dist.LessThan(tree.Size() + 1), 0)
   //}
   //
   //console.Histogram{
   //   Series: tree.(*BST).root.ExteriorHeightsAlongTheSpines(),
   //   MaximumPathLength: 20,
   //   Offset: 0,
   //}.Print(os.Stdout)
   //

   //N := 2000
   //I := &amp;LBSTBottomUp{}
   //tree := I.New()
   //for i := 0; i &lt; N; i++ {
   //   tree.Insert(abstract2.Position(rand.Intn(int(tree.Size() + 1))), 0)
   //}
   //var heights []int
   //tree.(*LBSTBottomUp).Inorder(func(p Node) {
   //   heights = append(heights, p.MaximumPathLength())
   //})
   //for x, y := range heights {
   //   fmt.Println(x, y)
   //}
   //
   //
   //   j := 0
   //
   //   for _, t := range heights[0] {
   //      fmt.Println(j, t + 1)
   //      j++
   //   }
   //   for _, r := range heights[1] {
   //      fmt.Println(j, r + 1)
   //      j++
   //   }
   //   if i + 1 &lt; N {
   //      fmt.Println()
   //      fmt.Println()
   //   }
   //}

   //N := 2000
   //tree := AVL{}.New()
   //for i := 0; i &lt; N; i++ {
   //   heights := tree.(*AVL).Root().InteriorHeightsAlongTheSpines()
   //
   //   j := 0
   //   tree.Insert(random.Uint64(), 0)
   //   for _, t := range heights[0] {
   //      fmt.Println(j, t + 1)
   //      j++
   //   }
   //   for _, r := range heights[1] {
   //      fmt.Println(j, r + 1)
   //      j++
   //   }
   //   if i + 1 &lt; N {
   //      fmt.Println()
   //      fmt.Println()
   //   }
   //}

   //n := 9000
   //
   //for P := 1; P &lt; 1000; P++ {
   //   spew.Dump(P)
   //   rand.Seed(int64(P))
   //
   //   v := []abstract2.Value{}
   //   for i := 0; i &lt; n; i++ {
   //      v = append(v, uint64(i))
   //   }
   //   t := FingerTreeDisjointGeometric{}.New(v...)
   //   for i := uint64(0); i &lt; t.Size(); i++ {
   //      t, r := t.Split(i)
   //      t.Verify()
   //      t.Verify()
   //      r.Verify()
   //      //
   //      invariant(slices.Equal(abstract2.Values(t), v))
   //      invariant(slices.Equal(abstract2.Values(t), v[:i]))
   //      invariant(slices.Equal(abstract2.Values(r), v[i:]))
   //   }
   //}

   //
   //v := []abstract.Value{}
   //n := 1000
   //for i := 0; i &lt; n; i++ {
   //   v = append(v, uint64(i))
   //   t := FingerTreeDisjointGeometric{}.New(v...)
   //   for i := uint64(0); i &lt; t.(*FingerTreeDisjointGeometric).HeadSize(); i++ {
   //      t := FingerTreeDisjointGeometric{}.New(v...)
   //      t, r := t.Split(i)
   //      t.Verify()
   //      r.Verify()
   //   }
   //}

   //spew.Dump(t)
   //spew.Dump(t, r)
   //
   //spew.Dump(abstract.Values(t), abstract.Values(r))

   // for depth := uint64(0); depth &lt; 120; depth++ {
   //    for size := uint64(1); size &lt; 1000000; size++ {
   //       a := sg1(depth, size)
   //       b := sg2(depth, size)
   //       if a != b {
   //          panic(fmt.Sprintf("no good! %d %d", depth, size))
   //       }
   //    }
   // }
}

//    for _, a := range distributions.Distributions(123) {
//       for _, b := range distributions.Distributions(123) {
//          tree := LBSTRelaxed{}.New().(*LBSTRelaxed)
//          for tree.size &lt; 1000000 {
//             tree.Insert(a.LessThan(tree.size+1), 0)
//          }
//          for tree.size &gt; 0 {
//             tree.Delete(b.LessThan(tree.size))
//          }
//          for tree.size &lt; 1000000 {
//             tree.Insert(a.LessThan(tree.size+1), 0)
//             tree.Insert(a.LessThan(tree.size+1), 0)
//             tree.Delete(b.LessThan(tree.size))
//          }
//          print(".")
//       }
//    }
//    println()
//
//    // println("mixed")
//    // mixed()
//    // println("insert")
//    // onlyInsert()
//    // println("delete")
//    // onlyDelete()
//    // C := map[int]uint64{}
//    // // S := random.Source(123123123)
//    // // R := &amp;Geometric{}
//    // Q := TrailingZeroes{source: random.Source(123)}
//    // H := 64
//    // // R.Seed(123456345656)
//    // for i := 0; i &lt; 1000000000; i++ {
//    //    // C[R.next()]++
//    //    C[Q.next()]++
//    // }
//    // for i := 0; i &lt; H; i++ {
//    //    println(util.PadLeft(fmt.Sprint(i), 3), util.Repeat("#",
//    //       int(math2.Ceil(math2.Log2(float64(C[i]))))))
//    // }
// }
//
// func printStats(k int) {
//    println()
//    println("1 rotations", uint64(float64(SINGLE_ROTATIONS) / float64(k)))
//    println("2 rotations", uint64(float64(DOUBLE_ROTATIONS) / float64(k)))
//    println("s rotations", uint64(float64(SINGLE_ROTATIONS + DOUBLE_ROTATIONS * 2) / float64(k)))
//    // println("promotions", uint64(float64(PROMOTIONS) / float64(k)))
//    // println("demotions", uint64(float64(DEMOTIONS) / float64(k)))
//    println("comparisons", uint64(float64(COMPARISONS) / float64(k)))
// }
//
// func mixed() {
//    n := list.Size(1_000_000)
//    r := distributions.Normal{}
//    x := list.Value(1)
//    r.Seed(123)
//    k := 5
//    for z := 0; z &lt; k; z++ {
//       t := LBST{}.New()
//       for t.Size() &lt; n {
//           t.Insert(r.LessThan(t.Size()+1), x)
//           t.Insert(r.LessThan(t.Size()+1), x)
//           t.Delete(r.LessThan(t.Size()))
//       }
//       print(".")
//    }
//    printStats(k)
// }
//
// func onlyDelete() {
//    n := list.Size(1_000_000)
//    r := distributions.Normal{}
//    r.Seed(123)
//    k := 5
//    for z := 0; z &lt; k; z++ {
//       t := LBST{}.New(make([]list.Value, n)...)
//       for t.Size() &gt; 0 {
//           t.Delete(r.LessThan(t.Size()))
//       }
//       print(".")
//    }
//    printStats(k)
//
// }
//
// func onlyInsert() {
//    n := list.Size(1_000_000)
//    r := distributions.Normal{}
//    x := list.Value(1)
//    r.Seed(123)
//    k := 5
//    for z := 0; z &lt; k; z++ {
//       t := LBST{}.New()
//       for t.Size() &lt; n {
//           t.Insert(r.LessThan(t.Size()+1), x)
//           x++
//       }
//       print(".")
//    }
//    printStats(k)
// }
//
// func InsertDeleteCyclesTest2() {
//    n := list.Size(10000)
//    r := random.Source(123)
//    x := list.Value(1)
//    t := AVLWeakTopDown{}.New()
//
//    for {
//       for t.Size() &lt; n {
//          t.Insert(random.LessThan(t.Size() + 1, r), x); x++
//       }
//       t.Verify()
//       for t.Size() &gt; n / 2 {
//          i := random.LessThan(t.Size(), r)
//          // spew.Dump(t, i)
//          t.Delete(i)
//          t.Verify()
//       }
//       print(".")
//    }
// }
//
// func InsertDeleteCyclesTest() {
//    t := AVLWeakTopDown{}.New()
//    n := list.Size(10000)
//    r := random.Source(123)
//    for {
//       for t.Size() &lt; n {
//          t.Insert(random.LessThan(t.Size() + 1, r), 0)
//          t.Verify()
//       }
//       m := random.LessThan(n / 2, r) + 1
//       for t.Size() &gt; m {
//          t.Delete(random.LessThan(t.Size(), r))
//          t.Verify()
//       }
//       print(".")
//    }
// }

//
//func sandboxJoinL() {
//
//
//   root :=
//      &amp;Node{rank: 6, s: 8,
//         l: &amp;Node{rank: 5, s: 4,
//            l: &amp;Node{rank: 3, s: 1,
//               l: &amp;Node{rank: 1, s: 0},
//               r: &amp;Node{rank: 2, s: 0,
//                  r: &amp;Node{rank: 1, s: 0},
//               },
//            },
//            r: &amp;Node{rank: 3, s: 1,
//               l: &amp;Node{rank: 1, s: 0},
//               r: &amp;Node{rank: 1, s: 0},
//            },
//         },
//         r: &amp;Node{rank: 5, s: 5,
//            l: &amp;Node{rank: 3, s: 1,
//               l: &amp;Node{rank: 1, s: 0},
//               r: &amp;Node{rank: 2, s: 1,
//                  l: &amp;Node{rank: 1, s: 0},
//                  r: &amp;Node{rank: 1, s: 0},
//               },
//            },
//            r: &amp;Node{rank: 3, s: 3,
//               l: &amp;Node{rank: 2, s: 1,
//                  l: &amp;Node{rank: 1, s: 0},
//                  r: &amp;Node{rank: 1, s: 0},
//               },
//               r: &amp;Node{rank: 2, s: 0,
//                  r: &amp;Node{rank: 1, s: 0},
//               },
//            },
//         },
//      }
//
//
//
//
//
//   // root :=
//   //    &amp;Node{rank: 7, s: 13,
//   //       l: &amp;Node{rank: 5, s: 7,
//   //          l: &amp;Node{rank: 4, s: 3,
//   //             l: &amp;Node{rank: 2, s: 1,
//   //                l: &amp;Node{rank: 1, s: 0},
//   //                r: &amp;Node{rank: 1, s: 0},
//   //             },
//   //             r: &amp;Node{rank: 2, s: 1,
//   //                l: &amp;Node{rank: 1, s: 0},
//   //                r: &amp;Node{rank: 1, s: 0},
//   //             },
//   //          },
//   //          r: &amp;Node{rank: 3, s: 2,
//   //             l: &amp;Node{rank: 2, s: 1,
//   //                l: &amp;Node{rank: 1, s: 0},
//   //             },
//   //             r: &amp;Node{rank: 2, s: 0,
//   //                r: &amp;Node{rank: 1, s: 0},
//   //             },
//   //          },
//   //       },
//   //       r: &amp;Node{rank: 5, s: 6,
//   //          l: &amp;Node{rank: 3, s: 3,
//   //             l: &amp;Node{rank: 2, s: 1,
//   //                l: &amp;Node{rank: 1, s: 0},
//   //                r: &amp;Node{rank: 1, s: 0},
//   //             },
//   //             r: &amp;Node{rank: 2, s: 0,
//   //                r: &amp;Node{rank: 1, s: 0},
//   //             },
//   //          },
//   //          r: &amp;Node{rank: 3, s: 1,
//   //             l: &amp;Node{rank: 1, s: 0},
//   //             r: &amp;Node{rank: 2, s: 1,
//   //                l: &amp;Node{rank: 1, s: 0},
//   //                r: &amp;Node{rank: 1, s: 0},
//   //             },
//   //          },
//   //       },
//   //    }
//
//
//      tree := WAVL{
//         root: root,
//         size: root.count(),
//      }
//      tree.Verify()
//
//      spew.Dump(tree.Delete(1))
//
//      // spew.Dump(tree1)
//      // spew.Dump(tree2)
//
//      tree.Verify()
//
//
//   // rand.Seed(1)
//   // N := 64
//   // x := uint64(1)
//   // for {
//   //    t := WAVL{}.New()
//   //    for t.Size() &lt; Size(N) {
//   //       t = t.Clone()
//   //       t.Insert(Pos(rand.Intn(int(t.Size()+1))), x); x++
//   //    }
//   //    t.Verify()
//   //    println("=====")
//   //
//   //    for t.Size() &gt; Size(N / 4) {
//   //        t = t.Clone()
//   //        i := Pos(rand.Intn(int(t.Size())))
//   //        println("------")
//   //        println("REMOVING", i)
//   //        spew.Dump(t)
//   //        s := t.(*WAVL).Delete(i)
//   //        println("after removal", s)
//   //        spew.Dump(t.(*WAVL))
//   //        t.Verify()
//   //    }
//   //
//   //    for t.Size() &lt; Size(N) {
//   //       t = t.Clone()
//   //       t.Insert(Pos(rand.Intn(int(t.Size()+1))), x); x++
//   //    }
//   //    t.Verify()
//   //    println("=====")
//   //    for t.Size() &gt; Size(N / 4) {
//   //        i := Pos(rand.Intn(int(t.Size())))
//   //        println("------")
//   //        println("REMOVING", i)
//   //        spew.Dump(t)
//   //        s := t.(*WAVL).Delete(i)
//   //        println("after removal", s)
//   //        spew.Dump(t.(*WAVL))
//   //        t.Verify()
//   //    }
//   // }
//
//   // for {
//   //    l := WAVL{}.New().(*WAVL)
//   //    r := WAVL{}.New().(*WAVL)
//   //
//   //    for n := rand.Intn(N); n &gt;= 0; n-- {
//   //        l.Insert(abstract.Pos(rand.Intn(int(l.Size()+1))), x); x++
//   //    }
//   //    for n := rand.Intn(N); n &gt;= 0; n-- {
//   //        r.Insert(abstract.Pos(rand.Intn(int(r.Size()+1))), x); x++
//   //    }
//   //    // if l.root.rank &gt;= r.root.rank &amp;&amp; l.root.rank - r.root.rank &gt; 2 {
//   //       p := l.Join(r)
//   //       p.Verify()
//   //    // }
//   //    print(".")
//   // }
//
//
//   // for {
//   //    l := WAVL{}.New().(*WAVL)
//   //    r := WAVL{}.New().(*WAVL)
//   //
//   //    for n := rand.Intn(N); n &gt;= 0; n-- {
//   //       l.Insert(abstract.Pos(rand.Intn(int(l.Size()+1))), x); x++
//   //    }
//   //    for n := rand.Intn(N); n &gt;= 0; n-- {
//   //       r.Insert(abstract.Pos(rand.Intn(int(r.Size()+1))), x); x++
//   //    }
//   //    p := l.Join(r)
//   //    p.Verify()
//   //    // assert(p.Size() == l.Size() + r.Size())
//   //    // assert(p.Size() == p.(*WAVL).root.count())
//   //    print(".")
//   // }
//}
</pre>
		
		<pre class="file" id="file30" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/random"
   "math/bits"
)

type Zip struct {
   Tree
   random.Source
}

func (Zip) New() List <span class="cov0" title="0">{
   return &amp;Zip{
      Source: random.New(random.Uint64()),
   }
}</span>

func (tree *Zip) Clone() List <span class="cov0" title="0">{
   return &amp;Zip{
      Tree:   tree.Tree.Clone(),
      Source: tree.Source, // TODO: copy?
   }
}</span>

func (tree *Zip) randomRank() uint64 <span class="cov0" title="0">{
   return uint64(bits.LeadingZeros64(tree.Uint64()))
}</span>

func (tree *Zip) unzip(p *Node, i Position, l, r **Node) <span class="cov0" title="0">{
   //p.partition(i, &amp;l, &amp;r)
   for p != nil </span><span class="cov0" title="0">{
      tree.copy(&amp;p)
      if i &lt;= p.s </span><span class="cov0" title="0">{
         *r = p
         p.s = p.s - i
         r = &amp;p.l
         p = *r
      }</span> else<span class="cov0" title="0"> {
         *l = p
         i = i - p.s - 1
         l = &amp;p.r
         p = *l
      }</span>
   }
   <span class="cov0" title="0">*l = nil
   *r = nil</span>
}

// When the new node's rank is greater than the rank of the current node,
// we know for sure that we can insert the new node at the current level.
//
// Otherwise, the new rank is less than or equal to the current rank.
//
//   When branching LEFT: if the ranks are equal, a split at the current
//   node would make it the right child of the new node, where an equal
//   rank would be valid. Keep searching if the new rank is less than.
//
//   When branching RIGHT: if the ranks are equal, a split at the current
//   node would make it the left child of the new node, where an equal
//   rank would NOT be valid.
func (tree *Zip) Insert(i Position, x Data) <span class="cov0" title="0">{
   tree.size++

   p := &amp;tree.root                                      // parent, pointer
   n := tree.allocate(Node{x: x, y: tree.randomRank()}) // new node

   for *p != nil </span><span class="cov0" title="0">{
      if n.y &gt; (*p).y </span><span class="cov0" title="0">{ // New rank is greater, insert here.
         break</span>
      }
      <span class="cov0" title="0">if i &lt;= (*p).s </span><span class="cov0" title="0">{
         if n.y == (*p).y </span><span class="cov0" title="0">{ // Branching left and ranks are equal.
            break</span>
         }
         <span class="cov0" title="0">tree.copy(p)
         (*p).s = (*p).s + 1 // Increase the size of the left subtree.
         p = &amp;(*p).l</span>         // Path left.
      } else<span class="cov0" title="0"> {
         tree.copy(p)
         i = i - ((*p).s + 1) // Skip the current node and left subtree.
         p = &amp;(*p).r          // Path right.
      }</span>
   }
   // assert(rank(n) &gt;= rank(*p))
   <span class="cov0" title="0">tree.unzip(*p, i, &amp;n.l, &amp;n.r) // Unzip the path into the new node.
   n.s = i                       // Set the size of the left subtree.
   *p = n</span>                        // Write the new node to the path.
}

func (tree *Zip) zip(l, r *Node, sl Size) (root *Node) <span class="cov0" title="0">{
   // assert(sl == l.size())
   p := &amp;root
   for </span><span class="cov0" title="0">{
      if l == nil </span><span class="cov0" title="0">{
         *p = r
         return
      }</span>
      <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
         *p = l
         return
      }</span>

      <span class="cov0" title="0">if rank(l) &gt;= rank(r) </span><span class="cov0" title="0">{
         tree.copy(&amp;l)
         sl = sl - l.s - 1 //l.sizeR(sl)
         *p = l
         p = &amp;l.r
         l = *p
      }</span> else<span class="cov0" title="0"> {
         tree.copy(&amp;r)
         r.s = r.s + sl
         *p = r
         p = &amp;r.l
         r = *p
      }</span>
   }
}

//
//func (tree *Zip) zipRecursive(x, y *Node, sl Size) *Node {
//   // assert(sl == x.count())
//   if x == nil { return y }
//   if y == nil { return x }
//   if rank(x) &lt; rank(y) {
//      tree.pathcopy(&amp;y)
//      y.i = y.i + sl
//      y.l = tree.zipRecursive(x, y.l, sl)
//      return y
//   } else {
//      tree.pathcopy(&amp;x)
//      sl = sl - x.i - 1
//      x.r = tree.zipRecursive(x.r, y, sl)
//      return x
//   }
//}
//
//func (tree *Zip) deleteRecursive(p *Node, i Position, x *Value) *Node {
//   if p == nil {
//      return nil
//   }
//   tree.pathcopy(&amp;p)
//   if i == p.i {
//      // assert(p.i == p.l.count())
//      *x = p.x
//      return tree.zipRecursive(p.l, p.r, p.i)
//   }
//   if i &lt; p.i {
//      p.i = p.i - 1
//      if i == p.l.i {
//         *x = p.l.x
//         tree.pathcopy(&amp;p.l)
//         tree.pathcopy(&amp;p.l.r)
//         tree.pathcopy(&amp;p.l.l)
//         p.l = tree.zipRecursive(p.l.l, p.l.r, p.l.i)
//         return p
//      } else {
//         p.l = tree.deleteRecursive(p.l, i, x)
//         return p
//      }
//   } else {
//      if (i - (p.i + 1)) == p.r.i {
//         *x = p.r.x
//         tree.pathcopy(&amp;p.r)
//         tree.pathcopy(&amp;p.r.r)
//         tree.pathcopy(&amp;p.r.l)
//         p.r = tree.zipRecursive(p.r.l, p.r.r, p.r.i)
//         return p
//      } else {
//         p.r = tree.deleteRecursive(p.r, i - (p.i + 1), x)
//         return p
//      }
//   }
//}

func (tree *Zip) delete(p **Node, i Position, x *Data) <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      if i == (*p).s </span><span class="cov0" title="0">{
         //
         // Found the node to delete.
         //
         defer tree.release(*p)
         *x = (*p).x
         if (*p).l == nil &amp;&amp; (*p).r == nil </span><span class="cov0" title="0">{
            *p = nil
         }</span> else<span class="cov0" title="0"> {
            tree.copy(p)
            *p = tree.zip((*p).l, (*p).r, (*p).s)
         }</span>
         <span class="cov0" title="0">return</span>
      }
      <span class="cov0" title="0">tree.copy(p)
      if i &lt; (*p).s </span><span class="cov0" title="0">{
         (*p).s = (*p).s - 1 // Decrease the size of the left subtree.
         p = &amp;(*p).l         // Path left.
      }</span> else<span class="cov0" title="0"> {
         i = i - ((*p).s + 1) // Skip the current node and left subtree.
         p = &amp;(*p).r          // Path right.
      }</span>
   }
}

func (tree *Zip) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   //tree.pathcopy(&amp;tree.root)
   //tree.root = tree.deleteRecursive(tree.root, i, &amp;x)
   tree.delete(&amp;tree.root, i, &amp;x)
   tree.size--
   return
}</span>

func (tree Zip) split(i Size) (Tree, Tree) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := tree.Tree.split(tree.root, i)

   return Tree{arena: tree.arena, root: l, size: i},
      Tree{arena: tree.arena, root: r, size: tree.size - i}
}</span>

func (tree *Zip) Split(i Position) (List, List) <span class="cov0" title="0">{
   l, r := tree.split(i)

   return &amp;Zip{l, tree.Source},
      &amp;Zip{r, tree.Source}
}</span>

func (tree *Zip) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *Zip) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

func (tree *Zip) Join(that List) List <span class="cov0" title="0">{
   tree.share(tree.root)
   tree.share(that.(*Zip).root)

   root := tree.zip(tree.root, that.(*Zip).root, tree.size)
   size := tree.size + that.(*Zip).size

   return &amp;Zip{Tree{arena: tree.arena, root: root, size: size}, tree.Source}
}</span>

func (tree *Zip) verifyRanks(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant(p.l == nil || p.y &gt; p.l.y)
   invariant(p.r == nil || p.y &gt; p.r.y || p.y == p.r.y)

   tree.verifyRanks(p.l)
   tree.verifyRanks(p.r)</span>
}

//func (tree *Zip) maxHeapify(p *Node) {
//   if p == nil {
//      return
//   }
//   tree.maxHeapify(p.l)
//   tree.maxHeapify(p.r)
//
//   m := p
//   if p.l != nil &amp;&amp; rank(p.l) &gt; rank(m) { m = p.l }
//   if p.r != nil &amp;&amp; rank(p.r) &gt; rank(m) { m = p.r }
//   if m != p {
//      y := p.y
//      p.y = m.y
//      m.y = y
//      tree.maxHeapify(m)
//   } else {
//      // p is either greater than or equal to both left and right children
//      // so we need to increase p
//      p.y++
//   }
//}

func (tree *Zip) Verify() <span class="cov0" title="0">{
   tree.verifySizes()
   tree.verifyRanks(tree.root)
}</span>

//func (tree *Zip) assignRanks(p *Node) {
//   if p == nil {
//      return
//   }
//   p.y = tree.randomRank()
//   tree.assignRanks(p.l)
//   tree.assignRanks(p.r)
//   return
//  //if p == nil {
//  //   return
//  //}
//  //tree.assignRanks(p.l)
//  //tree.assignRanks(p.r)
//  //
//  //if p.l == nil &amp;&amp; p.r == nil {
//  //   p.y = 0
//  //} else {
//  //   if rank(p.l) == rank(p.r) {
//  //      p.y = rank(p.l) + 1
//  //   } else if rank(p.l) &lt; rank(p.r) {
//  //      p.y = rank(p.r) + (tree.Random.Uint64() &amp; 1)
//  //   } else {
//  //      p.y = rank(p.l) + 1
//  //   }
//  //}
//}
</pre>
		
		<pre class="file" id="file31" style="display: none">package binarytree

import . "binarysearch/abstract/list"

type Splay struct {
   Tree
}

func (tree Splay) New() List <span class="cov0" title="0">{
   return &amp;Splay{}
}</span>

func (tree *Splay) Clone() List <span class="cov0" title="0">{
   return &amp;Splay{Tree: tree.Tree.Clone()}
}</span>

// `i` is the number of nodes that will be attached to the left still
// so we are not tracking the total size at any point.
// we reduce the size of the left subtree of p by i - 1
//
// size left reduces by (i + 1)
//
// the resulting size of p is then (s - p.s - 1 + i)
// the size before
//
//  1. Link `p` to the left of `r`
//
//  2. Set r
//
//     (p)            (r)
//     ↙
func (tree *Tree) linkL(p *Node, r *Node, i Position) (*Node, *Node, Size) <span class="cov0" title="0">{
   tree.copy(&amp;p.l)
   p.s = p.s - i - 1
   r.l = p
   r = r.l
   p = p.l
   return p, r, i // for those that will not be attached.. some might
   // not be linked, but it is not aware of how it is linked
}</span> // So maybe it is the number of nodes that must be taken away
//  p.s - i - 1 is the future size of the left subtree
//  p.s is the current size of the left subtree.
//  r.s is the future size of p
//  so in the future there are (i + 1) fewer nodes in the left subtree.

//

//  those nodes will NOT be linked.
//
//  So (i+i) is a

func (tree *Tree) linkR(p *Node, l *Node, i Position) (*Node, *Node, Size) <span class="cov0" title="0">{
   tree.copy(&amp;p.r)
   i = i - p.s - 1
   l.r = p
   l = l.r
   p = p.r
   return p, l, i
}</span>

func (tree *Splay) rotateL(p *Node) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p.r)
   return p.rotateL()
}</span>

func (tree *Splay) rotateR(p *Node) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p.l)
   return p.rotateR()
}</span>

func (tree *Splay) splay(p *Node, i Position) *Node <span class="cov0" title="0">{
   tree.copy(&amp;p)
   n := Node{s: i}
   l := &amp;n
   r := &amp;n
   for i != p.s </span><span class="cov0" title="0">{
      if i &lt; p.s </span><span class="cov0" title="0">{
         if i &lt; p.l.s </span><span class="cov0" title="0">{
            p, r, i = tree.linkL(tree.rotateR(p), r, i)
         }</span> else<span class="cov0" title="0"> if i &gt; p.l.s </span><span class="cov0" title="0">{
            p, r, i = tree.linkL(p, r, i)
            p, l, i = tree.linkR(p, l, i)
         }</span> else<span class="cov0" title="0"> {
            p, r, i = tree.linkL(p, r, i)
            break</span>
         }
      } else<span class="cov0" title="0"> {
         if i &gt; p.s+p.r.s+1 </span><span class="cov0" title="0">{
            p, l, i = tree.linkR(tree.rotateL(p), l, i)
         }</span> else<span class="cov0" title="0"> if i &lt; p.s+p.r.s+1 </span><span class="cov0" title="0">{
            p, l, i = tree.linkR(p, l, i)
            p, r, i = tree.linkL(p, r, i)
         }</span> else<span class="cov0" title="0"> {
            p, l, i = tree.linkR(p, l, i)
            break</span>
         }
      }
   }
   <span class="cov0" title="0">l.r = p.l
   r.l = p.r
   p.r = n.l
   p.l = n.r
   p.s = n.s
   return p</span>
}

func (tree *Splay) Splay(i Position) <span class="cov0" title="0">{
   tree.root = tree.splay(tree.root, i)
}</span>

func (tree *Splay) Size() Size <span class="cov0" title="0">{
   return tree.size
}</span>

// 1. Splay the node at `i`
// 2. Return the root.
func (tree *Splay) Select(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.Splay(i)
   return tree.root.x
}</span>

// 1. Splay the node to be updated, at position `i`.
// 2. Update the root's data.
// 3. Return the root.
func (tree *Splay) Update(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.Splay(i)
   tree.root.x = x
}</span>

//  1. Node a new node for the Data `s`.
//  2. Split the root into the left and right subtrees of the new node, such
//     that the first `i` nodes are on the left and the rest on the right.
//  3. Replace the previous root with the new node.
func (tree *Splay) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   //
   //
   if i == tree.size </span><span class="cov0" title="0">{
      tree.root = tree.allocate(Node{x: x, s: tree.size, l: tree.splayMax(tree.root)})
      tree.size++
      return
   }</span>
   <span class="cov0" title="0">l, r := tree.split(tree.root, tree.size, i)
   tree.root = tree.allocate(Node{x: x, s: i, l: l, r: r})
   tree.size++</span>
}

// 1. Splay the node to be deleted, making it the root.
// 2. Replace the root by a join of its left and right subtrees.
// 3. Return the deleted node.
func (tree *Splay) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())

   tree.Splay(i)
   defer tree.release(tree.root) // TODO: defer is difficult to translate, avoid it.
   x = tree.root.x
   tree.root = tree.join(tree.root.l, tree.root.r)
   tree.size--
   return
}</span>

func (tree *Splay) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)

   if i == tree.size </span><span class="cov0" title="0">{
      return &amp;Splay{Tree{arena: tree.arena, root: tree.root, size: tree.size}},
         &amp;Splay{Tree{arena: tree.arena, root: nil, size: 0}}
   }</span>
   //
   //
   <span class="cov0" title="0">l, r := tree.split(tree.root, tree.size, i)

   return &amp;Splay{Tree{arena: tree.arena, root: l, size: i}},
      &amp;Splay{Tree{arena: tree.arena, root: r, size: tree.size - i}}</span>
}

// 1. Splay the node at `i`.
// 2. Cut the left subtree of the root as l**, leaving a nil in its place.
// 3. The remaining root and right subtree is r**.
func (tree Splay) split(p *Node, s, i Position) (l, r *Node) <span class="cov0" title="0">{
   // assert(i &lt; s)
   p = tree.splay(p, i)
   l = p.l
   r = p
   r.l = nil
   r.s = 0
   return
}</span>

func (tree *Splay) Join(that List) List <span class="cov0" title="0">{ // TODO check if benchmarks are affected by poointer receivers here
   tree.share(tree.root)
   tree.share(that.(*Splay).root)
   return &amp;Splay{Tree{arena: tree.arena, root: tree.join(tree.root, that.(*Splay).root), size: tree.Size() + that.Size()}}
}</span>

func (tree *Splay) splayMax(l *Node) *Node <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{ // TODO is this ever nil?
      return nil
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;l)
   for l.r != nil </span><span class="cov0" title="0">{
      if l.r.r != nil </span><span class="cov0" title="0">{
         tree.copy(&amp;l.r)
         tree.copy(&amp;l.r.r)
         l.r = l.r.rotateL()
         l = l.rotateL()
      }</span> else<span class="cov0" title="0"> {
         tree.copy(&amp;l.r)
         l = l.rotateL()
      }</span>
   }
   <span class="cov0" title="0">return l</span>
}

// 1. Splay the right-most node of l*, which wouldn't have a right subtree.
// 2. Set the right subtree of the splayed node to r*.
// 3. Return the splayed node.
func (tree *Splay) join(l *Node, r *Node) *Node <span class="cov0" title="0">{
   if l == nil </span><span class="cov0" title="0">{
      return r
   }</span>
   <span class="cov0" title="0">l = tree.splayMax(l)
   l.r = r
   return l</span>
}

func (tree *Splay) Verify() <span class="cov0" title="0">{
   tree.verifySizes()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package binarytree


func (tree *Tree) split(p *Node, i uint64) (*Node, *Node) <span class="cov0" title="0">{
   n := Node{}
   l := &amp;n
   r := &amp;n
   for p != nil </span><span class="cov0" title="0">{
      tree.copy(&amp;p)
      if i &lt;= p.s </span><span class="cov0" title="0">{
         p.s = p.s - i
         r.l = p
         r = r.l
         p = p.l
      }</span> else<span class="cov0" title="0"> {
         i = i - p.s - 1
         l.r = p
         l = l.r
         p = p.r
      }</span>
   }
   <span class="cov0" title="0">l.r = nil
   r.l = nil
   return n.r, n.l</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package binarytree

import (
   . "binarysearch/abstract/list"
   "binarysearch/random"
)

type TreapFingerTree struct {
   Tree
   random.Source
}

func (TreapFingerTree) New() List <span class="cov0" title="0">{
   return &amp;TreapFingerTree{
      Source: random.New(random.Uint64()),
   }
}</span>

func (tree *TreapFingerTree) Clone() List <span class="cov0" title="0">{
   return &amp;TreapFingerTree{
      Tree:   tree.Tree.Clone(),
      Source: tree.Source,
   }
}</span>

//func (p *Node) flip(s Size) {
//   p.s = s - p.s - 1
//}

//func (p *Node) flipL(s Size) {
//   // assert(s == p.count())
//   for p != nil {
//      p = p.Copy()
//      sl := p.s
//      p.s = s - p.s - 1
//      p = p.l
//      s = sl
//   }
//}

func (tree *TreapFingerTree) reverseL(p *Node, g *Node, s Size) *Node <span class="cov0" title="0">{
   // assert(s == p.size())
   for </span><span class="cov0" title="0">{
      if p == nil </span><span class="cov0" title="0">{
         return g
      }</span>
      <span class="cov0" title="0">tree.copy(&amp;p)
      sl := p.s
      p.s = s - p.s - 1
      l := p.l
      p.l = g
      g = p
      p = l
      s = sl</span>
   }
}

func (tree *TreapFingerTree) reverseR(p *Node, g *Node) *Node <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      if p == nil </span><span class="cov0" title="0">{
         return g
      }</span>
      <span class="cov0" title="0">tree.copy(&amp;p)
      r := p.r
      p.r = g
      g = p
      p = r</span>
   }
}

//
//func (tree TreapTopDown) toTreapFingerTree() *TreapFingerTree {
//   ftree := TreapFingerTree{
//      TreapTopDown: tree,
//   }
//   ftree.Source = tree.Source
//   ftree.arena = tree.arena
//   ftree.root = tree.root
//   ftree.size = tree.size
//
//   if tree.root == nil {
//      return &amp;ftree
//   }
//   tree.pathcopy(&amp;tree.root)
//   ftree.root.l = ftree.reverseL(shared(tree.root.l), nil, tree.root.i)
//   ftree.root.r = ftree.reverseR(shared(tree.root.r), nil)
//   return &amp;ftree
//}

func (tree *TreapFingerTree) randomRank() uint64 <span class="cov0" title="0">{
   return tree.Uint64()
}</span>

func (tree *TreapFingerTree) rotateParentLeftOnRightSpine(p *Node) <span class="cov0" title="0">{
   tree.copy(&amp;p.r)
   r := p.r // parent on the spine
   p.r = r.r
   r.r = p.l
   p.l = r
   p.s = p.s + r.s + 1
   // measurement(&amp;rotations, 1)
}</span>

func (tree *TreapFingerTree) rotateParentRightOnLeftSpine(p *Node) <span class="cov0" title="0">{
   tree.copy(&amp;p.l)
   l := p.l
   p.l = l.l
   l.l = p.r
   p.r = l
   p.s = p.s + l.s + 1
   l.s = p.s - l.s - 1
   // measurement(&amp;rotations, 1)
}</span>

func (tree *TreapFingerTree) rotateRightIntoRoot(l *Node) <span class="cov0" title="0">{
   // assert(l.l == nil)

   p := tree.root

   tree.appendR(&amp;p.r, p)

   l.l = p.l
   p.l = l.r
   l.r = p.r
   p.r = nil
   l.s = p.s - l.s - 1
   p.s = p.s - l.s - 1

   tree.root = l // TODO: consider returning this, accepting p?, not tree
   // measurement(&amp;rotations, 1)
}</span>

func (tree *TreapFingerTree) rotateLeftIntoRoot(r *Node) <span class="cov0" title="0">{
   // assert(r.r == nil)

   p := tree.root

   tree.appendL(&amp;p.l, p)

   r.r = p.r
   p.r = r.l
   r.l = p.l
   p.l = nil
   r.s = r.s + p.s + 1
   p.s = r.s - p.s - 1

   tree.root = r
   // measurement(&amp;rotations, 1)
}</span>

func (tree *TreapFingerTree) rotateUpR(p *Node) *Node <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      if p.r == nil </span><span class="cov0" title="0">{
         if p.y &gt; tree.root.y </span><span class="cov0" title="0">{
            tree.rotateLeftIntoRoot(p)
            return nil
         }</span>
      } else<span class="cov0" title="0"> {
         if p.y &gt; p.r.y </span><span class="cov0" title="0">{
            tree.rotateParentLeftOnRightSpine(p)
            continue</span>
         }
      }
      <span class="cov0" title="0">return p</span>
   }
}

func (tree *TreapFingerTree) rotateUpL(p *Node) *Node <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      if p.l == nil </span><span class="cov0" title="0">{
         if p.y &gt; tree.root.y </span><span class="cov0" title="0">{
            tree.rotateRightIntoRoot(p)
            return nil
         }</span>
      } else<span class="cov0" title="0"> {
         if p.y &gt; p.l.y </span><span class="cov0" title="0">{
            tree.rotateParentRightOnLeftSpine(p)
            continue</span>
         }
      }
      <span class="cov0" title="0">return p</span>
   }
}

func (tree *TreapFingerTree) rotateDownL(p *Node) <span class="cov0" title="0">{
   for p.r != nil &amp;&amp; p.r.y &gt; p.y </span><span class="cov0" title="0">{
      tree.copy(&amp;p.r)
      r := p.r
      p.r = r.l
      r.l = p.l
      p.l = r
      r.s = p.s - r.s - 1
      p.s = p.s - r.s - 1
   }</span>
   // measurement(&amp;rotations, 1)
}

func (tree *TreapFingerTree) rotateDownR(p *Node) <span class="cov0" title="0">{
   for p.l != nil &amp;&amp; p.l.y &gt; p.y </span><span class="cov0" title="0">{
      tree.copy(&amp;p.l)
      l := p.l
      p.l = l.r
      l.r = p.r
      p.r = l
      p.s = p.s - l.s - 1
   }</span>
   // measurement(&amp;rotations, 1)
}

//   func (tree *TreapFingerTree) setRoot(p *Node) {
//     tree.root = p
//   }
func (tree *TreapFingerTree) setHead(p *Node) <span class="cov0" title="0">{
   tree.root.l = p
}</span>

//   func (tree *TreapFingerTree) setSize(s Size) {
//     tree.size = s
//   }
//
//   func (tree *TreapFingerTree) setHeadSize(s Size) {
//     tree.root.i = s
//   }
func (tree *TreapFingerTree) setTail(p *Node) <span class="cov0" title="0">{
   tree.root.r = p
}</span>
func (tree *TreapFingerTree) getHead() (p *Node) <span class="cov0" title="0">{
   return tree.root.l
}</span>
func (tree *TreapFingerTree) getTail() (p *Node) <span class="cov0" title="0">{
   return tree.root.r
}</span>

func (tree *TreapFingerTree) insertAsLast(x Data) <span class="cov0" title="0">{
   tree.copy(&amp;tree.root)
   p := tree.allocate(Node{x: x, y: tree.randomRank()})
   p.r = tree.getTail()
   p = tree.rotateUpR(p)
   tree.setTail(p)
   tree.size++
}</span>

func (tree *TreapFingerTree) insertAsFirst(x Data) <span class="cov0" title="0">{
   tree.copy(&amp;tree.root)
   p := tree.allocate(Node{x: x, y: tree.randomRank()})
   p.l = tree.getHead()
   p = tree.rotateUpL(p)
   tree.setHead(p)
   tree.root.s++
   tree.size++
}</span>

func (tree TreapFingerTree) Select(i Position) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   switch </span>{
   case i &lt; tree.root.s:<span class="cov0" title="0">
      return tree.accessFromHead(i)</span>
   case i &gt; tree.root.s:<span class="cov0" title="0">
      return tree.accessFromTail(tree.size - i - 1)</span>
   default:<span class="cov0" title="0">
      return tree.root.x</span>
   }
}

func (tree *TreapFingerTree) Update(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   switch </span>{
   case i &lt; tree.root.s:<span class="cov0" title="0">
      tree.updateFromHead(x, i)</span>
   case i &gt; tree.root.s:<span class="cov0" title="0">
      tree.updateFromTail(x, tree.size-i-1)</span>
   default:<span class="cov0" title="0">
      tree.copy(&amp;tree.root)
      tree.root.x = x</span>
   }
}

func (tree TreapFingerTree) accessFromHead(i Position) Data <span class="cov0" title="0">{
   p := tree.getHead()
   for </span><span class="cov0" title="0">{
      if i == 0 </span><span class="cov0" title="0">{
         return p.x
      }</span>
      <span class="cov0" title="0">if i &gt; p.s </span><span class="cov0" title="0">{
         i = i - p.s - 1
         p = p.l
      }</span> else<span class="cov0" title="0"> {
         return tree.lookup(p.r, i-1)
      }</span>
   }
}

func (tree *TreapFingerTree) updateFromTail(x Data, i Position) <span class="cov0" title="0">{
   tree.copy(&amp;tree.root)
   tree.copy(&amp;tree.root.r)

   p := tree.root.r
   for </span><span class="cov0" title="0">{
      if i == 0 </span><span class="cov0" title="0">{
         p.x = x
         return
      }</span>
      <span class="cov0" title="0">if i &gt; p.s </span><span class="cov0" title="0">{
         tree.copy(&amp;p.r)
         i = i - p.s - 1
         p = p.r
      }</span> else<span class="cov0" title="0"> {
         tree.copy(&amp;p.l)
         tree.update(p.l, p.s-i, x)
         return
      }</span>
   }
}

func (tree *TreapFingerTree) updateFromHead(x Data, i Position) <span class="cov0" title="0">{
   tree.copy(&amp;tree.root)
   tree.copy(&amp;tree.root.l)

   p := tree.root.l
   for </span><span class="cov0" title="0">{
      if i == 0 </span><span class="cov0" title="0">{
         p.x = x
         return
      }</span>
      <span class="cov0" title="0">if i &gt; p.s </span><span class="cov0" title="0">{
         tree.copy(&amp;p.l)
         i = i - p.s - 1
         p = p.l
      }</span> else<span class="cov0" title="0"> {
         tree.copy(&amp;p.r)
         tree.update(p.r, i-1, x)
         return
      }</span>
   }
}

func (tree TreapFingerTree) accessFromTail(i Position) Data <span class="cov0" title="0">{
   p := tree.getTail()
   for </span><span class="cov0" title="0">{
      if i == 0 </span><span class="cov0" title="0">{
         return p.x
      }</span>
      <span class="cov0" title="0">if i &gt; p.s </span><span class="cov0" title="0">{
         i = i - p.s - 1
         p = p.r
      }</span> else<span class="cov0" title="0"> {
         return tree.lookup(p.l, p.s-i)
      }</span>
   }
}

func (tree *TreapFingerTree) insert(p **Node, i Position, n *Node) <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      if *p == nil </span><span class="cov0" title="0">{
         *p = n
         return
      }</span>
      <span class="cov0" title="0">if (*p).y &lt;= n.y </span><span class="cov0" title="0">{
         n.l, n.r = tree.Tree.split(*p, i)
         n.s = i
         *p = n
         return
      }</span>
      <span class="cov0" title="0">tree.copy(p)
      if i &lt;= (*p).s </span><span class="cov0" title="0">{
         p = insertL(*p)
      }</span> else<span class="cov0" title="0"> {
         p = insertR(*p, &amp;i)
      }</span>
   }
}

func (tree *TreapFingerTree) insertFromHead(x Data, i Position) <span class="cov0" title="0">{
   tree.copy(&amp;tree.root)
   tree.copy(&amp;tree.root.l)
   tree.root.s++
   tree.size++

   n := tree.allocate(Node{x: x, y: tree.randomRank()})
   p := tree.root.l
   for </span><span class="cov0" title="0">{
      //
      if i &gt; p.s </span><span class="cov0" title="0">{
         tree.copy(&amp;p.l)
         i = i - p.s - 1
         p = p.l
         continue</span>
      }
      //
      <span class="cov0" title="0">if rank(n) &gt; rank(p) </span><span class="cov0" title="0">{
         p.r, n.r = tree.Tree.split(p.r, i)
         n.s = p.s - i
         p.s = i
         n.l = p.l
         p.l = tree.rotateUpL(n)
         return
      }</span>
      //
      <span class="cov0" title="0">p.s++
      tree.insert(&amp;p.r, i, n)
      return</span>
   }
}

func (tree TreapFingerTree) split(i Position) (Tree, Tree) <span class="cov0" title="0">{
   // assert(i &lt;= tree.size)
   tree.share(tree.root)
   if i == 0 </span><span class="cov0" title="0">{
      return Tree{arena: tree.arena},
         Tree{arena: tree.arena, root: tree.root, size: tree.size}
   }</span>
   <span class="cov0" title="0">if i == tree.size </span><span class="cov0" title="0">{
      return Tree{arena: tree.arena, root: tree.root, size: tree.size},
         Tree{arena: tree.arena}
   }</span>
   <span class="cov0" title="0">if i &lt;= tree.root.s </span><span class="cov0" title="0">{
      return tree.splitFromHead(i)
   }</span> else<span class="cov0" title="0"> {
      return tree.splitFromTail(i)
   }</span>
}

func (tree TreapFingerTree) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.size)
   l, r := tree.split(i)
   return &amp;TreapFingerTree{Tree: l, Source: tree.Source},
      &amp;TreapFingerTree{Tree: r, Source: tree.Source}
}</span>

func (tree TreapFingerTree) splitFromHead(i Position) (Tree, Tree) <span class="cov0" title="0">{
   // assert(i &lt;= tree.size)
   // assert(i &lt;= tree.root.s)
   /////

   // TODO: I think there is a bug here when i == n

   //////
   tree.copy(&amp;tree.root)

   p := tree.root
   d := i
   for d &gt; (p.l.s + 1) </span><span class="cov0" title="0">{
      d = d - (p.l.s + 1)
      tree.copy(&amp;p.l)
      p = p.l
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p.l)
   g := p.l
   p.l = nil
   p = g
   g = p.l

   sl := d - 1
   sr := p.s - sl

   l, r := tree.Tree.split(p.r, sl)

   L := Tree{arena: tree.arena, root: p, size: i}
   R := Tree{arena: tree.arena, root: tree.root, size: tree.size - i}

   L.root.s = i - d
   L.root.l = tree.root.l
   L.root.r = tree.reverseR(l, nil)

   R.root.s = tree.root.s - i
   R.root.r = tree.root.r
   R.root.l = tree.reverseL(r, g, sr)

   return L, R</span>
}

func (tree TreapFingerTree) splitFromTail(i Position) (Tree, Tree) <span class="cov0" title="0">{
   // assert(i &lt; tree.size)
   // assert(i &gt; tree.root.s)

   tree.copy(&amp;tree.root)

   p := tree.root
   d := tree.size - i

   for d &gt; (p.r.s + 1) </span><span class="cov0" title="0">{
      d = d - (p.r.s + 1)
      tree.copy(&amp;p.r)
      p = p.r
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p.r)
   g := p.r
   p.r = nil
   p = g
   g = p.r

   sr := d - 1
   sl := p.s - sr

   l, r := tree.Tree.split(p.l, sl)

   L := Tree{arena: tree.arena}
   R := Tree{arena: tree.arena}

   R.root = p
   R.size = tree.size - i
   R.root.s = sr
   R.root.l = tree.reverseL(r, nil, sr)
   R.root.r = tree.root.r

   L.root = tree.root
   L.size = i
   L.root.l = tree.getHead()
   L.root.r = tree.reverseR(l, g)

   return L, R</span>
}

//
//
//

func (tree *TreapFingerTree) insertFromTail(x Data, i Position) <span class="cov0" title="0">{
   tree.copy(&amp;tree.root)
   tree.copy(&amp;tree.root.r)

   tree.size++

   n := tree.allocate(Node{x: x, y: tree.randomRank()})
   p := tree.root.r
   for </span><span class="cov0" title="0">{
      //
      if i &gt; p.s </span><span class="cov0" title="0">{
         tree.copy(&amp;p.r)
         i = i - p.s - 1
         p = p.r
         continue</span>
      }
      //
      <span class="cov0" title="0">if rank(n) &gt; rank(p) </span><span class="cov0" title="0">{

         n.l, p.l = tree.Tree.split(p.l, p.s-i)
         n.s = p.s - i
         p.s = i
         n.r = p.r
         p.r = tree.rotateUpR(n)
         return
      }</span>
      //
      <span class="cov0" title="0">p.s++
      tree.insert(&amp;p.l, p.s-i-1, n)
      return</span>
   }
}

// create new node with random rank
// if this rank is less than the root's rank, we need a new root node and the
//
//   old root node will
func (tree *TreapFingerTree) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   if tree.root == nil </span><span class="cov0" title="0">{
      tree.root = tree.allocate(Node{x: x, y: tree.randomRank()})
      tree.size = 1
      return
   }</span>
   <span class="cov0" title="0">if i &lt;= tree.root.s </span><span class="cov0" title="0">{
      if i == 0 </span><span class="cov0" title="0">{
         tree.insertAsFirst(x)
      }</span> else<span class="cov0" title="0"> {
         tree.insertFromHead(x, i-1)
      }</span>
   } else<span class="cov0" title="0"> {
      if i == tree.size </span><span class="cov0" title="0">{
         tree.insertAsLast(x)
      }</span> else<span class="cov0" title="0"> {
         tree.insertFromTail(x, tree.size-i-1)
      }</span>
   }
}

////
//func (t *TreapFingerTreeOld) removeFromHead(i int) (s Data) {
//  invariant(i &gt;= 0)
//
//  //
//  //
//  if i == 0 {
//     return t.Shift()
//  }
//
//  //
//  t.size = t.size - 1
//  t.root = t.root.copy().withRelativePosition(t.root.w - 1)
//  t.head = t.head.copy()
//
//  //
//  p := t.head
//  d := i
//
//  //
//  //
//  for {
//     //visualize("↗")
//     invariant(d &gt; 0)
//     invariant(p.isL())
//
//     //
//     //
//     if d + p.w &lt; 0 {
//        //visualize("|↘")
//        p.decreaseInternalWeightOfL()
//        return (&amp;Treap{}).remove(&amp;p.r, d, p.sizeLR()+1).s
//     }
//
//     //
//     //
//     if d + p.w == 0 {
//        dissolveOnLeftSpine(p, &amp;s)
//        return
//     }
//
//     //
//     //
//     d = d + p.w
//     p = shadow(&amp;p.l)
//  }
//}
//
////
////
//func (t *TreapFingerTreeOld) removeFromTail(i int) (s Data) {
//  invariant(i &gt;= 0)
//
//  //
//  if i == t.size - 1 {
//     return t.Pop()
//  }
//
//  //
//  t.size = t.size - 1
//  t.tail = t.tail.copy()
//
//  //
//  p := t.tail
//  d := i - t.size
//
//  //
//  //
//  for {
//     //visualize("↖")
//     invariant(d &lt; 0)
//     invariant(p.isR())
//
//     //
//     //
//     if d + p.w &gt; 0 {
//        //visualize("|↙")
//        p.decreaseInternalWeightOfR()
//        return (&amp;Treap{}).remove(&amp;p.l, d, p.sizeRL()+1).s
//     }
//
//     //
//     //
//     if d + p.w == 0 {
//        dissolveOnRightSpine(p, &amp;s)
//        return
//     }
//
//     //
//     //
//     d = d + p.w
//     p = shadow(&amp;p.r)
//  }
//}
//
////
////
//func dissolveOnLeftSpine(l *Node, s *Data) {
//  //visualize("!")
//
//  p  := copyOf(l.l)
//  g  := p.l
//  p.l = l
//  l.l = nil
//  *s  = p.s
//  *l  = *reverseL((&amp;Treap{}).dissolveWithoutSize(p), g)
//}
//
////
////
//func dissolveOnRightSpine(r *Node, s *Data) {
//  //visualize("!")
//  invariant(r.isR())
//
//  p  := r.r.copy()
//  g  := p.r
//  p.r = r
//  r.r = nil
//  *s  = p.s
//  *r  = *reverseR((&amp;Treap{}).dissolveWithoutSize(p), g)
//}
//

func (tree *TreapFingerTree) deleteFirst(x *Data) <span class="cov0" title="0">{
   //println("deleteFirst")
   defer tree.release(tree.root.l)
   *x = tree.root.l.x
   tree.copy(&amp;tree.root)
   tree.copy(&amp;tree.root.l)
   tree.root.l = tree.reverseL(tree.root.l.r, tree.root.l.l, tree.root.l.s)
   tree.root.s--
}</span>

func (tree *TreapFingerTree) deleteLast(x *Data) <span class="cov0" title="0">{
   //println("deleteLast")
   defer tree.release(tree.root.r)
   *x = tree.root.r.x
   tree.copy(&amp;tree.root)
   tree.copy(&amp;tree.root.r)
   tree.root.r = tree.reverseR(tree.root.r.l, tree.root.r.r)
}</span>
func (tree TreapFingerTree) delete(p **Node, i Position, x *Data) <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      if i == (*p).s </span><span class="cov0" title="0">{
         *x = (*p).x
         if (*p).l == nil &amp;&amp; (*p).r == nil </span><span class="cov0" title="0">{
            *p = nil
         }</span> else<span class="cov0" title="0"> {
            tree.copy(p) // TODO: should we instead share the left and right here?
            //defer tree.release(*p)
            *p = tree.join((*p).l, (*p).r, (*p).s)
         }</span>
         <span class="cov0" title="0">return</span>
      }
      <span class="cov0" title="0">tree.copy(p)
      if i &lt; (*p).s </span><span class="cov0" title="0">{
         p = deleteL(*p)
      }</span> else<span class="cov0" title="0"> {
         p = deleteR(*p, &amp;i)
      }</span>
   }
}
func (tree *TreapFingerTree) deleteFromHead(i Position, x *Data) <span class="cov0" title="0">{
   //println("deleteFromHead")
   if i == 0 </span><span class="cov0" title="0">{
      tree.deleteFirst(x)
      return
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;tree.root)
   tree.copy(&amp;tree.root.l)
   tree.root.s--
   p := tree.root.l
   for i &gt; p.s+1 </span><span class="cov0" title="0">{
      tree.copy(&amp;p.l)
      i = i - p.s - 1
      p = p.l
   }</span>
   <span class="cov0" title="0">if i &lt; p.s+1 </span><span class="cov0" title="0">{
      tree.delete(&amp;p.r, i-1, x)
      p.s--
      return
   }</span>
   <span class="cov0" title="0">tree.copy(&amp;p.l)
   g := p.l
   defer tree.release(g)
   *x = g.x
   p.r = tree.join(p.r, g.r, p.s)
   p.l = g.l
   p.s = p.s + g.s
   tree.rotateDownL(p)</span>
}

func (tree *TreapFingerTree) join(l, r *Node, sl Size) (root *Node) <span class="cov0" title="0">{
   // assert(sl == l.size())
   p := &amp;root
   for </span><span class="cov0" title="0">{
      if l == nil </span><span class="cov0" title="0">{
         *p = r
         return
      }</span>
      <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
         *p = l
         return
      }</span>
      <span class="cov0" title="0">if l.y &gt;= r.y </span><span class="cov0" title="0">{
         tree.copy(&amp;l)
         sl = sl - l.s - 1
         *p = l
         p = &amp;l.r
         l = *p
      }</span> else<span class="cov0" title="0"> {
         tree.copy(&amp;r)
         r.s = r.s + sl
         *p = r
         p = &amp;r.l
         r = *p
      }</span>
   }
}

func (tree *TreapFingerTree) deleteFromTail(i Position, x *Data) <span class="cov0" title="0">{
   //println("deleteFromTail")
   if i == tree.size-1 </span><span class="cov0" title="0">{
      tree.deleteLast(x)
      return
   }</span>
   <span class="cov0" title="0">i = tree.size - i - 1
   tree.copy(&amp;tree.root)
   tree.copy(&amp;tree.root.r)
   p := tree.root.r
   for i &gt; p.s+1 </span><span class="cov0" title="0">{
      tree.copy(&amp;p.r) // TODO I think this could be nulll?
      i = i - p.s - 1
      p = p.r
   }</span>
   //println("found inflection", p.s)
   <span class="cov0" title="0">if i &lt; p.s+1 </span><span class="cov0" title="0">{
      //println("descend")
      tree.delete(&amp;p.l, p.s-i, x)
      p.s--
      return
   }</span>
   //println("delete on the right spine")
   <span class="cov0" title="0">tree.copy(&amp;p.r)
   g := p.r
   defer tree.release(g)
   *x = g.x
   p.l = tree.join(g.l, p.l, g.s)
   p.r = g.r
   p.s = p.s + g.s
   tree.rotateDownR(p)</span>
}

//func (tree TreapFingerTree) toTreap() (treap TreapTopDown) {
//   treap = tree.TreapTopDown
//   if treap.root == nil {
//      return
//   }
//   tree.root.l = tree.reverseL(shared(tree.root.l), nil, tree.root.i)
//   tree.root.r = tree.reverseR(shared(tree.root.r), nil)
//   return
//}

func (tree *TreapFingerTree) reverseL2(p *Node, g *Node) *Node <span class="cov0" title="0">{
   s := Size(0)
   for </span><span class="cov0" title="0">{
      if p == nil </span><span class="cov0" title="0">{
         return g
      }</span>
      <span class="cov0" title="0">tree.copy(&amp;p)
      s = s + p.s + 1
      p.s = s - p.s - 1
      l := p.l
      p.l = g
      g = p
      p = l</span>
   }
}
func (tree *TreapFingerTree) deleteRoot(v *Data) <span class="cov0" title="0">{
   //println("deleteRoot")
   tree.copy(&amp;tree.root)
   *v = tree.root.x

   // To treap
   tree.root.l = tree.reverseL2(tree.root.l, nil)
   tree.root.r = tree.reverseR(tree.root.r, nil)

   // Dissolve root
   tree.root = tree.join(tree.root.l, tree.root.r, tree.root.s)

   if tree.root == nil </span><span class="cov0" title="0">{
      return
   }</span>
   // To finger tree
   //tree.pathcopy(&amp;tree.root)
   <span class="cov0" title="0">tree.root.l = tree.reverseL(tree.root.l, nil, tree.root.s)
   tree.root.r = tree.reverseR(tree.root.r, nil)</span>
}

func (tree *TreapFingerTree) Delete(i Position) (v Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.size)
   switch </span>{
   case i &lt; tree.root.s:<span class="cov0" title="0">
      tree.deleteFromHead(i, &amp;v)
      tree.size--</span>
   case i &gt; tree.root.s:<span class="cov0" title="0">
      tree.deleteFromTail(i, &amp;v)
      tree.size--</span>
   default:<span class="cov0" title="0">
      tree.deleteRoot(&amp;v)
      tree.size--</span>
   }
   <span class="cov0" title="0">return</span>
}

//func (t *TreapFingerTreeOld) Remove(i int) (s Data){
//  switch {
//  case i &lt; t.root.sizeRL(): return t.removeFromHead(i)
//  case i &gt; t.root.sizeRL(): return t.removeFromTail(i)
//  default:
//     return t.removeRoot()
//  }
//}
//
//
//func (tree *FingerTreeDisjointUniform) Delete(i Position) (s Data) {
//   if i &lt; tree.head.size {
//      if i == 0 {
//         tree.shift(&amp;s)
//         return s
//      }
//      tree.deleteFromHead(i, &amp;s)
//      tree.distribute()
//      return s
//   } else {
//      if i == tree.head.size + tree.tail.size - 1 {
//         tree.pop(&amp;s)
//         return s
//      }
//      tree.deleteFromTail(tree.head.size + tree.tail.size - i - 1, &amp;s)
//      tree.distribute()
//      return s
//   }
//}
//
//func (tree *FingerTreeDisjointUniform) deleteFromHead(i Position, s *Data) {
//
//   tree.head.root = pathcopy(tree.head.root)
//   tree.head.size--
//   p := tree.head.root
//   for i &gt; p.s + 1 {
//      p.l = p.l.Copy()
//      i = i - p.s - 1
//      p = p.l
//   }
//   if i &lt; p.s + 1 {
//      Treap{}.delete(&amp;p.r, i - 1, s)
//      p.s--
//      return
//   }
//   p.l = p.l.Copy()
//   g := p.l
//   *s = g.s
//   p.r = Treap{}.join(p.r, g.r, p.s)
//   p.l = g.l
//   p.s = p.s + g.s
//   tree.rotateDownL(p)
//}
//func (tree *FingerTreeDisjointUniform) deleteFromTail(i Position, s *Data) {
//
//   tree.tail.root = pathcopy(tree.tail.root)
//   tree.tail.size--
//   p := tree.tail.root
//   for {
//      if i == p.s + 1 {
//         p.r = p.r.Copy()
//         g := p.r
//         *s = g.s
//         p.l = Treap{}.join(g.l, p.l, g.s)
//         p.r = g.r
//         p.s = p.s + g.s
//         tree.rotateDownR(p)
//         return
//      }
//      if i &lt; p.s + 1 {
//         Treap{}.delete(&amp;p.l, p.s - i, s)
//         p.s--
//         return
//      }
//      i = i - p.s - 1
//      p.r = p.r.Copy()
//      p = p.r
//   }
//}
//func (tree *FingerTreeDisjointUniform) pop(s *Data) {
//
//   *s = tree.tail.root.s
//
//   tree.tail.root = tree.tail.root.copy()
//   tree.tail.root = tree.reverseR(tree.tail.root.l, tree.tail.root.r)
//   tree.tail.size = tree.tail.size - 1
//   tree.distribute()
//}
//
//
//func (tree *FingerTreeDisjointUniform) shift(s *Data) {
//
//   *s = tree.head.root.s
//
//   tree.head.root = tree.head.root.copy()
//   tree.head.root = tree.reverseL(tree.head.root.r, tree.head.root.l, tree.head.root.s)
//   tree.head.size = tree.head.size - 1
//   tree.distribute()
//}

func (tree *TreapFingerTree) joinUp(o *TreapFingerTree) *Node <span class="cov0" title="0">{
   tree.copy(&amp;tree.root)
   tree.copy(&amp;o.root)

   l := tree.root.r
   r := o.root.l
   s := Size(0) // size of p

   var p *Node
   for </span><span class="cov0" title="0">{
      if r == nil </span><span class="cov0" title="0">{
         tree.root.r = o.root.r
         o.root.l = p
         o.root.r = l
         o.root.s = s

         tree.appendR(&amp;tree.root.r, tree.rotateUpR(o.root))
         return tree.root
      }</span>
      <span class="cov0" title="0">if l == nil </span><span class="cov0" title="0">{
         o.root.l = tree.root.l
         o.root.s = tree.size + o.root.s
         tree.root.l = r
         tree.root.r = p
         tree.root.s = s

         tree.appendL(&amp;o.root.l, tree.rotateUpL(tree.root))
         return o.root
      }</span>
      <span class="cov0" title="0">if l.y &lt; r.y </span><span class="cov0" title="0">{ // TODO: how does &lt;= affect things? Should we prefer larger size?
         tree.copy(&amp;l)
         s = s + l.s + 1
         g := l.r
         l.r = p
         p = l
         l = g
      }</span> else<span class="cov0" title="0"> {
         tree.copy(&amp;r)
         s = s + r.s + 1
         r.s = s - r.s - 1
         g := r.l
         r.l = p
         p = r
         r = g
      }</span>
   }
}

func (tree *TreapFingerTree) Join(that List) List <span class="cov0" title="0">{
   if tree.Size() == 0 </span><span class="cov0" title="0">{
      return that.Clone()
   }</span> // TODO: can we avoid this?
   <span class="cov0" title="0">if that.Size() == 0 </span><span class="cov0" title="0">{
      return tree.Clone()
   }</span> // TODO: can we avoid this?

   <span class="cov0" title="0">l := tree.Clone().(*TreapFingerTree) // TODO: can we avoid this?
   r := that.Clone().(*TreapFingerTree) // TODO: can we avoid this?

   return &amp;TreapFingerTree{
      Tree: Tree{
         arena: tree.arena,
         root:  l.joinUp(r),
         size:  l.size + r.size,
      },
      Source: tree.Source,
   }</span>
}

func (tree TreapFingerTree) eachFromHead(p *Node, visit func(Data)) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">visit(p.x)
   p.r.inorder(visit)
   tree.eachFromHead(p.l, visit)</span>
}

func (tree TreapFingerTree) eachFromTail(p *Node, visit func(Data)) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">tree.eachFromTail(p.r, visit)
   p.l.inorder(visit)
   visit(p.x)</span>
}

// func (tree FingerTreap) head() *Node {
//    return tree.root.l
// }
//
// func (tree FingerTreap) tail() *Node {
//    return tree.root.r
// }

func (tree TreapFingerTree) inorder(p *Node, visit func(Data)) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">tree.eachFromHead(p.l, visit)
   visit(p.x)
   tree.eachFromTail(p.r, visit)</span>
}

func (tree TreapFingerTree) Each(visit func(Data)) <span class="cov0" title="0">{
   tree.inorder(tree.root, visit)
}</span>

// func (p *Node) preorder(visit func(Data)) {
//    if p == nil {
//       return
//    }
//    visit(p.s)
//    p.l.preorder(visit)
//    p.r.preorder(visit)
// }
//
// func (p *Node) postorder(visit func(Data)) {
//    if p == nil {
//       return
//    }
//    p.l.postorder(visit)
//    p.r.postorder(visit)
//    visit(p.s)
// }

func (tree TreapFingerTree) verifyRanks() <span class="cov0" title="0">{
   if tree.root == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">l := tree.root.l
   r := tree.root.r
   for ; l != nil; l = l.l </span><span class="cov0" title="0">{
      TreapTopDown{}.verifyMaxRankHeap(l.r)
      invariant(rank(l) &gt;= rank(l.r))
      invariant(rank(l) &lt;= rank(l.l) || l.l == nil)
   }</span>
   <span class="cov0" title="0">for ; r != nil; r = r.r </span><span class="cov0" title="0">{
      TreapTopDown{}.verifyMaxRankHeap(r.l)
      invariant(rank(r) &gt;= rank(r.l))
      invariant(rank(r) &lt;= rank(r.r) || r.r == nil)
   }</span>
   <span class="cov0" title="0">invariant(rank(tree.root) &gt;= rank(l))
   invariant(rank(tree.root) &gt;= rank(r))</span>
}

func (tree TreapFingerTree) verifyPositions() <span class="cov0" title="0">{
   if tree.root == nil </span><span class="cov0" title="0">{
      return
   }</span>
   // The root's size must be equal to the size of the left subtree.
   <span class="cov0" title="0">invariant(tree.root.s == tree.getHead().size())

   // Verify internal positions along the spines.
   for l := tree.getHead(); l != nil; l = l.l </span><span class="cov0" title="0">{
      tree.verifySize(l.r, l.s)
   }</span>
   <span class="cov0" title="0">for r := tree.getTail(); r != nil; r = r.r </span><span class="cov0" title="0">{
      tree.verifySize(r.l, r.s)
   }</span>
}

func (tree TreapFingerTree) Verify() <span class="cov0" title="0">{
   invariant(tree.size == tree.root.size())
   tree.verifyPositions()
   tree.verifyRanks()
}</span>

//package structures
//
//import (
//  . "trees/pkg/abstract/list"
//  "trees/pkg/utility"
//  "golang.org/x/exp/rand"
//)
//
//
//
//// An implementation of a persistent list using a finger search tree (TreapFingerTreeOld).
////
//// The first node of the sequence is the head, the last node is the tail. The
//// head is therefore the leftmost node in the tree and the tail the rightmost.
////
//// Starting at the head, nodes along the left spine of the tree have their left
//// pointers reversed to point to their parent instead. Symmetrically along the
//// right spine starting from the tail, nodes have their right pointers reversed
//// to point to their parent. This provides access to internal nodes of the tree
//// by ascending along the spine from the head or tail and then descend inwards.
////
//// The root has no children. Datas access to nodes other than the root must start
//// from the head or the tail. There is no need to ascend both spines because the
//// position to search for can be compared to the relative position of the root
//// which is an absolute position in the sequence.
////
////
////                               ROOT
////                                   ↘ +4
////                                    (m)
////                            -2               +2
////                            (s)             (l)
////                        -1 ↗   ↘ +1     -1 ↙   ↖ +1
////                        (e)     (a)     (p)     (e)
////                       ↗                           ↖
////                   HEAD                             TAIL
////
////
//// Another way to visualize this structure is to use a horizontal spine layout.
//// Notice that the relative position of every node along the spine indicates how
//// many nodes will be skipped if a search continues along in the same direction:
////
////
////   HEAD                              ROOT                              TAIL
////
////   -1  -2    -4            -8        +16        +8            +4    +2  +1
////    ○ → ○  →  ○ --------- → ○         ◎         ○ ← --------- ○  ←  ○ ← ○
////        ↓     ↓             ↓                   ↓             ↓     ↓
////        ○     ○             ○                   ○             ○     ○
////            ↙   ↘        ↙     ↘             ↙     ↘        ↙   ↘
////           ○     ○     ○         ○         ○         ○     ○     ○
////                     ↙   ↘     ↙   ↘     ↙   ↘     ↙   ↘
////                    ○     ○   ○     ○   ○     ○   ○     ○
////
////
////
//// Operations:
////
////    From        O(n)        Creates a new instance from existing Datas.
////    Get         O(lg n)     Returns a Data at position.
////    Set         O(lg n)     Updates a Data at position.
////    Insert      O(lg n)     Inserts a Data at position, increasing length.
////    Remove      O(lg n)     Removes a Data at position, reducing length.
////    Split       O(lg n)     Partition by position, in-place on the left.
////    Join        O(lg n)     Concatenate by appending another TreapFingerTreeOld at the end.
////    Push        O(1)        Adds a Data after the last Data.
////    Unshift     O(1)        Adds a Data before the first Data.
////    Pop         O(1)        Removes the last Data.
////    Shift       O(1)        Removes the first Data.
////
////
////
//// Reading list:
////
////  - Implement an immutable deque as a balanced binary tree? (2010)
////    https://stackoverflow.com/q/3271256
////
////  - Functional Set Operations with Treaps (2001)
////    Dan Blandford, Guy Blelloch
////    https://www.cs.cmu.edu/afs/cs/project/pscico/pscico/papers/fingertrees/
////    https://www.cs.cmu.edu/afs/cs/project/pscico/pscico/src/fingertrees/
////
////  - An O(n log log n)-Time Algorithm for Triangulating a Simple Polygon (1986)
////    Appendix: Finger search trees
////    R. E. Tarjan, C. J. Van Wyk
////    https://api.semanticscholar.org/CorpusID:4981331
////  - Finger trees: a simple general-purpose data structure (2006)
////    R. Hinze, R. Paterson
////    https://api.semanticscholar.org/CorpusID:6881581
////
////  - Finger Search Trees (2005)
////    G. Brodal
////    https://api.semanticscholar.org/CorpusID:5694716
////
////
////
//// Symbols:
////
////       t   tree
////       o   other tree
////       i   index, offset, 0-based
////       d   relative position, distance
////       s   data
////
////
//type TreapFingerTreeOld struct {
//  Tree
//  root *Node // s ?
//  head *Node // l
//  tail *Node // r
//  size int   // w
//  // z another int available here
//}
//
//func (t *TreapFingerTreeOld) New() List {
//  return &amp;TreapFingerTreeOld{}
//}
//
//// Creates a new instance of TreapFingerTreeOld by building a Treap then converting it to an TreapFingerTreeOld.
////
//// TODO: Build recursively from the head and tail towards the root.
//// TODO: Explore building by push without copy, aka transience.
////
//func (t *TreapFingerTreeOld) From(arr []Data) List {
//  return Treap{}.From(arr).(*Treap).ToFST()
//}
//
//// Returns the size of the tree, the length of its sequence.
//func (t *TreapFingerTreeOld) Len() int {
//  return t.size
//}
//
//// Creates a shallow copy of an TreapFingerTreeOld.
//// TODO just use structs where it makes sense to.
//func (t TreapFingerTreeOld) Clone() List {
//  /// TODO extract this to a node method
//  if t.root != nil {
//     t.root.rc++
//  }
//  ///////
//  if t.head != nil {
//     t.head.rc++
//  }
//  if t.tail != nil {
//     t.tail.rc++
//  }
//  return &amp;t
//}
//
//// Returns the Data at i.
//func (t *TreapFingerTreeOld) Get(i int) Data {
//  // assert(i &lt; t.size)
//  return t.seekTo(i).s
//}
//
//// Replaces the Data at i, returns t.
//func (t *TreapFingerTreeOld) Set(i int, s Data) {
//  // assert(i &lt; t.size) // TODO move these assertions to the list impl?
//  t.shadowTo(i).withData(s)
//}
//
////
//func (t *TreapFingerTreeOld) seekTo(i int) *Node {
//  switch {
//     case i &lt; t.root.sizeRL(): return t.seekFromHead(i)
//     case i &gt; t.root.sizeRL(): return t.seekFromTail(i)
//  default:
//     return t.root
//  }
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) shadowTo(i int) *Node {
//  switch {
//     case i &lt; t.root.sizeRL(): return t.shadowFromHead(i)
//     case i &gt; t.root.sizeRL(): return t.shadowFromTail(i)
//  default:
//     return shadow(&amp;t.root)
//  }
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) seekFromHead(i int) *Node {
//  return t.seekL(t.head, i)
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) seekFromTail(i int) *Node {
//  return t.seekR(t.tail, i - t.size + 1)
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) shadowFromHead(i int) *Node {
//  return t.seekShadowL(shadow(&amp;t.head), i)
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) shadowFromTail(i int) *Node {
//  return t.seekShadowR(shadow(&amp;t.tail), i - t.size + 1)
//}
//
////
////
////
////
////
////
////
////
////
// func (t *TreapFingerTreeOld) seekL(p *Node, i int) *Node {
//  for {
//     invariant(i &gt;= 0)
//     invariant(p.isL())
//     //
//     if i == 0 {
//        return p
//     }
//     //
//     if i + p.w &lt; 0 { // d - (sizeLR(p) + 1) &lt; 0
//        return seekTo(i, p.r)
//     }
//     //
//     i = i + p.w
//     p = p.l
//  }
// }
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) seekR(p *Node, d int) *Node {
//  for {
//     invariant(d &lt;= 0)
//     invariant(p.isR())
//
//     //
//     if d == 0 {
//        return p
//     }
//     //
//     if d + p.w &gt; 0 { // d - (sizeRL(p) + 1) &lt; 0
//        return seekTo(d, p.l)
//     }
//     //
//     d = d + p.w
//     p = p.r
//  }
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) seekShadowL(p *Node, d int) *Node {
//  for {
//     invariant(d &gt;= 0)
//     invariant(p.isL())
//     //
//     if d == 0 {
//        return p
//     }
//     invariant(d &gt; 0)
//     //
//     if d + p.w &lt; 0 { // d - (sizeLR(p) + 1) &lt; 0
//        return shadowTo(d, &amp;p.r)
//     }
//     //
//     d = d + p.w
//     p = shadow(&amp;p.l)
//  }
//}
//
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) seekShadowR(p *Node, d int) *Node {
//  for {
//     invariant(d &lt;= 0)
//     invariant(p.isR())
//
//     //
//     if d == 0 {
//        return p
//     }
//     //
//     if d + p.w &gt; 0 { // d - (sizeRL(p) + 1) &lt; 0
//        return shadowTo(d, &amp;p.l)
//     }
//     //
//     d = d + p.w
//     p = shadow(&amp;p.r)
//  }
//}
//
//func generateRandomRank() Rank {
//  return random.Uint64()
//  //var level Rank
//  //for random.Uint64() &amp; 1 == 0 {
//  //   level++
//  //}
//  ////fmt.Println(level)
//  //return level
//}
//
//// Creates a new node containing a given data Data with a fixed random rank.
//func (TreapFingerTreeOld) createNodeWithData(s Data) *Node {
//  return &amp;Node{
//     s: s,
//     z: generateRandomRank(),
//  }
//}
//func (Treap) createNodeWithData(s Data) *Node {
//  return &amp;Node{
//     s: s,
//     z: generateRandomRank(),
//  }
//}
//
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) Push(s Data) {
//  if t.isEmpty() {
//     t.root = t.createNodeWithData(s).withRelativePosition(+1)
//  } else {
//     t.tail = t.rotateUpR(t.createNodeWithData(s).withRelativePosition(+1).withR(t.tail))
//  }
//  t.size++
//}
//
//
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) Unshift(s Data) {
//  if t.isEmpty() {
//     t.root = t.createNodeWithData(s).withRelativePosition(+1)
//  } else {
//     //
//     t.root = copyOf(t.root); t.root.increaseInternalWeightOfR()
//     t.head = t.rotateUpL(t.createNodeWithData(s).withRelativePosition(-1).withL(t.head))
//  }
//  t.size++
//}
//
////
////
////
////
////
////
////
////
////

//
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) Shift() (s Data) {
//  // assert(!t.isEmpty())
//  if t.head != nil {
//     s = t.head.s
//     t.dissolveHead()
//  } else {
//     s = t.root.s
//     t.removeRoot()
//  }
//  return s
//}
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) rotateUpR(p *Node) *Node {
//  invariant(p.isR())
//  //
//  //
//  for p.hasR() {
//     if rankOf(p) &lt;= rankOf(p.r) {
//        return p
//     }
//     t.rotateLeftOnRightSpine(p)
//  }
//  //
//  //
//  if rankOf(p) &lt;= rankOf(t.root) {
//     return p
//  }
//  t.rotateLeftIntoRoot(p)
//  return nil
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) rotateUpL(p *Node) *Node {
//  invariant(p.isL())
//  //
//  //
//  for p.hasL() {
//     if rankOf(p) &lt;= rankOf(p.l) {
//        return p
//     }
//     t.rotateRightOnLeftSpine(p)
//  }
//  //
//  //
//  if rankOf(p) &lt;= rankOf(t.root) {
//     return p
//  }
//  t.rotateRightIntoRoot(p)
//  return nil
//}
//
//
//
//
//
////
////
////
////
////
////
////
////
////
//
//func (t *TreapFingerTreeOld) rotateRightIntoRoot(p *Node) {
//  //visualize("↻")
//  invariant(p.isL())
//  invariant(!p.hasL())
//  invariant(!t.isEmpty())
//  //
//  //
//  g := copyOf(t.root)
//  r := p.r
//  //
//  //
//  appendR(&amp;t.tail, g)
//
//  g.l = r; t.root = p; p.r = nil
//  rotateRelativePositions(g, p, r)
//}
//
////
////
////
////
////
////
////
////
////
//
//func (t *TreapFingerTreeOld) rotateLeftIntoRoot(p *Node) {
//  //visualize("↺")
//  invariant(p.isR())
//  invariant(!p.hasR())
//  invariant(!t.isEmpty())
//  // invariant rank of p is greater than root
//  g := copyOf(t.root)
//  l := p.l
//
//  //
//  //
//  appendL(&amp;t.head, g)
//
//  g.r = l
//  t.root = p
//  p.l = nil
//  rotateRelativePositions(g, p, l)
//}
//
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) rotateLeftOnRightSpine(p *Node)  {
//  invariant(p.isR())
//  //visualize("↺")
//  g := p.r.copy()
//  //
//  // as
//  p.r, p.l, g.r = g.r, g, p.l
//  rotateRelativePositions(g, p, g.r)
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) rotateRightOnLeftSpine(p *Node) {
//  invariant(p.isL())
//  //visualize("↻")
//  g := p.l.copy()
//  //
//  // as
//  p.l, p.r, g.l = g.l, g, p.r
//  rotateRelativePositions(g, p, g.l)
//}
//
//
//
////
////
//func (t *TreapFingerTreeOld) Insert(i int, s Data) {
//  // assert(i &lt;= t.size)
//
//  // takes care of the null root case also.
//  if i == 0 {
//     t.Unshift(s)
//     return
//  }
//  if i == t.size {
//     t.Push(s)
//     return
//  }
//  if i &lt; t.root.w {
//     t.insertFromHead(s, i)
//  } else {
//     t.insertFromTail(s, i)
//  }
//}
//
////
//func (t *TreapFingerTreeOld) insertOnRightSpine(p *Node, n *Node, d int) {
//  invariant(!n.hasL())
//  invariant(!n.hasR())
//  invariant(d &lt; 0)
//
//  n.l, p.l = unzip(p.l, d, p.sizeRL())
//
//  n.w = d + p.w + 1 // TODO revise
//  p.w = -d
//
//  //
//  if n.hasL() {
//     n.l.toL(n.sizeRL())
//  }
//  n.r = p.r
//  p.r = t.rotateUpR(n)
//}
//
////
//func (t *TreapFingerTreeOld) insertOnLeftSpine(p *Node, n *Node, d int) {
//  invariant(!n.hasL())
//  invariant(!n.hasR())
//  invariant(d &gt;= 0)
//  //
//  //
//  p.r, n.r = unzip(p.r, d, p.sizeLR())
//
//  //
//  n.w = p.w + d // TODO revise
//  p.w = -d - 1
//
//  //
//  if n.hasR() {
//     n.r.toR(n.sizeLR())
//  }
//  n.l = p.l
//  p.l = t.rotateUpL(n)
//}
//
//
////
////
//func (t *TreapFingerTreeOld) insertFromTail(s Data, i int) {
//  //visualize("↖")
//
//  t.tail = copyOf(t.tail)
//
//  n := t.createNodeWithData(s)
//  p := t.tail
//  d := i - t.size
//
//  //
//  t.size = t.size + 1
//
//  for {
//     //visualize("↖")
//     invariant(d &lt;= 0)
//     invariant(p.isR())
//
//     if d + p.w &lt; 0 {
//        d = d + p.w
//        p = shadow(&amp;p.r)
//        continue
//     }
//     if rankOf(p) &lt; rankOf(n) {
//        t.insertOnRightSpine(p, n, d)
//        return
//     }
//     //visualize("|↙")
//     (&amp;Treap{}).insert(&amp;p.l, n, d, p.sizeRL()); p.increaseInternalWeightOfR()
//     return
//  }
//}
//
//func (t *TreapFingerTreeOld) insertFromHead(s Data, i int) {
//  //visualize("↗")
//  invariant(i &gt;= 0)
//
//  //
//  t.head = copyOf(t.head)
//  t.root = copyOf(t.root)
//  t.size = t.size + 1
//
//  t.root.increaseInternalWeightOfR()
//  //
//  n := t.createNodeWithData(s)
//  p := t.head
//  d := i - 1
//
//  for {
//     //visualize("↗")
//     invariant(d &gt;= 0)
//     invariant(p.isL())
//
//     //
//     //
//     if d + p.w &gt;= 0  {
//        d = d + p.w
//        p = shadow(&amp;p.l)
//        continue
//     }
//     //
//     //
//     if rankOf(p) &lt; rankOf(n) {
//        t.insertOnLeftSpine(p, n, d)
//        return
//     }
//     //
//     //
//     //visualize("|↘")
//     (&amp;Treap{}).insert(&amp;p.r, n, d, p.sizeLR()); p.increaseInternalWeightOfL()
//     return
//  }
//}
//
//
////
//
//
////
////
//func (t *TreapFingerTreeOld) Remove(i int) (s Data){
//  switch {
//  case i &lt; t.root.sizeRL(): return t.removeFromHead(i)
//  case i &gt; t.root.sizeRL(): return t.removeFromTail(i)
//  default:
//     return t.removeRoot()
//  }
//}
//
//
//func (t *TreapFingerTreeOld) toBST() *Treap {
//  if t.isEmpty() {
//     return &amp;Treap{}
//  }
//  return &amp;Treap{
//     size: t.size,
//     root: copyOf(t.root).
//        withL(reverseL(t.head.copyOrNil(), nil)).
//        withR(reverseR(t.tail.copyOrNil(), nil)),
//  }
//}
//
//
//
////
////
//func (t *TreapFingerTreeOld) isEmpty() bool {
//  return t.root == nil
//}
//
////
////
//func inorderL(p *Node, fn func(*Node)) {
//  if p == nil {
//     return
//  }
//  fn(p)
//  inorder(p.r, fn)
//  inorderL(p.l, fn)
//}
//
////
//func inorderR(p *Node, fn func(*Node)) {
//  if p == nil {
//     return
//  }
//  inorderR(p.r, fn)
//  inorder(p.l, fn)
//  fn(p)
//}
////
//func (t *TreapFingerTreeOld) inorder(fn func(*Node)) {
//  if t.isEmpty() {
//     return
//  }
//  inorderL(t.head, fn)
//  fn(t.root)
//  inorderR(t.tail, fn)
//}
//
////
//func (t *TreapFingerTreeOld) Each(fn func(i int, s Data)) {
//  i := 0
//  t.inorder(func(n *Node) {
//     fn(i, n.s)
//     i++
//  })
//}
//
////
//func (t *TreapFingerTreeOld) Array() []Data {
//  a := make([]Data, t.size)
//  i := 0
//  t.inorder(func(n *Node) {
//     a[i] = n.s
//     i++
//  })
//  return a
//}
//
////
////
//func (t *TreapFingerTreeOld) Validate() {
//  if t.isEmpty() {
//     // assert(t.head == nil)
//     // assert(t.tail == nil)
//     // assert(t.size == 0)
//     return
//  }
//  t.verifyRelationPositionInvariant()
//  t.verifyRankHeapInvariant()
//  t.verifyRoot()
//}
//
//
//
////
////
//func (t *TreapFingerTreeOld) verifyRanksAlongLeftSpine(p *Node) {
//  for ; p != nil; p = p.l {
//     if p.hasR() {
//        // assert(rankOf(p) &gt;= rankOf(p.r))
//        p.r.verifyRankHeapInvariant()
//     }
//     if p.hasL() {
//        // assert(rankOf(p) &lt;= rankOf(p.l))
//     }
//  }
//}
//
////
////
//func (t *TreapFingerTreeOld) verifyRanksAlongRightSpine(p *Node) {
//  for ; p != nil; p = p.r {
//     if p.hasL() {
//        // assert(rankOf(p) &gt;= rankOf(p.l))
//        p.l.verifyRankHeapInvariant()
//     }
//     if p.hasR() {
//        // assert(rankOf(p) &lt;= rankOf(p.r))
//     }
//  }
//}
//
////
//func (t *TreapFingerTreeOld) verifyRankHeapInvariant() {
//  t.verifyRanksAlongLeftSpine(t.head)
//  t.verifyRanksAlongRightSpine(t.tail)
//
//  if t.root != nil {
//     //
//     //
//     if t.head != nil {
//        for p := t.head; p.hasL(); p = p.l {
//           // assert(rankOf(p) &lt;= rankOf(t.root))
//        }
//     }
//     //
//     //
//     if t.tail != nil {
//        for p := t.tail; p.hasR(); p = p.r {
//           // assert(rankOf(p) &lt;= rankOf(t.root))
//        }
//     }
//  }
//}
//
////
//func (t *TreapFingerTreeOld) verifyRoot() {
//  // assert(t.root.l == nil)
//  // assert(t.root.r == nil)
//  // assert(t.root.sizeRL() == t.head.size())
//}
//
////
//func (t *TreapFingerTreeOld) verifyRelationPositionInvariant() {
//  if t.root != nil {
//     // assert(t.root.isR())
//     // assert(t.head.size() == t.root.sizeRL())
//  }
//  for p := t.head; p != nil; p = p.l {
//     // assert(p.isL())
//     p.verifyRelativePositionInvariant()
//  }
//  for p := t.tail; p != nil; p = p.r {
//     // assert(p.isR())
//     p.verifyRelativePositionInvariant()
//  }
//}
//
//
//func (t *TreapFingerTreeOld) hasHead() bool {
//  return t.head != nil
//}
//
//func (t *TreapFingerTreeOld) hasTail() bool {
//  return t.tail != nil
//}
//
//func (t *TreapFingerTreeOld) hasRoot() bool {
//  return t.root != nil
//}
//
////
////
////
////
////
////
////
////
////
//func (t *TreapFingerTreeOld) dissolveHead() {
//  invariant(t.hasHead())
//
//  //
//  t.root = copyOf(t.root).withRelativePosition(t.root.sizeRL())
//  //
//  p := t.head
//  g := t.head.l
//  r := t.head.r
//  //
//  //
//  if t.head.hasR() {
//     t.head = reverseL(copyOf(r).toL(p.sizeLR()), g)
//  } else {
//     t.head = g
//  }
//  t.size--
//}
//
//
////
////
////
////
////
////
////
////
//
//
////
////
//func (t *TreapFingerTreeOld) Split(i Index) (List, List) {
//  // assert(i &lt;= t.size)
//  //
//  //
//  if i == t.size { return t, &amp;TreapFingerTreeOld{} }
//  if i == 0      { return &amp;TreapFingerTreeOld{}, t }
//
//  tmp := t.Clone().(*TreapFingerTreeOld) // get this of this all
//
//  if i &lt;= t.root.sizeRL() {
//     return tmp, tmp.splitFromHead(i)
//  } else {
//     return tmp, tmp.splitFromTail(i)
//  }
//}
//
////
////

//
//// Can we use _dissolve here?
////
//func (t *TreapFingerTreeOld) removeRoot() (s Data) {
//  invariant(t.root != nil)
//  s = t.root.s
//  //
//  if t.size == 1 {
//     t.size = 0
//     t.root = nil
//     return
//  }
//  //
//  //
//  if t.head == nil {
//     // TODO use tree construction here?
//     pr := followR(&amp;t.tail)
//     t.head = reverseL((*pr).l.copyOrNil(), nil)
//     t.root = copyOf(*pr).withL(nil).withR(nil)
//     t.size = t.size - 1
//     *pr = nil
//     return
//  }
//  //
//  //
//  if t.tail == nil {
//     pl := followL(&amp;t.head)
//     t.tail = reverseR((*pl).r.copyOrNil(), nil)
//     t.root = copyOf(*pl).withL(nil).withR(nil).toR(t.root.sizeRL())
//     t.size = t.size - 1
//     *pl = nil
//     return
//  }
//  //
//  //
//  pl := followL(&amp;t.head)
//  pr := followR(&amp;t.tail)
//  //
//  //
//  sl := t.root.sizeRL()
//  sr := t.root.sizeRR(t.size)
//  //
//
//  //
//  l := (*pl).copy().toR(sl)
//  r := (*pr).copy().toL(sr)
//
//  var p *Node
//
//  //
//  // TODO is it not possible to already have a p on hand here?
//  (&amp;Treap{}).joinRL(&amp;p, l, r, sl + sr)
//  //
//  //
//  if rankOf(l) &gt;= rankOf(r) {
//     *pr = reverseR(p.r, nil)
//     *pl = nil
//  } else {
//     *pl = reverseL(p.l, nil)
//     *pr = nil
//  }
//  //
//  //
//  t.root = p.withL(nil).withR(nil)
//  t.size = t.size - 1
//  return
//}
//
//
//// TODO: if instead we use the same, does there exist a general algorithm?
////       if so or otherwise, does it simplify anything?
////
////
////
//func (t *TreapFingerTreeOld) splitFromHead(i int) (o *TreapFingerTreeOld) {
//  //
//  //
//  //
//  g := &amp;t.head
//  d := i
//  for {
//     invariant(d &gt; 0)
//     //
//     //
//     if d - ((*g).sizeLR() + 1) &gt; 0 {
//        d -= (*g).sizeLR() + 1
//        g = &amp;(shadow(g).l)
//        continue
//     }
//     //
//     //
//     //
//     //
//     p := shadow(g)
//     l, r := unzip(p.r, d - 1, p.sizeLR())
//     *g = nil
//     //
//     //
//     o = &amp;TreapFingerTreeOld{
//        root: copyOf(t.root).withRelativePosition(t.root.w - i),
//        head: reverseL(r, p.l),
//        tail: t.tail,
//        size: t.size - i,
//     }
//     //
//     //
//     *t = TreapFingerTreeOld{
//        root: p.withRelativePosition(i - (d - 1)).withL(nil).withR(nil),
//        tail: reverseR(l, nil),
//        head: t.head,
//        size: i,
//     }
//     return
//  }
//}
//
////
////
//func (t *TreapFingerTreeOld) splitFromTail(i int) (o *TreapFingerTreeOld) {
//  //
//  //
//  g := &amp;t.tail
//  d := i - t.size
//  for {
//     invariant(d &lt; 0)
//     //
//     //
//     if d + 1 + (*g).sizeRL() &lt; 0 {
//        d += (*g).sizeRL() + 1
//        g = &amp;shadow(g).r
//        continue
//     }
//     //
//     //
//     p := shadow(g)
//     l, r := unzip(p.l, d, p.sizeRL())
//     *g = nil
//
//     o = &amp;TreapFingerTreeOld{
//        root: copyOf(p).withW(-d).withL(nil).withR(nil),
//        head: reverseL(r, nil),
//        tail: t.tail,
//        size: t.size - i,
//     }
//     //
//     //
//     *t = TreapFingerTreeOld{
//        root: t.root,
//        tail: reverseR(l, p.r),
//        head: t.head,
//        size: i,
//     }
//     return
//  }
//}
//
//
//func (t Treap) DepthAlongTheSpines() (depths [2][]int) {
//  if t.root == nil {
//     return
//  }
//  traverseL(t.root.l, func(p *Node) {
//     depths[0] = append(depths[0], 1 + p.r.depth())
//  })
//  traverseR(t.root.r, func(p *Node) {
//     depths[1] = append(depths[1], 1 + p.l.depth())
//  })
//  return
//}
//
//
////
//func (t TreapFingerTreeOld) WeightAlongTheSpinesLog2() (weights [2][]int) {
//  var l []*Node
//  var r []*Node
//
//  traverseL(t.head, func(p *Node) {
//     l = append(l, p)
//  })
//  traverseR(t.tail, func(p *Node) {
//     r = append(r, p)
//  })
//  for i := len(l) - 1; i &gt;= 0; i-- {
//     weights[0] = append(weights[0], 1 + utility.Log2(l[i].sizeLR() + 1))
//  }
//  for i := len(r) - 1; i &gt;= 0; i-- {
//     weights[1] = append(weights[1], 1 + utility.Log2(r[i].sizeRL() + 1))
//  }
//  return
//}
//
//func (t TreapFingerTreeOld) DepthAlongTheSpines() (depths [2][]int) {
//  var l []*Node
//  var r []*Node
//  traverseL(t.head, func(p *Node) {
//     l = append(l, p)
//  })
//  traverseR(t.tail, func(p *Node) {
//     r = append(r, p)
//  })
//  for i := len(l) - 1; i &gt;= 0; i-- {
//     depths[0] = append(depths[0], 1 + l[i].r.depth())
//  }
//  for i := len(r) - 1; i &gt;= 0; i-- {
//     depths[1] = append(depths[1], 1 + r[i].l.depth())
//  }
//  return
//}
</pre>
		
		<pre class="file" id="file34" style="display: none">package binarytree

import . "binarysearch/abstract/list"

import (
   "binarysearch/random"
)

type TreapJoinBased struct {
   TreapTopDown // TODO: maybe all trees should have only BST at the base, expanded
}

func (TreapJoinBased) New() List <span class="cov0" title="0">{
   return &amp;TreapJoinBased{
      TreapTopDown{
         Source: random.New(random.Uint64()),
      },
   }
}</span>

func (tree *TreapJoinBased) Clone() List <span class="cov0" title="0">{
   return &amp;TreapJoinBased{
      TreapTopDown{
         Tree:   tree.Tree.Clone(),
         Source: tree.Source,
      },
   }
}</span>

func (tree *TreapJoinBased) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.root = JoinBased{Tree: tree.Tree, Joiner: tree}.insert(tree.root, i, tree.size, tree.allocate(Node{x: x, y: tree.Source.Uint64()}))
   tree.size++
}</span>
func (tree *TreapJoinBased) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.root = JoinBased{Tree: tree.Tree, Joiner: tree}.delete(tree.root, i, tree.size, &amp;x)
   tree.size--
   return
}</span>

func (tree TreapJoinBased) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := JoinBased{Tree: tree.Tree, Joiner: &amp;tree}.splitToBST(tree.root, i, tree.size)

   return &amp;TreapJoinBased{TreapTopDown{l, tree.Source}}, // TODO consider merging Treap and Treap??
      &amp;TreapJoinBased{TreapTopDown{r, tree.Source}}
}</span>

func (tree TreapJoinBased) Join(that List) List <span class="cov0" title="0">{
   l := tree
   r := that.(*TreapJoinBased)
   tree.share(l.root)
   tree.share(r.root)
   return &amp;TreapJoinBased{
      TreapTopDown{
         Source: tree.Source,
         Tree: Tree{
            arena: tree.arena,
            root:  tree.join(l.root, r.root, l.size),
            size:  l.size + r.size,
         },
      },
   }
}</span>

func (tree TreapJoinBased) Verify() <span class="cov0" title="0">{
   tree.Tree.verifySizes()
   tree.verifyMaxRankHeap(tree.root)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package binarytree
import . "binarysearch/abstract/list"

import (
   "binarysearch/random"
)

type TreapTopDown struct {
   Tree
   random.Source
}

func (TreapTopDown) New() List <span class="cov0" title="0">{
   return &amp;TreapTopDown{
      Source: random.New(random.Uint64()),
   }
}</span>

//func (tree *TreapTopDown) randomRank() uint64 {
//   return tree.Uint64()
//}

func (tree *TreapTopDown) Clone() List <span class="cov0" title="0">{
   return &amp;TreapTopDown{
      Tree:   tree.Tree.Clone(),
      Source: tree.Source,
   }
}</span>

func (tree *TreapTopDown) join(l, r *Node, sl Size) (root *Node) <span class="cov0" title="0">{
   // assert(sl == l.size())
   p := &amp;root
   for </span><span class="cov0" title="0">{
      if l == nil </span><span class="cov0" title="0">{
         *p = r
         return
      }</span>
      <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
         *p = l
         return
      }</span>
      <span class="cov0" title="0">if l.y &gt;= r.y </span><span class="cov0" title="0">{
         tree.copy(&amp;l)
         sl = sl - l.s - 1
         *p = l
         p = &amp;l.r
         l = *p
      }</span> else<span class="cov0" title="0"> {
         tree.copy(&amp;r)
         r.s = r.s + sl
         *p = r
         p = &amp;r.l
         r = *p
      }</span>
   }
}

func (tree *TreapTopDown) join2(l, r *Node, sl, sr Size) (root *Node) <span class="cov0" title="0">{
   return tree.join(l, r, sl)
}</span>

//
//// TODO: this is identical to zip tree
//func (TreapTopDown) build(x []Data) *TreapTopDown {
//   tree := TreapTopDown{
//      Tree:   Tree{}.New(),
//      Source: random.New(random.Uint64()),
//   }
//   //
//   // Build bottom-up with a reversed right spine.
//   //
//   var p *Node
//   for _, x := range x {
//      //
//      // Node a new node with random rank.
//      //
//      p = tree.allocate(Node{
//         x: x,
//         y: tree.randomRank(),
//         r: p,
//      })
//      //
//      // Rotate up
//      //
//      for p.r != nil &amp;&amp; rank(p) &gt; rank(p.r) { // TODO: n.r nil check might be redundant because of the nil check in rank
//         g := p.r // parent on the spine
//         p.r = g.r
//         g.r = p.l
//         p.l = g
//         p.s = p.s + g.s + 1
//      }
//   }
//   //
//   // Reverse the right spine.
//   //
//   var r *Node
//   for p != nil {
//      g := p.r
//      p.r = r
//      r = p
//      p = g
//   }
//   tree.root = r
//   tree.size = Size(len(x))
//   return &amp;tree
//}

func (tree *TreapTopDown) join3(l, p, r *Node, sl, sr Size) (root *Node) <span class="cov0" title="0">{
   //tree.pathcopy(&amp;p)
   if rank(p) &gt;= rank(l) &amp;&amp; rank(p) &gt;= rank(r) </span><span class="cov0" title="0">{
      p.l = l
      p.r = r
      p.s = sl
      return p
   }</span>
   <span class="cov0" title="0">if rank(l) &gt; rank(r) </span><span class="cov0" title="0">{
      l.r = tree.join3(l.r, p, r, sl-l.s-1, sr)
      return l
   }</span> else<span class="cov0" title="0"> {
      r.l = tree.join3(l, p, r.l, sl, r.s)
      r.s = r.s + sl + 1
      return r
   }</span>
}

func (tree TreapTopDown) delete(p **Node, i Position, x *Data) <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      if i == (*p).s </span><span class="cov0" title="0">{
         *x = (*p).x
         if (*p).l == nil &amp;&amp; (*p).r == nil </span><span class="cov0" title="0">{
            *p = nil
         }</span> else<span class="cov0" title="0"> {
            tree.copy(p)
            defer tree.release(*p)// TODO what
            *p = tree.join((*p).l, (*p).r, (*p).s)
         }</span>
         <span class="cov0" title="0">return</span>
      }
      <span class="cov0" title="0">tree.copy(p)
      if i &lt; (*p).s </span><span class="cov0" title="0">{
         p = deleteL(*p)
      }</span> else<span class="cov0" title="0"> {
         p = deleteR(*p, &amp;i)
      }</span>
   }
}

func (tree *TreapTopDown) insert(p **Node, i Position, n *Node) <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      if *p == nil </span><span class="cov0" title="0">{
         *p = n
         return
      }</span>
      <span class="cov0" title="0">if (*p).y &lt;= n.y </span><span class="cov0" title="0">{
         n.l, n.r = tree.Tree.split(*p, i)
         n.s = i
         *p = n
         return
      }</span>
      <span class="cov0" title="0">tree.copy(p)
      if i &lt;= (*p).s </span><span class="cov0" title="0">{
         p = insertL(*p)
      }</span> else<span class="cov0" title="0"> {
         p = insertR(*p, &amp;i)
      }</span>
   }
}

func (tree *TreapTopDown) Insert(i Position, x Data) <span class="cov0" title="0">{
   // assert(i &lt;= tree.size)
   tree.size++
   tree.insert(&amp;tree.root, i, tree.allocate(Node{x: x, y: tree.Source.Uint64()}))
}</span>

func (tree *TreapTopDown) Delete(i Position) (x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.delete(&amp;tree.root, i, &amp;x)
   tree.size--
   return
}</span>

func (tree TreapTopDown) split(i Size) (Tree, Tree) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   tree.share(tree.root)
   l, r := tree.Tree.split(tree.root, i)

   return Tree{arena: tree.arena, root: l, size: i},
      Tree{arena: tree.arena, root: r, size: tree.size - i}
}</span>

func (tree TreapTopDown) Split(i Position) (List, List) <span class="cov0" title="0">{
   // assert(i &lt;= tree.Size())
   l, r := tree.split(i)
   return &amp;TreapTopDown{Tree: l, Source: tree.Source},
      &amp;TreapTopDown{Tree: r, Source: tree.Source}
}</span>

func (tree *TreapTopDown) Select(i Size) Data <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   return tree.lookup(tree.root, i)
}</span>

func (tree *TreapTopDown) Update(i Size, x Data) <span class="cov0" title="0">{
   // assert(i &lt; tree.Size())
   tree.copy(&amp;tree.root)
   tree.update(tree.root, i, x)
}</span>

// TODO: Figure out a standard naming for "that"

func (tree TreapTopDown) Join(that List) List <span class="cov0" title="0">{
   tree.share(tree.root)
   tree.share(that.(*TreapTopDown).root)
   return &amp;TreapTopDown{
      Tree{
         arena: tree.arena,
         root:  tree.join(tree.root, that.(*TreapTopDown).root, tree.size),
         size:  tree.size + that.(*TreapTopDown).size,
      },
      tree.Source,
   }
}</span>

func (tree TreapTopDown) verifyMaxRankHeap(p *Node) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">invariant(rank(p) &gt;= rank(p.l))
   invariant(rank(p) &gt;= rank(p.r))

   tree.verifyMaxRankHeap(p.l)
   tree.verifyMaxRankHeap(p.r)</span>
}

func (tree TreapTopDown) Verify() <span class="cov0" title="0">{
   tree.verifySizes()
   tree.verifyMaxRankHeap(tree.root)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package binarytree

import (
   "arena"
   "binarysearch/abstract/list"
)

//type ExteriorHeightsAlongTheSpines = [2][]int

//type InteriorHeightsAlongTheSpines = [2][]int

//type SymmetricWeightPerLevel = [2][]Size

// TODO I don't think this interface has any Data
type BinaryTree interface {
   Root() *Node
   Size() list.Size

   InteriorHeightsAlongTheSpines() [2][]int
   ExteriorHeightsAlongTheSpines() [2][]int
   SymmetricWeightPerLevel() [2][]list.Size
}

// The internal path length of a binary tree that has n internal nodes is
// sum (i=1 to n) leveli where leveli is the length of the path
// from the root to internal node i .
//
// In a complete binary tree
// one leveli is 0 ,
// two leveli s are 1 ,
// four leveli s are 2 ,
// eight leveli s are 4 , and so on.

// That is, the external path length of a full binary tree equals the
// internal path length plus twice the number of internal nodes

// // Returns the total number of links between p* and all nodes reachable BST p*.
//func InternalPathLength(p BinaryTreeNode, s Size) Size {
//   if reflect.DataOf(p).IsNil() {
//      return 0
//   }
//   // assert(p.Count() == s)
//   iL := InternalPathLength(p.Left(), p.SizeOfLeftSubtree(s))
//   iR := InternalPathLength(p.Right(), p.SizeOfRightSubtree(s))
//   return s - 1 + iL + iR // TODO reference this
//}
//
//func Count(p BinaryTreeNode) Size {
//   if p == nil {
//      return 0
//   } else {
//      return 1 + Count(p.Left()) + Count(p.Right())
//   }
//}

//
// // Returns the average path length of all nodes reachable BST p*.
//func AveragePathLength(p BinaryTreeNode, s Size) float64 {
//   if s == 0 {
//      return 0
//   }
//   return float64(p.InternalPathLength(s)) / float64(s)
//}

type Tree struct {
   arena *arena.Arena
   root *Node
   size list.Size
}

// Clone creates a shallow copy of the tree and shares its root with the copy.
func (tree *Tree) Clone() Tree <span class="cov8" title="1">{
   if tree.arena == nil </span><span class="cov8" title="1">{
      tree.arena = arena.NewArena()
   }</span>
   <span class="cov8" title="1">tree.share(tree.root)
   return *tree</span>
}

func (tree Tree) Free() <span class="cov8" title="1">{
   if tree.arena != nil </span><span class="cov8" title="1">{
      tree.arena.Free()
   }</span>
}

//
//func (tree Tree) Values() []Data {
//   values := make([]Data, 0, tree.size)
//   tree.Each(func(x Data) {
//      values = append(values, x)
//   })
//   return values
//}
//
//func (tree *Tree) build(Datas []Data) *Node {
//   if len(Datas) == 0 {
//      return nil
//   }
//   m := len(Datas) - (len(Datas) &gt;&gt; 1)
//
//   return tree.allocate(Node{
//      x: Datas[m],
//      s: Size(m),
//      l: tree.build(Datas[:m]),
//      r: tree.build(Datas[m+1:]),
//   })
//}

func (tree *Tree) insert(p **Node, s list.Size, i list.Position, x list.Data) <span class="cov8" title="1">{
   for </span><span class="cov8" title="1">{
      if *p == nil </span><span class="cov8" title="1">{
         *p = tree.allocate(Node{x: x})
         return
      }</span>
      <span class="cov8" title="1">tree.copy(p)
      sl := (*p).s
      sr := s - (*p).s - 1

      if i &gt; sl </span><span class="cov8" title="1">{
         p = insertR(*p, &amp;i)
         s = sr
      }</span> else<span class="cov8" title="1"> {
         p = insertL(*p)
         s = sl
      }</span>
   }
}

func (tree *Tree) Insert(i list.Size, x list.Data) <span class="cov8" title="1">{
   tree.insert(&amp;tree.root, tree.size, i, x)
   tree.size++
}</span>

//func (tree *Tree) Split(i Size) (Tree, Tree) {
//   // assert(i &lt;= tree.size)
//
//   var l, r *Node
//   tree.partition(tree.root, i, &amp;l, &amp;r)
//
//   return Tree{arena: tree.arena, root: l, size: i},
//          Tree{arena: tree.arena, root: r, size: tree.size - i}
//}

func (tree Tree) Verify() <span class="cov8" title="1">{
   tree.verifySize(tree.root, tree.size)
}</span>

//
//func (tree Tree) Root() *Node {
//  return tree.root
//}

func (tree Tree) Size() list.Size <span class="cov8" title="1">{
   return tree.size
}</span>

func (tree Tree) Root() *Node <span class="cov0" title="0">{
   return tree.root
}</span>

func (tree Tree) lookup(p *Node, i list.Size) list.Data <span class="cov8" title="1">{
   for </span><span class="cov8" title="1">{
      if i == p.s </span><span class="cov8" title="1">{
         return p.x
      }</span>
      <span class="cov8" title="1">if i &lt; p.s </span><span class="cov8" title="1">{
         p = p.l
      }</span> else<span class="cov8" title="1"> {
         i = i - p.s - 1
         p = p.r
      }</span>
   }
}

//func (tree *Tree) Select(i Size) Data {
//  // assert(i &lt; tree.Size())
//  return tree.lookup(tree.root, i)
//}

//func (tree *Tree) Update(i Size, x Data) {
//   // assert(i &lt; tree.Size())
//   tree.pathcopy(&amp;tree.root)
//   tree.update(tree.root, i, x)
//}

func (tree Tree) Each(visit func(list.Data)) <span class="cov8" title="1">{
   tree.root.inorder(visit)
}</span>

//
//func (tree *Tree) dissolve(p **Node, s Size) Data {
//   defer tree.release(*p)
//   x := (*p).x
//
//   if (*p).l == nil { *p = (*p).r; return x }
//   if (*p).r == nil { *p = (*p).l; return x }
//
//   if (*p).sizeL() &lt;= (*p).sizeR(s) {
//      m := tree.deleteMin(&amp;(*p).r)
//      m.l = (*p).l
//      m.r = (*p).r
//      m.s = (*p).s
//      m.y = (*p).y
//      *p = m
//   } else {
//      m := tree.deleteMax(&amp;(*p).l)
//      m.l = (*p).l
//      m.r = (*p).r
//      m.s = (*p).s - 1
//      m.y = (*p).y
//      *p = m
//   }
//   return x
//}

//func (tree *Tree) dissolve(p *Node, s Size) *Node {
//   if p.l == nil { tree.release(p); return p.r }
//   if p.r == nil { tree.release(p); return p.l }
//   if p.sizeL() &lt; p.sizeR(s) {
//      defer tree.release(p)
//      var x *Node
//      p.r, x = tree.deleteMin2(p.r)
//      p.x = x.x
//   } else {
//      defer tree.release(p)
//      p.x = tree.deleteMax(&amp;p.l).x
//      p.s = (*p).s - 1
//   }
//   return p
//}

func (tree *Tree) dissolve(p *Node, s list.Size) *Node <span class="cov0" title="0">{
   defer tree.release(p)
   if p.l == nil </span><span class="cov0" title="0">{
      return p.r
   }</span>
   <span class="cov0" title="0">if p.r == nil </span><span class="cov0" title="0">{
      return p.l
   }</span>
   <span class="cov0" title="0">if p.sizeL() &lt;= p.sizeR(s) </span><span class="cov0" title="0">{
      r := tree.deleteMin(&amp;p.r)
      r.l = p.l
      r.r = p.r
      r.s = p.s
      r.y = p.y
      return r
   }</span> else<span class="cov0" title="0"> {
      l := tree.deleteMax(&amp;p.l)
      l.r = p.r
      l.l = p.l
      l.s = p.s - 1
      l.y = p.y
      return l
   }</span>
}

func (tree *Tree) delete(p **Node, s list.Size, i list.Size) (x list.Data) <span class="cov0" title="0">{
   for </span><span class="cov0" title="0">{
      tree.copy(p)
      if i == (*p).s </span><span class="cov0" title="0">{
         x := (*p).x
         *p = tree.dissolve(*p, s)
         return x
      }</span>
      <span class="cov0" title="0">if i &lt; (*p).s </span><span class="cov0" title="0">{
         s = (*p).s
         (*p).s = (*p).s - 1
         p = &amp;(*p).l
      }</span> else<span class="cov0" title="0"> {
         i = i - (*p).s - 1
         s = s - (*p).s - 1
         p = &amp;(*p).r
      }</span>
   }
}

//func (p *Node) deleteL(r **Node, s Size, i Position) (**Node, Size, Position) {
//   s = p.i
//   p.i--
//   *r = p
//   r = &amp;p.l
//   return r, s, i
//}
//
//func (p *Node) deleteR(n **Node, s Size, i Position) (**Node, Size, Position) {
//   i = i - (*p).i - 1
//   s = s - (*p).i - 1
//   *n = p
//   n = &amp;p.r
//   return n, s, i
//}
// Deletes the node at position `i` from the tree.
// Returns the data that was in the deleted Data.
//func (tree *Tree) Delete(i Size) Data {
//   // assert(i &lt; tree.Size())
//   x := tree.delete(&amp;tree.root, tree.size, i)
//   tree.size--
//   return x
//}

func (tree Tree) verifySizes() <span class="cov0" title="0">{
   tree.verifySize(tree.root, tree.size)
}</span>

func (tree Tree) InteriorHeightsAlongTheSpines() (h [2][]int) <span class="cov0" title="0">{
   if tree.root == nil </span><span class="cov0" title="0">{
      return
   }</span>
   //
   <span class="cov0" title="0">for l := tree.root.l; l != nil; l = l.l </span><span class="cov0" title="0">{
      h[0] = append(h[0], l.r.height()+1)
   }</span>
   <span class="cov0" title="0">for r := tree.root.r; r != nil; r = r.r </span><span class="cov0" title="0">{
      h[1] = append(h[1], r.l.height()+1)
   }</span>

   // Reverse the left spine.
   <span class="cov0" title="0">i := 0
   j := len(h[0]) - 1
   for i &lt; j </span><span class="cov0" title="0">{
      h[0][i], h[0][j] = h[0][j], h[0][i]
      i++
      j--
   }</span>
   <span class="cov0" title="0">return</span>
}

func (tree Tree) ExteriorHeightsAlongTheSpines() (h [2][]int) <span class="cov0" title="0">{
   if tree.root == nil </span><span class="cov0" title="0">{
      return
   }</span>
   //
   <span class="cov0" title="0">for l := tree.root.l; l != nil; l = l.l </span><span class="cov0" title="0">{
      h[0] = append(h[0], l.height())
   }</span>
   <span class="cov0" title="0">for r := tree.root.r; r != nil; r = r.r </span><span class="cov0" title="0">{
      h[1] = append(h[1], r.height())
   }</span>

   // Reverse the left spine.
   <span class="cov0" title="0">i := 0
   j := len(h[0]) - 1
   for i &lt; j </span><span class="cov0" title="0">{
      h[0][i], h[0][j] = h[0][j], h[0][i]
      i++
      j--
   }</span>
   <span class="cov0" title="0">return</span>
}

func (tree Tree) countNodesPerLevel(p *Node, counter *[]list.Size, level int) <span class="cov0" title="0">{
   if p == nil </span><span class="cov0" title="0">{
      return
   }</span>
   // Add more levels to the counter as needed on the way down.
   <span class="cov0" title="0">if len(*counter) &lt;= level </span><span class="cov0" title="0">{
      *counter = append(*counter, 0)
   }</span>
   <span class="cov0" title="0">(*counter)[level]++
   tree.countNodesPerLevel(p.l, counter, level+1)
   tree.countNodesPerLevel(p.r, counter, level+1)</span>
}

func (tree Tree) SymmetricWeightPerLevel() (weights [2][]list.Size) <span class="cov0" title="0">{
   if tree.root == nil </span><span class="cov0" title="0">{
      return
   }</span>
   <span class="cov0" title="0">tree.countNodesPerLevel(tree.root.l, &amp;weights[0], 0)
   tree.countNodesPerLevel(tree.root.r, &amp;weights[1], 0)
   return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
